<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ZAB协议</title>
      <link href="/2020/05/17/fen-bu-shi/zab-xie-yi/"/>
      <url>/2020/05/17/fen-bu-shi/zab-xie-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="ZAB-协议"><a href="#ZAB-协议" class="headerlink" title="ZAB 协议"></a>ZAB 协议</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>ZAB（Zookeeper Atomic Broadcast）是为 ZooKeeper 设计的崩溃恢复原子广播协议，它保证 ZooKeeper 集群数据的一致性和命令的全局有序性。</p><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><p>在介绍 ZAB 协议之前首先要知道 ZooKeeper 相关的几个概念，才能更好的了解 ZAB 协议。</p><h4 id="集群角色"><a href="#集群角色" class="headerlink" title="集群角色"></a>集群角色</h4><ul><li><p><strong>Leader ：</strong>同一时间集群总只允许有一个 Leader ，提供对客户端的读写功能，负责将数据同步至各个节点。</p></li><li><p><strong>Follower ：</strong>提供对客户端读功能，写请求则转发给 Leader 处理，当 Leader 崩溃失联之后参与 Leader 选举。</p></li><li><p><strong>Observer ：</strong>与 Follower 不同的是不参与 Leader 选举。</p></li></ul><h4 id="服务状态"><a href="#服务状态" class="headerlink" title="服务状态"></a>服务状态</h4><ul><li><p><strong>LOOKING ：</strong>当节点认为集群中没有 Leader ，服务器会进入 LOOKING 状态，目的是为了查找或者选举 Leader 。</p></li><li><p><strong>FOLLOWING ：</strong>Follower 角色。</p></li><li><p><strong>LEADING ：</strong>Leader 角色。</p></li><li><p><strong>OBSERVING ：</strong>Observer 角色。</p></li></ul><p>可以知道 ZooKeeper 是通过自身的状态来区分自己所属的角色，来执行自己应该的任务。</p><h4 id="ZAB-状态"><a href="#ZAB-状态" class="headerlink" title="ZAB 状态"></a>ZAB 状态</h4><p>ZooKeeper 还给 ZAB 定义了 4 种状态，反映了 ZooKeeper 从选举到对外提供服务的过程中的四个步骤。状态枚举定义：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> ZabState <span class="token punctuation">{</span>    ELECTION<span class="token punctuation">,</span>    DISCOVERY<span class="token punctuation">,</span>    SYNCHRONIZATION<span class="token punctuation">,</span>    BROADCAST<span class="token punctuation">}</span></code></pre><ul><li><p><strong>ELECTION ：</strong>集群进入选举状态，此过程会选出一个节点作为 Leader 角色。</p></li><li><p><strong>DISCOVERY ：</strong>连接上 Leader ，响应 Leader 心跳，并且检测 Leader 的角色是否更改，通过此步骤之后选举出的 Leader 才能执行真正职务。</p></li><li><p><strong>SYNCHRONIZATION ：</strong>整个集群都确认 Leader 之后，将会把 Leader 的数据同步到各个节点，保证整个集群的数据一致性。</p></li><li><p><strong>BROADCAST ：</strong>过渡到广播状态，集群开始对外提供服务。</p></li></ul><h4 id="ZXID"><a href="#ZXID" class="headerlink" title="ZXID"></a>ZXID</h4><p>ZXID 是极为重要的概念，它是一个 <code>long</code> 型（64位）整数，分为两部分：<strong>纪元（epoch）</strong>部分和<strong>计数器（counter）</strong>部分，是一个<strong>全局有序</strong>的数字。</p><p><code>epoch</code> 代表当前集群所属哪个 Leader ，Leader 的选举就类似一个朝代的更替，你前朝的剑不能斩本朝的官，用 epoch 代表当前命令的有效性，counter 是一个递增的数字。</p><h3 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h3><p>基础概念介绍完了，下面开始介绍 ZAB 协议是怎么支持 Leader 选举的。进行 Leader 选举有三个问题，什么时候进行？选举规则？选择流程？</p><p>下面我会一一解答这三个问题：</p><ol><li><p><strong>选举发生的时机</strong></p><p>Leader 发生选举有两个时机。</p><p>一个是服务启动的时候当整个集群都没有 Leader 节点会进入选举状态，如果 Leader 已经存在就会告诉该节点 Leader 的信息，自己连接上 Leader ，整个集群不用进入选举状态。</p><p>还有一个就是在服务运行中，可能会出现各种情况，服务宕机、断电、网络延迟很高的时候 Leader 都不能再对外提供服务了，所以当其他节点通过心跳检测到 Leader 失联之后，集群也会进入选举状态。</p></li><li><p><strong>选举规则</strong></p><p>进入投票选举流程，怎么才能选举出 Leader ？或者说按照什么规则来让其他节点都能选举你当 Leader 。</p><p>ZAB 协议是按照几个比较规则来进行投票的筛选，如果你的票比我更好，就修改自身的投票信息，改投你当 Leader 。</p><p>下面代码是 ZooKeeper 投票比较规则：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/* * We return true if one of the following three cases hold: * 1- New epoch is higher * 2- New epoch is the same as current epoch, but new zxid is higher * 3- New epoch is the same as current epoch, new zxid is the same *  as current zxid, but server id is higher. */</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newEpoch <span class="token operator">></span> curEpoch<span class="token punctuation">)</span>        <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newEpoch <span class="token operator">==</span> curEpoch<span class="token punctuation">)</span>            <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newZxid <span class="token operator">></span> curZxid<span class="token punctuation">)</span>                <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newZxid <span class="token operator">==</span> curZxid<span class="token punctuation">)</span>                    <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>newId <span class="token operator">></span> curId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>当其他节点的<strong>纪元（epoch）</strong>比自身高投它，如果纪元相同比较自身的 <strong>ZXID</strong> 的大小，选举 ZXID 大的节点，这里的 ZXID 代表节点所提交事务最大的 ID ，ZXID 越大代表该节点的数据越完整。</p><p>最后如果 epoch 和 ZXID 都相等，则比较服务的 <strong>serverId</strong> ，这个 ID 是配置 ZooKeeper 集群时所配置的，所以我们配置 ZooKeeper 集群的时候可以把服务性能更高的集群的 serverId 配置大些，让性能好的机器担任 Leader 角色。</p></li><li><p><strong>选举流程</strong></p><p>时机和规则都有了，下面就是 Leader 的选举流程：</p><p><img src="https://s1.ax1x.com/2020/05/17/Y2bedH.png" alt="选举流程"></p></li></ol><ul><li>所有节点第一票先选举自己当 Leader ，将投票信息广播出去；</li><li>从队列中接受投票信息；</li><li>按照规则判断是否需要更改投票信息，将更改后的投票信息再次广播出去；</li><li>判断是否有超过一半的投票选举同一个节点，如果是根据投票结果设置自己的服务状态，选举结束，否则继续进入投票流程。</li></ul><p><strong>举例</strong></p><p><img src="https://s1.ax1x.com/2020/05/17/Y2brOU.png" alt=""></p><p>上图来自《ZooKeeper：分布式过程协同技术详解》，整体流程还是比较简单，这里就不具体分析了。</p><h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>集群在经过 Leader 选举之后还会有<strong>连接 Leader</strong> 和<strong>同步</strong>两个步骤，这里就不具体分析这两个步骤的流程了，主要介绍集群对外提供服务如何保证各个节点数据的一致性。</p><p>ZAB 在广播状态中保证以下特征：</p><ul><li><strong>可靠传递：</strong>如果消息 m 由一台服务器传递，那么它最终将由所有服务器传递。</li><li><strong>全局有序：</strong>如果一个消息 a 在消息 b 之前被一台服务器交付，那么所有服务器都交付了 a 和 b ，并且 a 先于 b 。</li><li><strong>因果有序：</strong>如果消息 a 在因果上先于消息 b 并且二者都被交付，那么 a 必须排在 b 之前。</li></ul><p><strong>有序性</strong>是 ZAB 协议必须要保证的一个属性，因为 ZooKeeper 是以类似目录结构的数据结构存储数据的，必须要求命名的有序性。</p><p>比如一个命名 a 创建路径为 <code>/test</code> ，然后命名 b 创建路径为 <code>/test/123</code> ，如果不能保证有序性，b 命名在 a 之前，b 命令会因为父节点不存在而创建失败。</p><p><img src="https://s1.ax1x.com/2020/05/17/Y2LN2q.png" alt="Broadcast"></p><p>如上图所示，整个写请求类似一个<strong>二阶段</strong>的提交。</p><p>当收到客户端的写请求的时候会经历以下几个步骤：</p><ul><li><p>Leader 收到客户端的写请求，生成一个事务（Proposal），其中包含了 ZXID ；</p></li><li><p>Leader 开始广播该事务，需要注意的是所有节点的通讯都是由一个 FIFO 的队列维护的；</p></li><li><p>Follower 接受到事务之后，将事务写入本地磁盘，写入成功之后返回 Leader 一个 ACK ；</p></li><li><p>Leader 收到过半的 ACK 之后，开始提交本事务，并广播事务提交信息；</p></li><li><p>从节点开始提交本事务。</p></li></ul><p>由以上流程可知，ZooKeeper 通过二阶段提交来保证集群中数据的一致性，因为只需要收到过半的 ACK 就可以提交事务，所以 ZooKeeper 的数据并不是强一致性。</p><p>ZAB 协议的有序性保证是通过几个方面来体现的。</p><p>第一，服务之前用 TCP 协议进行通讯，保证在网络传输中的有序性；</p><p>第二，节点之前都维护了一个 FIFO 的队列，保证全局有序性；</p><p>第三，通过全局递增的 ZXID 保证因果有序性。</p><h3 id="状态流转"><a href="#状态流转" class="headerlink" title="状态流转"></a>状态流转</h3><p>前面介绍了 ZooKeeper 服务状态有四种，ZAB 状态也有四种。这里就简单介绍一个他们之间的状态流转，更能加深对 ZAB 协议在 ZooKeeper 工作流程中作用的理解。</p><p><img src="https://s1.ax1x.com/2020/05/17/Y2LfsK.png" alt="状态流转"></p><ul><li><p>服务在启动或者和 Leader 失联之后服务状态转为 <strong>LOOKING</strong> ；</p></li><li><p>如果 Leader 不存在选举 Leader ，如果存在直接连接 Leader ，此时 ZAB 协议状态为 <strong>ELECTION</strong> ；</p></li><li><p>如果有超过半数的投票选择同一台 Server ，则 Leader 选举结束，被选举为 Leader 的 Server 服务状态为 <strong>LEADING</strong> ，其他 Server 服务状态为 <strong>FOLLOWING/OBSERVING</strong> ；</p></li><li><p>所有 Server 连接上 Leader ，此时 ZAB 协议状态为 <strong>DISCOVERY</strong> ；</p></li><li><p>Leader 同步数据给 Learner（从节点），使各个从节点数据和 Leader 保持一致，此时 ZAB 协议状态为 <strong>SYNCHRONIZATION</strong> ；</p></li><li><p>同步超过一半的 Server 之后，集群对外提供服务，此时 ZAB 状态为 <strong>BROADCAST</strong> 。</p></li></ul><p>可以知道整个 ZooKeeper 服务的工作流程类似一个状态机的转换，而 ZAB 协议就是驱动服务状态流转的关键，理解了 ZAB 就理解了 ZooKeeper 工作的关键原理。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文对 ZAB 协议在 ZooKeeper 中的工作流程做了简单的介绍，希望对大家理解学习 ZooKeeper 有所帮助。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议 </tag>
            
            <tag> ZooKeeper </tag>
            
            <tag> ZAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是ZooKeeper？</title>
      <link href="/2020/05/17/fen-bu-shi/shi-me-shi-zookeeper/"/>
      <url>/2020/05/17/fen-bu-shi/shi-me-shi-zookeeper/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-ZooKeeper-？"><a href="#什么是-ZooKeeper-？" class="headerlink" title="什么是 ZooKeeper ？"></a>什么是 ZooKeeper ？</h2><p><img src="https://s1.ax1x.com/2020/05/16/YcjsZF.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/16/Ycj7IH.png" alt=""></p><p><strong>————— 第二天 —————</strong></p><p><img src="https://s1.ax1x.com/2020/05/16/YcY21H.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/16/YcYjun.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/17/YgY3a6.jpg" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/17/YgYYGD.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/17/YgYtRe.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/17/YgYNxH.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/17/YgYaMd.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/17/YgYwqI.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/17/YgYBZt.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/17/YgYDdP.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/16/YctlgH.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/16/YctJbt.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/17/YgYyi8.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/17/YgtNkV.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/17/YgtafU.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/17/Ygt0l4.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/17/YgtB6J.png" alt=""></p><h3 id="ZooKeeper-的数据模型"><a href="#ZooKeeper-的数据模型" class="headerlink" title="ZooKeeper 的数据模型"></a>ZooKeeper 的数据模型</h3><p>ZooKeeper 的数据模型是什么样子呢？它很像数据结构当中的树，也很像文件系统的目录。</p><p><img src="https://s1.ax1x.com/2020/05/17/Ygty01.png" alt=""></p><p>树是由节点所组成，ZooKeeper 的数据存储也同样是基于节点，这种节点叫做 <strong>Znode</strong> 。</p><p>但是，不同于树的节点，Znode 的引用方式是<strong>路径引用</strong>，类似于文件路径：</p><p> / 动物 / 仓鼠</p><p> / 植物 / 荷花</p><p>这样的层级结构，让每一个 Znode 节点拥有唯一的路径，就像命名空间一样对不同信息作出清晰的隔离。</p><p><img src="https://s1.ax1x.com/2020/05/17/Ygt46H.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/17/YgtonA.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/17/Ygt77t.png" alt=""></p><ul><li><strong>data：</strong>Znode 存储的数据信息。</li></ul><ul><li><strong>ACL：</strong>记录 Znode 的访问权限，即哪些人或哪些 IP 可以访问本节点。</li></ul><ul><li><strong>stat：</strong>包含 Znode 的各种元数据，比如事务 ID 、版本号、时间戳、大小等等。</li></ul><ul><li><strong>child：</strong>当前节点的子节点引用，类似于二叉树的左孩子右孩子。</li></ul><p>这里需要注意一点，ZooKeeper 是为读多写少的场景所设计。Znode 并不是用来存储大规模业务数据，而是用于存储少量的状态和配置信息，<strong>每个节点的数据最大不能超过 1 MB</strong> 。</p><p><img src="https://s1.ax1x.com/2020/05/17/Ygtqtf.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/17/YgtX9S.png" alt=""></p><h3 id="ZooKeeper-的基本操作和事件通知"><a href="#ZooKeeper-的基本操作和事件通知" class="headerlink" title="ZooKeeper 的基本操作和事件通知"></a>ZooKeeper 的基本操作和事件通知</h3><p>ZooKeeper 包含了哪些基本操作呢？这里列举出比较常用的 API ：</p><ul><li><strong>create：</strong>创建节点</li></ul><ul><li><strong>delete：</strong>删除节点</li></ul><ul><li><strong>exists：</strong>判断节点是否存在</li></ul><ul><li><strong>getData：</strong>获得一个节点的数据</li></ul><ul><li><strong>setData：</strong>设置一个节点的数据</li></ul><ul><li><strong>getChildren：</strong>获取节点下的所有子节点</li></ul><p>这其中，<code>exists</code> 、<code>getData</code> 、<code>getChildren</code> 属于<strong>读</strong>操作。ZooKeeper 客户端在请求读操作的时候，可以选择是否设置 <strong>Watch</strong> 。</p><blockquote><p>Watch 是什么意思呢？</p></blockquote><p>我们可以理解成是注册在特定 Znode 上的触发器。当这个 Znode 发生改变，也就是调用了 <code>create</code> 、<code>delete</code> 、<code>setData</code> 方法的时候，将会触发 Znode 上注册的对应事件，请求 Watch 的客户端会接收到<strong>异步通知</strong>。</p><p>具体交互过程如下：</p><ul><li>客户端调用 <code>getData</code> 方法，<strong>watch</strong> 参数是 <code>true</code> 。服务端接到请求，返回节点数据，并且在对应的<strong>哈希表</strong>里插入被 <strong>Watch</strong> 的 <code>Znode</code> 路径，以及 <strong>Watcher</strong> 列表。</li></ul><p><img src="https://s1.ax1x.com/2020/05/17/YgNZjJ.jpg" alt=""></p><ul><li>当被 <strong>Watch</strong> 的 <code>Znode</code> 已删除，服务端会查找哈希表，找到该 <code>Znode</code> 对应的所有 <strong>Watcher</strong> ，异步通知客户端，并且删除哈希表中对应的 <strong>Key-Value</strong> 。</li></ul><p><img src="https://s1.ax1x.com/2020/05/17/YgNuH1.jpg" alt=""></p><h3 id="ZooKeeper-的一致性"><a href="#ZooKeeper-的一致性" class="headerlink" title="ZooKeeper 的一致性"></a>ZooKeeper 的一致性</h3><p><img src="https://s1.ax1x.com/2020/05/17/Y26KGd.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/17/Y26YdS.png" alt=""></p><p>ZooKeeper 的集群长成什么样呢？就像下图这样：</p><p><img src="https://s1.ax1x.com/2020/05/17/Y26coF.png" alt="ZooKeeper 集群"></p><p>ZooKeeper Service 集群是<strong>一主多从</strong>结构。</p><p><strong>在更新数据时，首先更新到主节点（这里的节点是指服务器，不是 Znode），再同步到从节点。</strong></p><p><strong>在读取数据时，直接读取任意从节点。</strong></p><p>为了保证主从节点的数据一致性，ZooKeeper 采用了 <strong>ZAB 协议</strong>，这种协议非常类似于一致性算法 <strong>Paxos</strong> 和 <strong>Raft</strong> 。</p><p><img src="https://s1.ax1x.com/2020/05/17/Y26LJH.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/17/Y2cQkF.png" alt=""></p><p>在学习 ZAB 之前，我们需要首先了解 ZAB 协议所定义的三种节点状态：</p><ul><li><strong>Looking：</strong>选举状态。</li></ul><ul><li><strong>Following：</strong>Follower 节点（从节点）所处的状态。</li></ul><ul><li><strong>Leading：</strong>Leader 节点（主节点）所处状态。</li></ul><p>我们还需要知道<strong>最大 ZXID</strong> 的概念：</p><p>最大 ZXID 也就是节点本地的最新事务编号，包含 <strong>epoch</strong> 和<strong>计数</strong>两部分。epoch 是纪元的意思，相当于 Raft 算法选主时候的 term 。</p><p>假如 ZooKeeper 当前的主节点挂掉了，集群会进行<strong>崩溃恢复</strong>。ZAB 的崩溃恢复分成三个阶段：</p><p><strong>1. Leader Election</strong></p><p>选举阶段，此时集群中的节点处于 <strong>Looking</strong> 状态。它们会各自向其他节点发起投票，投票当中包含自己的服务器 ID 和最新事务 ID（ZXID）。</p><p><img src="https://s1.ax1x.com/2020/05/17/Y22uiF.png" alt=""></p><p>接下来，节点会用自身的 ZXID 和从其他节点接收到的 ZXID 做比较，如果发现别人家的 ZXID 比自己大，也就是数据比自己新，那么就重新发起投票，投票给目前已知最大的 ZXID 所属节点。</p><p><img src="https://s1.ax1x.com/2020/05/17/Y2WYCD.png" alt=""></p><p>每次投票后，服务器都会统计投票数量，判断是否有某个节点得到半数以上的投票。如果存在这样的节点，该节点将会成为准 Leader ，状态变为 Leading 。其他节点的状态变为 Following 。</p><p><img src="https://s1.ax1x.com/2020/05/17/Y2WxVx.png" alt=""></p><p>这就相当于，一群武林高手经过激烈的竞争，选出了武林盟主。</p><p><strong>2. Discovery</strong></p><p>发现阶段，用于在从节点中发现最新的 ZXID 和事务日志。或许有人会问：既然 Leader 被选为主节点，已经是集群里数据最新的了，为什么还要从节点中寻找最新事务呢？</p><p>这是为了防止某些意外情况，比如因网络原因在上一阶段产生多个 Leader 的情况。</p><p>所以这一阶段，Leader 集思广益，接收所有 Follower 发来各自的最新 epoch 值。Leader 从中选出最大的 epoch ，基于此值加 1 ，生成新的 epoch 分发给各个 Follower 。</p><p>各个 Follower 收到全新的 epoch 后，返回 ACK 给 Leader ，带上各自最大的 ZXID 和历史事务日志。Leader 选出最大的 ZXID ，并更新自身历史日志。</p><p><strong>3. Synchronization</strong></p><p>同步阶段，把 Leader 刚才收集得到的最新历史事务日志，同步给集群中所有的 Follower 。只有当半数 Follower 同步成功，这个准 Leader 才能成为正式的 Leader 。</p><p>自此，故障恢复正式完成。</p><p><img src="https://s1.ax1x.com/2020/05/17/Y2fMRg.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/17/Y2f3ss.png" alt=""></p><p>什么是 <strong>Broadcast</strong> 呢？简单来说，就是 ZooKeeper 常规情况下更新数据的时候，由 Leader 广播到所有的 Follower 。其过程如下：</p><ul><li>客户端发出写入数据请求给任意 Follower 。</li></ul><ul><li>Follower 把写入数据请求转发给 Leader 。</li></ul><ul><li>Leader 采用<strong>二阶段提交</strong>方式，先发送 <strong>Propose</strong> 广播给 Follower 。</li></ul><ul><li>Follower 接到 Propose 消息，写入日志成功后，返回 ACK 消息给 Leader 。</li></ul><ul><li>Leader 接到半数以上 ACK 消息，返回成功给客户端，并且广播 <strong>Commit</strong> 请求给 Follower 。</li></ul><p><img src="https://s1.ax1x.com/2020/05/17/Y2hpmn.png" alt="Broadcast"></p><p>ZAB 协议既不是强一致性，也不是弱一致性，而是处于两者之间的<strong>单调一致性</strong>。它依靠事务 ID 和版本号，保证了数据的更新和读取是有序的。</p><h3 id="ZooKeeper-的应用场景"><a href="#ZooKeeper-的应用场景" class="headerlink" title="ZooKeeper 的应用场景"></a>ZooKeeper 的应用场景</h3><p><img src="https://s1.ax1x.com/2020/05/17/Y2hkfU.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/17/Y2hKTx.png" alt=""></p><h4 id="1-分布式锁"><a href="#1-分布式锁" class="headerlink" title="1. 分布式锁"></a>1. 分布式锁</h4><p>这是雅虎研究员设计 ZooKeeper 的初衷。利用 ZooKeeper 的<strong>临时顺序节点</strong>，可以轻松实现分布式锁。</p><h4 id="2-服务注册和发现"><a href="#2-服务注册和发现" class="headerlink" title="2. 服务注册和发现"></a>2. 服务注册和发现</h4><p>利用 Znode 和 Watcher ，可以实现分布式服务的注册和发现。最著名的应用就是阿里的分布式 RPC 框架 Dubbo 。</p><h4 id="3-共享配置和状态信息"><a href="#3-共享配置和状态信息" class="headerlink" title="3.  共享配置和状态信息"></a>3.  共享配置和状态信息</h4><p>Redis 的分布式解决方案 Codis ，就利用了 ZooKeeper 来存放数据路由表和 <code>codis-proxy</code> 节点的元信息。同时 <code>codis-config</code> 发起的命令都会通过 ZooKeeper 同步到各个存活的 <code>codis-proxy</code> 。</p><p>此外，Kafka 、HBase 、Hadoop 也都依靠 ZooKeeper 同步节点信息，实现高可用。</p><p><img src="https://s1.ax1x.com/2020/05/17/Y2hR7q.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/17/Y2hfA0.png" alt=""></p><p><strong>几点补充：</strong></p><ul><li>ZAB 协议相对比较复杂，小灰对此也只是浅层次的理解，有兴趣的小伙伴们可以去官方社区进行进一步学习。</li></ul><ul><li>本漫画纯属娱乐，还请大家尽量珍惜当下的工作，切勿模仿小灰的行为哦。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZooKeeper </tag>
            
            <tag> ZAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是拜占庭将军问题？</title>
      <link href="/2020/05/16/fen-bu-shi/shi-me-shi-bai-zhan-ting-jiang-jun-wen-ti/"/>
      <url>/2020/05/16/fen-bu-shi/shi-me-shi-bai-zhan-ting-jiang-jun-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是拜占庭将军问题？"><a href="#什么是拜占庭将军问题？" class="headerlink" title="什么是拜占庭将军问题？"></a>什么是拜占庭将军问题？</h2><p><img src="https://s1.ax1x.com/2020/05/16/YcYB0x.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/16/YcY74S.png" alt=""></p><p><strong>————— 第二天 —————</strong></p><p><img src="https://s1.ax1x.com/2020/05/16/YcY21H.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/16/YcYjun.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/16/Yct94U.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/16/YctFgJ.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/16/YctZHx.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/16/YctlgH.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/16/YctJbt.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/16/YctrKs.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/16/YctcV0.png" alt=""></p><h3 id="什么是拜占庭将军问题？-1"><a href="#什么是拜占庭将军问题？-1" class="headerlink" title="什么是拜占庭将军问题？"></a>什么是拜占庭将军问题？</h3><p>在很久很久以前，拜占庭是东罗马帝国的首都。那个时候罗马帝国国土辽阔，为了防御目的，因此每个军队都分隔很远，将军与将军之间只能靠信使传递消息。</p><p><img src="https://s1.ax1x.com/2020/05/17/YgYMrR.png" alt=""></p><p>在打仗的时候，拜占庭军队内所有将军必需达成<strong>一致的共识</strong>，才能更好地赢得胜利。但是，在军队内有可能存有叛徒，扰乱将军们的决定。</p><p><img src="https://s1.ax1x.com/2020/05/16/YcXKnU.png" alt=""></p><p>这时候，在已知有成员不可靠的情况下，其余忠诚的将军需要在不受叛徒或间谍的影响下达成一致的协议。</p><p>莱斯利·兰伯特（Leslie Lamport）通过这个比喻，表达了计算机网络中所存在的一致性问题。这个问题被称为<strong>拜占庭将军问题</strong>。</p><p><img src="https://s1.ax1x.com/2020/05/16/Ych5tO.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/16/Yc4Ccj.png" alt=""></p><h3 id="什么是-Raft-算法？"><a href="#什么是-Raft-算法？" class="headerlink" title="什么是 Raft 算法？"></a>什么是 Raft 算法？</h3><p>Raft 算法是一种简单易懂的共识算法。它依靠 <strong>状态机</strong> 和 <strong>主从同步</strong> 的方式，在各个节点之间实现数据的一致性。</p><p>在学习 Raft 算法的时候，大家需要了解 Raft 的两个核心要点：</p><ul><li><p><strong>选取主节点</strong></p></li><li><p><strong>同步数据</strong></p></li></ul><p>不难理解，使用主从同步的方式，可以让集群各个节点的数据更新以主节点为准，从而保证了一致性。那么，如何选取主节点呢？</p><p><img src="https://s1.ax1x.com/2020/05/16/Yc4NCD.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/16/Yc4R2Q.png" alt=""></p><p>我们的出生，离不开无数小蝌蚪之间的激烈竞争。在竞争的过程中，某个速度最快运气最好的小蝌蚪最终胜出，让我们诞生到了这个世界。</p><p>同样道理，Raft 算法在选择主节点的过程中，也是通过多个节点之间的<strong>投票竞争</strong>。</p><p>说到这里，不得不说一下 Raft 算法的状态机。Raft 算法为节点定义了三种角色：</p><ul><li><p><strong>Leader</strong>（主节点）</p></li><li><p><strong>Follower</strong>（从节点）</p></li><li><p><strong>Candidate</strong>（参与投票竞争的节点）</p></li></ul><p>让我们来看一看选主的具体流程：</p><p><strong>第一步</strong>，在最初，还没有一个主节点的时候，所有节点的身份都是 Follower 。每一个节点都有自己的计时器，当计时达到了超时时间（Election Timeout），该节点会转变为 Candidate 。</p><p><img src="https://s1.ax1x.com/2020/05/16/Yc5diT.png" alt=""></p><p><strong>第二步</strong>，成为 Candidate 的节点，会首先给自己投票，然后向集群中其他所有的节点发起请求，要求大家都给自己投票。</p><p><img src="https://s1.ax1x.com/2020/05/16/Yc5WFK.png" alt=""></p><p><strong>第三步</strong>，其他收到投票请求且还未投票的 Follower 节点会向发起者投票，发起者收到反馈通知后，票数增加。</p><p><img src="https://s1.ax1x.com/2020/05/16/YcIM01.png" alt=""></p><p><strong>第四步</strong>，当得票数超过了集群节点数量的一半，该节点晋升为 Leader 节点。Leader 节点会立刻向其他节点发出通知，告诉大家自己才是老大。收到通知的节点全部变为 Follower ，并且各自的计时器清零。</p><p><img src="https://s1.ax1x.com/2020/05/16/YcIt6H.png" alt=""></p><p>这里需要说明一点，每个节点的超时时间都是不一样的。比如 A 节点的超时时间是 3 秒，B 节点的超时时间是 5 秒，C 节点的超时时间是 4 秒。这样一来，A 节点将会最先发起投票请求，而不是所有节点同时发起。</p><p>为什么这样设计呢？设想如果所有节点同时发起投票，必然会导致大家的票数差不多，形成僵局，谁也当不成老大。</p><p>那么，成为 Leader 的节点是否就坐稳了老大的位置呢？并不是。Leader 节点需要每隔一段时间向集群其他节点发送<strong>心跳通知</strong>，表明你们的老大还活着。</p><p><img src="https://s1.ax1x.com/2020/05/16/YcIt6H.png" alt=""></p><p>一旦 Leader 节点挂掉，发不出通知，那么计时达到了超时时间的 Follower 节点会转变为 Candidate 节点，发起选主投票，周而复始……</p><p><img src="https://s1.ax1x.com/2020/05/16/YcoZUP.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/16/YcoNCT.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/16/YcojMQ.png" alt=""></p><p>让我们来看一看数据同步的流程：</p><p><strong>第一步</strong>，由客户端提交数据到 Leader 节点。</p><p><img src="https://s1.ax1x.com/2020/05/16/YcTFRU.png" alt=""></p><p><strong>第二步</strong>，由 Leader 节点把数据复制到集群内所有的 Follower 节点。如果一次复制失败，会不断进行重试。</p><p><img src="https://s1.ax1x.com/2020/05/16/YcTMi6.png" alt=""></p><p><strong>第三步</strong>，Follower 节点们接收到复制的数据，会反馈给 Leader 节点。</p><p><img src="https://s1.ax1x.com/2020/05/16/YcTNdI.png" alt=""></p><p><strong>第四步</strong>，如果 Leader 节点接收到超过半数的 Follower 反馈，表明复制成功。于是提交自己的数据，并通知客户端数据提交成功。</p><p><img src="https://s1.ax1x.com/2020/05/16/YcT0W8.png" alt=""></p><p><strong>第五步</strong>，由 Leader 节点通知集群内所有的 Follower 节点提交数据，从而完成数据同步流程。</p><p><img src="https://s1.ax1x.com/2020/05/16/YcTHm9.png" alt=""></p><h3 id="共识算法的应用场景？"><a href="#共识算法的应用场景？" class="headerlink" title="共识算法的应用场景？"></a>共识算法的应用场景？</h3><p><img src="https://s1.ax1x.com/2020/05/16/Yc7pOH.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/16/Yc7Eff.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/16/YcXJ91.jpg" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/16/Yc7BA1.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/16/Yc7738.png" alt=""></p><h4 id="Paxos-算法："><a href="#Paxos-算法：" class="headerlink" title="Paxos 算法："></a>Paxos 算法：</h4><p>早期的共识算法，由拜占庭将军问题的提出者 Leslie Lamport 所发明。谷歌的分布式锁服务 Chubby 就是以 Paxos 算法为基础。</p><h4 id="ZAB-算法："><a href="#ZAB-算法：" class="headerlink" title="ZAB 算法："></a>ZAB 算法：</h4><p>Zookeeper 所使用的一致性算法，在流程上和 Raft 算法比较接近。</p><h4 id="PBFT-算法："><a href="#PBFT-算法：" class="headerlink" title="PBFT 算法："></a>PBFT 算法：</h4><p>区块链技术所使用的共识算法之一，适用于私有链的共识。</p><p><img src="https://s1.ax1x.com/2020/05/16/YcHnC6.png" alt=""></p><blockquote><p>更正：Raft ，ZAB ，Paxos 解决的是节点故障问题，而非拜占庭问题（节点故意欺骗）。因为它们都没有办法进行拜占庭容错，只是单纯的可信前提下的分布式容错。PBFT 解决了拜占庭问题，这对于区块链的共识是必要的。</p><p>以小灰的理解，拜占庭的叛徒有两种情况，一种是节点故障，一种是节点故意捣乱。Raft 解决的是节点故障，以及捣乱者不是主节点的情况，但无法解决捣乱者成为主节点的情况。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Raft </tag>
            
            <tag> 拜占庭 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抢红包算法</title>
      <link href="/2020/05/15/suan-fa/qiang-hong-bao-suan-fa/"/>
      <url>/2020/05/15/suan-fa/qiang-hong-bao-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="抢红包算法"><a href="#抢红包算法" class="headerlink" title="抢红包算法"></a>抢红包算法</h2><p><img src="https://s1.ax1x.com/2020/05/14/YDhTaQ.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/14/YD4iGR.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/14/YD4uIH.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/14/YD4Gsf.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/14/YD40Wn.png" alt=""></p><blockquote><p>发出一个固定金额的红包，由若干个人来抢，需要满足哪些规则？</p></blockquote><p><strong>1.所有人抢到金额之和等于红包金额，不能超过，也不能少于。</strong></p><p><strong>2.每个人至少抢到一分钱。</strong></p><p><strong>3.要保证所有人抢到金额的几率相等。</strong></p><p><img src="https://s1.ax1x.com/2020/05/14/YD4IQx.png" alt=""></p><blockquote><p>小灰的思路是什么样呢？</p></blockquote><p>每次抢到的金额 = 随机区间 <strong>( 0 , 剩余金额)</strong></p><p><img src="https://s1.ax1x.com/2020/05/14/YD4XYd.png" alt=""></p><blockquote><p>为什么这么说呢？让我们看一个栗子：</p></blockquote><p>假设有 10 个人，红包总额 100 元。</p><p>第一个人的随机范围是<strong>（0 , 100 元)</strong>，平均可以抢到 <strong>50 元</strong>。</p><p>假设第一个人随机到 50 元，那么剩余金额是 100 - 50 = 50 元。</p><p>第二个人的随机范围是 <strong>（0 , 50 元）</strong>，平均可以抢到 <strong>25 元</strong>。</p><p>假设第二个人随机到 25 元，那么剩余金额是 50 - 25 = 25 元。</p><p>第三个人的随机范围是 <strong>（0 , 25 元）</strong>，平均可以抢到 <strong>12.5 元</strong>。</p><p>以此类推，每一次随机范围越来越小。</p><p><img src="https://s1.ax1x.com/2020/05/14/YD58h9.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/14/YD54Ag.png" alt=""></p><h3 id="方法-1-：二倍均值法"><a href="#方法-1-：二倍均值法" class="headerlink" title="方法 1 ：二倍均值法"></a><strong>方法 1 ：二倍均值法</strong></h3><p>剩余红包金额为 M ，剩余人数为 N ，那么有如下公式：</p><p>每次抢到的金额 = 随机区间 <strong>（0 , M / N * 2）</strong></p><p>这个公式，保证了<strong>每次随机金额的平均值是相等的</strong>，不会因为抢红包的先后顺序而造成不公平。</p><blockquote><p>举个栗子：</p></blockquote><p>假设有 10 个人，红包总额 100 元。</p><p>100/10*2 = 20 ，所以第一个人的随机范围是<strong>（0 ，20 )</strong> ，平均可以抢到 <strong>10 元</strong>。</p><p>假设第一个人随机到 10 元，那么剩余金额是 100 - 10 = 90 元。</p><p>90/9*2 = 20 ，所以第二个人的随机范围同样是<strong>（0 ，20 )</strong>，平均可以抢到 <strong>10 元</strong>。</p><p>假设第二个人随机到 10 元，那么剩余金额是 90-10 = 80 元。</p><p>80/8*2 = 20 ，所以第三个人的随机范围同样是<strong>（0 ，20 )</strong>，平均可以抢到 <strong>10 元</strong>。</p><p>以此类推，每一次随机范围的均值是相等的。</p><p><img src="https://s1.ax1x.com/2020/05/14/YDIBrV.png" alt=""></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//抢红包算法，金额参数以分为单位</span><span class="token keyword">public</span> <span class="token keyword">static</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">divideRedPackage</span><span class="token punctuation">(</span>Integer totalAmount<span class="token punctuation">,</span> Integer totalPeopleNum<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> amountList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Integer restAmount <span class="token operator">=</span> totalAmount<span class="token punctuation">;</span>    Integer restPeopleNum <span class="token operator">=</span> totalPeopleNum<span class="token punctuation">;</span>    Random random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> totalPeopleNum <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//随机范围：[1，剩余人均金额的两倍)，左闭右开，保证最小随机数为 1</span>        <span class="token keyword">int</span> amount <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>restAmount <span class="token operator">/</span> restPeopleNum <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        restAmount <span class="token operator">-=</span> amount<span class="token punctuation">;</span>        restPeopleNum <span class="token operator">--</span><span class="token punctuation">;</span>        amountList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    amountList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>restAmount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> amountList<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> amountList <span class="token operator">=</span> <span class="token function">divideRedPackage</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Integer amount <span class="token operator">:</span> amountList<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"抢到金额："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">divide</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>程序输出结果如下：</strong></p><p>抢到金额：2.92</p><p>抢到金额：1.48</p><p>抢到金额：3.05</p><p>抢到金额：0.53</p><p>抢到金额：0.45</p><p>抢到金额：1.36</p><p>抢到金额：1.02</p><p>抢到金额：1.99</p><p>抢到金额：1.3</p><p>抢到金额：0.48</p><p>抢到金额：0.83</p><p>抢到金额：2.89</p><p>抢到金额：0.94</p><p>抢到金额：2.11</p><p>抢到金额：3.13</p><p>抢到金额：0.91</p><p>抢到金额：2.64</p><p>抢到金额：2.02</p><p>抢到金额：2.88</p><p>抢到金额：1.13</p><p>抢到金额：2.09</p><p>抢到金额：1.37</p><p>抢到金额：2.41</p><p>抢到金额：2.13</p><p>抢到金额：1.32</p><p>抢到金额：0.44</p><p>抢到金额：1.62</p><p>抢到金额：1.89</p><p>抢到金额：2.23</p><p>抢到金额：0.44</p><p><img src="https://s1.ax1x.com/2020/05/14/YD7qG4.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/15/YD7LRJ.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/15/YD7jMR.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/15/YDHPiD.png" alt=""></p><h3 id="方法-2-：线段切割法"><a href="#方法-2-：线段切割法" class="headerlink" title="方法 2 ：线段切割法"></a><strong>方法 2 ：线段切割法</strong></h3><p>何谓线段切割法？我们可以把红包总金额想象成一条很长的线段，而每个人抢到的金额，则是这条主线段所拆分出的若干子线段。</p><p><img src="https://s1.ax1x.com/2020/05/15/YDHwYF.png" alt=""></p><p>如何确定每一条子线段的长度呢？由“切割点”来决定。当 N 个人一起抢红包的时候，就需要确定 N-1 个切割点。</p><p>因此，当 N 个人一起抢总金额为 M 的红包时，我们需要做 N-1 次随机运算，以此确定 N-1 个切割点。随机的范围区间是<strong>（1 , M）</strong>。</p><p>当所有切割点确定以后，子线段的长度也随之确定。这样每个人来抢红包的时候，只需要顺次领取与子线段长度等价的红包金额即可。</p><p>这就是<strong>线段切割法</strong>的思路。在这里需要注意以下两点：</p><p><strong>1.当随机切割点出现重复，如何处理。</strong></p><p><strong>2.如何尽可能降低时间复杂度和空间复杂度。</strong></p><p><img src="https://s1.ax1x.com/2020/05/15/YDHsyR.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/15/YDH2TK.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 抢红包算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2020/05/13/she-ji-mo-shi/dan-li-mo-shi/"/>
      <url>/2020/05/13/she-ji-mo-shi/dan-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>单例模式确保一个类只有一个实例，并提供全局访问点。</p><h3 id="八种写法"><a href="#八种写法" class="headerlink" title="八种写法"></a>八种写法</h3><blockquote><p>饿汉式（静态常量）（可用）</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> Singleton INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>饿汉式（静态代码块）（可用）</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> Singleton INSTANCE<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>懒汉式（线程不安全）（不可用）</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>懒汉式（线程安全）（不推荐）</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>懒汉式（线程不安全）（不推荐）</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>双重检查（推荐面试使用）</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//防止重排序和保证可见性</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//新建对象实际有3个步骤（非原子操作）:1.创建空的对象2.调用构造方法3.赋值到对象上</span>                    <span class="token comment" spellcheck="true">//重排序:1.创建空的对象2.赋值到对象上3.调用构造方法，导致对象内的属性为空</span>                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>静态内部类（可用）</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonInstance</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//只有需要 Singleton 实例时才会加载（懒汉+安全）</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> SingletonInstance<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>枚举单例。最好的方法（1. 写法简单 2. 线程安全有保障 3. 避免反序列化破坏单例）</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> Singleton <span class="token punctuation">{</span>    INSTANCE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//代表类中的任何一个方法，通过 Singleton.INSTANCE.whatever() 调用</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">whatever</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ</title>
      <link href="/2020/05/09/fen-bu-shi/rocketmq/"/>
      <url>/2020/05/09/fen-bu-shi/rocketmq/</url>
      
        <content type="html"><![CDATA[<h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>消息队列</strong>在互联网技术存储方面使用如此广泛，几乎所有的后端技术面试官都要在<strong>消息队列</strong>的使用和原理方面对小伙伴们进行 360° 的刁难。作为一个在互联网公司面一次拿一次 offer 的面霸，打败了无数竞争对手，每次都只能看到无数落寞的身影失望的离开，略感愧疚（<strong>请允许我使用一下夸张的修辞手法</strong>）。于是在一个寂寞难耐的夜晚，我痛定思痛，决定开始写<strong>《吊打面试官》</strong>系列，希望能帮助各位读者以后面试势如破竹，对面试官进行 360° 的反击，吊打问你的面试官，让一同面试的同僚瞠目结舌，疯狂收割大厂offer ！</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="RocketMQ-简介"><a href="#RocketMQ-简介" class="headerlink" title="RocketMQ 简介"></a>RocketMQ 简介</h3><blockquote><p>RocketMQ 是一个纯 Java 、分布式、队列模型的开源消息中间件，前身是 MetaQ ，是阿里参考 Kafka 特点研发的一个队列模型的消息中间件，后开源给 Apache 基金会成为了 Apache 的顶级开源项目，具有高性能、高可靠、高实时、分布式特点。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9hjvwekvkg309j06makn.gif" alt=""></p><p>在阿里巴巴内部围绕着 RocketMQ 内核打造了三款产品，分别是 <strong>MetaQ</strong> 、<strong>Notify</strong> 和 <strong>Aliware MQ</strong> 。</p><p>这三者分别采用了不同的模型，<strong>MetaQ</strong> 主要使用了拉模型，解决了顺序消息和海量堆积问题；<strong>Notify</strong> 主要使用了推模型，解决了事务消息；而云产品 <strong>Aliware MQ</strong> 则是提供了商业化的版本。</p><h4 id="经历多次双-11-洗礼的英雄"><a href="#经历多次双-11-洗礼的英雄" class="headerlink" title="经历多次双 11 洗礼的英雄"></a>经历多次双 11 洗礼的英雄</h4><p>   在备战2016年双十一时，<strong>RocketMq</strong> 团队重点做了<strong>两件事情</strong>，优化慢请求与统一存储引擎。</p><ul><li><strong>优化慢请求</strong>：这里主要是解决在海量高并发场景下降低慢请求对整个集群带来的抖动，<strong>毛刺问题</strong>。这是一个极具挑战的技术活，团队同学经过长达 1 个多月的跟进调优，从双十一的复盘情况来看，99.996% 的延迟落在了 10ms 以内，<strong>而 99.6% 的延迟在 1ms 以内</strong>。优化主要集中在 <strong>RocketMQ</strong> 存储层算法优化、JVM 与操作系统调优。更多的细节大家可以参考《万亿级数据洪峰下的分布式消息引擎》。</li><li><strong>统一存储引擎</strong>：主要解决的消息引擎的高可用，成本问题。在多代消息引擎共存的前提下，我们对 <strong>Notify</strong> 的存储模块进行了全面移植与替换。</li></ul><p><strong>RocketMQ 天生为金融互联网领域而生</strong>，追求高可靠、高可用、高并发、低延迟，是一个阿里巴巴由内而外成功孕育的典范，除了阿里集团上千个应用外，根据我们不完全统计，国内至少有上百家单位、科研教育机构在使用。</p><p><strong>RocketMQ</strong> 在阿里集团也被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，<strong>binglog</strong> 分发等场景。</p><h4 id="它所拥有的功能"><a href="#它所拥有的功能" class="headerlink" title="它所拥有的功能"></a>它所拥有的功能</h4><p>我们直接去 <strong>GitHub</strong> 上看 <strong>Apache</strong> 对它的描述可能会好点：</p><p><img src="https://s1.ax1x.com/2020/05/09/YMj2mq.png" alt="RocketMQ 功能"></p><p>功能完整到爆炸有木有？</p><h4 id="它的项目结构组成是怎么样子的？"><a href="#它的项目结构组成是怎么样子的？" class="headerlink" title="它的项目结构组成是怎么样子的？"></a>它的项目结构组成是怎么样子的？</h4><blockquote><p>GitHub 地址：<a href="https://github.com/apache/rocketmq" target="_blank" rel="noopener">https://github.com/apache/rocketmq</a></p></blockquote><p><img src="https://s1.ax1x.com/2020/05/09/YMjL0x.jpg" alt="RocketMQ 项目结构"></p><p><strong>它的核心模块：</strong></p><ul><li><strong>rocketmq-broker：</strong>接受生产者发来的消息并存储（通过调用 rocketmq-store ），消费者从这里取得消息。</li><li><strong>rocketmq-client：</strong>提供发送、接受消息的客户端 API 。</li><li><strong>rocketmq-namesrv：</strong>NameServer ，类似于 ZooKeeper ，这里保存着消息的 TopicName 、队列等运行时的元信息。</li><li><strong>rocketmq-common：</strong>通用的一些类、方法、数据结构等。</li><li><strong>rocketmq-remoting：</strong>基于 Netty4 的 client/server + fastjson 序列化 + 自定义二进制协议。</li><li><strong>rocketmq-store：</strong>消息、索引存储等。</li><li><strong>rocketmq-filtersrv：</strong>消息过滤器 Server ，需要注意的是，要实现这种过滤，需要上传代码到 MQ ！（一般而言，我们利用 <code>Tag</code> 足以满足大部分的过滤需求，如果更灵活更复杂的过滤需求，可以考虑 <code>filtersrv</code> 组件）。</li><li><strong>rocketmq-tools：</strong>命令行工具。</li></ul><h3 id="它的架构组成，或者理解为为什么它这么快？这么强？这么厉害？"><a href="#它的架构组成，或者理解为为什么它这么快？这么强？这么厉害？" class="headerlink" title="它的架构组成，或者理解为为什么它这么快？这么强？这么厉害？"></a>它的架构组成，或者理解为为什么它这么快？这么强？这么厉害？</h3><p>它主要有四大核心组成部分：<strong>NameServer</strong> 、<strong>Broker</strong> 、<strong>Producer</strong> 以及 <strong>Consumer</strong> 四部分。</p><p><img src="https://s1.ax1x.com/2020/05/09/YMv8EV.jpg" alt="RocketMQ 架构组成"></p><blockquote><p><strong>Tips：</strong>我们可以看到 <strong>RocketMQ</strong> 啥都是<strong>集群</strong>部署的，这是它<strong>吞吐量大</strong>，<strong>高可用</strong>的原因之一，集群的模式也很花哨，可以支持多 Master 模式、多 Master 多 Slave 异步复制模式、多 Master 多 Slave 同步双写模式。</p></blockquote><p>而且这个模式好像 Kafka 啊！（我这里是废话，本身就是阿里基于 Kafka 的很多特性研发的）。</p><h3 id="分别介绍下各个集群组成部分吧"><a href="#分别介绍下各个集群组成部分吧" class="headerlink" title="分别介绍下各个集群组成部分吧"></a>分别介绍下各个集群组成部分吧</h3><h4 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h4><blockquote><p>主要负责对于源数据的管理，包括了对于 <strong>Topic</strong> 和路由信息的管理。</p></blockquote><p><strong>NameServer</strong> 是一个功能齐全的服务器，其角色类似 Dubbo 中的 ZooKeeper ，但 NameServer 与 ZooKeeper 相比<strong>更轻量</strong>。主要是因为每个 NameServer 节点互相之间是独立的，没有任何信息交互。</p><p><strong>NameServer</strong> 压力不会太大，平时主要开销是在<strong>维持心跳</strong>和<strong>提供 Topic-Broker 的关系数据</strong>。</p><p>但有一点需要注意，Broker 向 NameServer 发心跳时， 会带上当前自己所负责的所有 <strong>Topic</strong> 信息，如果 <strong>Topic</strong> 个数太多（万级别），会导致一次心跳中，单 Topic 的数据就几十M，网络情况差的话， 网络传输失败，心跳失败，导致 NameServer 误认为 Broker 心跳失败。</p><p><strong>NameServer</strong> 被设计成几乎无状态的，可以横向扩展，节点之间相互之间无通信，通过部署多台机器来标记自己是一个伪集群。</p><p>每个 Broker 在启动的时候会到 NameServer 注册，Producer 在发送消息前会根据 Topic 到 <strong>NameServer</strong> 获取到 Broker 的路由信息，Consumer 也会定时获取 Topic 的路由信息。</p><p>所以从功能上看 NameServer 应该是和 ZooKeeper 差不多，据说 RocketMQ 的早期版本确实是使用的 ZooKeeper ，后来改为了自己实现的 NameServer 。</p><p>我们看一下 <strong>Dubbo</strong> 中注册中心的角色，是不是真的一毛一样，师出同门相似点真的很多：</p><p><img src="https://s1.ax1x.com/2020/05/09/YMxp5T.jpg" alt="Dubbo 架构"></p><h4 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h4><blockquote><p>消息生产者，负责产生消息，一般由业务系统负责产生消息。</p></blockquote><ul><li><p><strong>Producer</strong> 由用户进行分布式部署，消息由 <strong>Producer</strong> 通过多种负载均衡模式发送到 <strong>Broker</strong> 集群，发送低延时，支持快速失败。</p></li><li><p><strong>RocketMQ</strong> 提供了三种方式发送消息：<strong>同步</strong>、<strong>异步</strong>和<strong>单向</strong>。</p></li><li><p><strong>同步发送：</strong>同步发送指消息发送方发出数据后会在收到接收方发回响应之后才发下一个数据包。一般用于重要通知消息，例如重要通知邮件、营销短信。</p></li><li><p><strong>异步发送：</strong>异步发送指发送方发出数据后，不等接收方发回响应，接着发送下个数据包，一般用于可能链路耗时较长而对响应时间敏感的业务场景，例如用户视频上传后通知启动转码服务。</p></li><li><p><strong>单向发送：</strong>单向发送是指只负责发送消息而不等待服务器回应且没有回调函数触发，适用于某些耗时非常短但对可靠性要求并不高的场景，例如日志收集。</p></li></ul><h4 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h4><blockquote><p>消息中转角色，负责<strong>存储消息</strong>，转发消息。</p></blockquote><ul><li><strong>Broker</strong> 是具体提供业务的服务器，单个 Broker 节点与所有的 NameServer 节点保持长连接及心跳，并会定时将 <strong>Topic</strong> 信息注册到 NameServer ，顺带一提底层的通信和连接都是<strong>基于 Netty 实现</strong>的。</li><li><strong>Broker</strong> 负责消息存储，以 Topic 为纬度支持轻量级的队列，单机可以支撑上万队列规模，支持消息推拉模型。</li><li>官网上有数据显示：具有<strong>上亿级消息堆积能力</strong>，同时可<strong>严格保证消息的有序性</strong>。</li></ul><h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><blockquote><p>消息消费者，负责消费消息，一般是后台系统负责异步消费。</p></blockquote><ul><li><p><strong>Consumer</strong> 也由用户部署，支持 <strong>PUSH</strong> 和 <strong>PULL</strong> 两种<strong>消费模式</strong>，支持<strong>集群消费</strong>和<strong>广播消费</strong>，提供<strong>实时的消息订阅机制</strong>。</p><ul><li><p><strong>Pull：</strong>拉取型消费者（Pull Consumer）。主动从消息服务器拉取信息，只要批量拉取到消息，用户应用就会启动消费过程，所以 Pull 称为<strong>主动</strong>消费型。</p></li><li><p><strong>Push：</strong>推送型消费者（Push Consumer）。封装了消息的拉取、消费进度和其它的内部维护工作，将消息到达时执行的回调接口留给用户应用程序来实现。所以 Push 称为<strong>被动</strong>消费类型，但从实现上看还是从消息服务器中拉取消息，不同于 Pull 的是 Push 首先要注册<strong>消费监听器</strong>，当监听器处触发后才开始消费消息。</p></li></ul></li></ul><h3 id="消息领域模型"><a href="#消息领域模型" class="headerlink" title="消息领域模型"></a>消息领域模型</h3><p><img src="https://s1.ax1x.com/2020/05/09/YQS9c4.md.png" alt="消息领域模型"></p><h4 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h4><p><strong>Message</strong>（消息）就是要传输的信息。</p><p>一条消息必须有一个主题（Topic），主题可以看做是你的信件要邮寄的地址。</p><p>一条消息也可以拥有一个可选的标签（Tag）和额处的键值对，它们可以用于设置一个业务 Key 并在 Broker 上查找此消息以便在开发期间查找问题。</p><h4 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h4><p><strong>Topic</strong>（主题）可以看做消息的规类，它是消息的第一级类型。比如一个电商系统可以分为：交易消息、物流消息等，一条消息必须有一个 Topic 。</p><p><strong>Topic</strong> 与生产者和消费者的关系非常松散，一个 Topic 可以有 0 个、1 个、多个生产者向其发送消息，一个生产者也可以同时向不同的 Topic 发送消息。</p><p>一个 Topic 也可以被  0 个、1 个、多个消费者订阅。</p><h4 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h4><p><strong>Tag</strong>（标签）可以看作子主题，它是消息的第二级类型，用于为用户提供额外的灵活性。使用标签，同一业务模块不同目的的消息就可以用相同 Topic 而不同的 <strong>Tag</strong> 来标识。比如交易消息又可以分为：交易创建消息、交易完成消息等，一条消息可以没有 <strong>Tag</strong> 。</p><p>标签有助于保持您的代码干净和连贯，并且还可以为 <strong>RocketMQ</strong> 提供的查询系统提供帮助。</p><h4 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h4><p>分组，一个组可以订阅多个Topic。</p><p>分为 <strong>ProducerGroup</strong> 与 <strong>ConsumerGroup</strong> ，代表某一类的生产者和消费者，一般来说同一个服务可以作为Group，同一个Group一般来说发送和消费的消息都是一样的。</p><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>在 <strong>Kafka</strong> 中叫 Partition ，每个 Queue 内部是有序的，在 <strong>RocketMQ</strong> 中分为读和写两种队列，一般来说读写队列数量一致，如果不一致就会出现很多问题。</p><h4 id="Message-Queue"><a href="#Message-Queue" class="headerlink" title="Message Queue"></a>Message Queue</h4><p><strong>Message Queue</strong>（消息队列），主题被划分为一个或多个子主题，即消息队列。</p><p>一个 Topic 下可以设置多个消息队列，发送消息时执行该消息的 Topic ，RocketMQ 会轮询该 Topic 下的所有队列将消息发出去。</p><p>消息的物理管理单位。一个 Topic 下可以有多个 Queue ，Queue 的引入使得消息的存储可以分布式集群化，具有了水平扩展能力。</p><h4 id="Offset"><a href="#Offset" class="headerlink" title="Offset"></a>Offset</h4><p>在 <strong>RocketMQ</strong> 中，所有消息队列都是持久化，长度无限的数据结构，所谓长度无限是指队列中的每个存储单元都是定长，访问其中的存储单元使用 Offset 来访问，Offset 为 java long 类型，64 位，理论上在 100 年内不会溢出，所以认为是长度无限。</p><p>也可以认为 Message Queue 是一个长度无限的数组，<strong>Offset</strong> 就是下标。</p><h4 id="消息消费模式"><a href="#消息消费模式" class="headerlink" title="消息消费模式"></a>消息消费模式</h4><p>消息消费模式有两种：<strong>Clustering</strong>（集群消费）和 <strong>Broadcasting</strong>（广播消费）。</p><p><strong>默认情况下就是集群消费</strong>，该模式下一个消费者集群共同消费一个主题的多个队列，一个队列只会被一个消费者消费，如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。</p><p>而广播消费消息会发给消费者组中的每一个消费者进行消费。</p><h4 id="Message-Order"><a href="#Message-Order" class="headerlink" title="Message Order"></a>Message Order</h4><p><strong>Message Order</strong>（消息顺序）有两种：<strong>Orderly</strong>（顺序消费）和 <strong>Concurrently</strong>（并行消费）。</p><p>顺序消费表示消息消费的顺序同生产者为每个消息队列发送的顺序一致，所以如果正在处理全局顺序是强制性的场景，需要确保使用的主题只有一个消息队列。</p><p>并行消费不再保证消息顺序，消费的最大并行数量受每个消费者客户端指定的线程池限制。</p><h3 id="一次完整的通信流程是怎样的？"><a href="#一次完整的通信流程是怎样的？" class="headerlink" title="一次完整的通信流程是怎样的？"></a>一次完整的通信流程是怎样的？</h3><p>Producer 与 NameServer 集群中的其中一个节点（随机选择）建立长连接，定期从 NameServer 获取 <strong>Topic</strong> 路由信息，并向提供 Topic 服务的 <strong>Broker Master</strong> 建立长连接，且定时向 <strong>Broker</strong> 发送心跳。</p><p><strong>Producer</strong> <strong>只能</strong>将消息发送到 Broker Master ，但是 <strong>Consumer</strong> 则不一样，它<strong>同时</strong>和提供 Topic 服务的 Master 和 Slave 建立<strong>长连接</strong>，既可以从 Broker Master 订阅消息，也可以从 Broker Slave 订阅消息。</p><p>具体如下图：</p><p><img src="https://s1.ax1x.com/2020/05/09/YQ9Umj.jpg" alt="通信流程"></p><p>我上面说过它跟 <strong>Dubbo</strong> 像不是我瞎说的，就连它的注册过程都很像 <strong>Dubbo</strong> 的服务暴露过程。</p><p>是不是觉得很简单，但是你同时也产生了好奇心，每一步是怎么初始化启动的呢？我们一步步分析一下。</p><h4 id="NameService-启动流程"><a href="#NameService-启动流程" class="headerlink" title="NameService 启动流程"></a>NameService 启动流程</h4><p>在 org.apache.rocketmq.namesrv 目录下的 <strong>NamesrvStartup</strong> 这个启动类基本上描述了它的启动过程我们可以看一下代码：</p><ul><li><p>第一步是初始化配置。</p></li><li><p>d第二步是创建 <strong>NamesrvController</strong> 实例，并开启两个定时任务：</p><ul><li><p>每隔 10s 扫描一次 <strong>Broker</strong> ，移除处于不激活的 <strong>Broker</strong> ；</p></li><li><p>每隔 10s 打印一次 KV 配置。</p></li></ul><p><img src="https://s1.ax1x.com/2020/05/09/YQCGU1.jpg" alt="开启定时任务"></p></li><li><p>第三步注册钩子函数，启动服务器并监听 Broker 。</p></li></ul><blockquote><p>钩子：钩子是一种方法，它在抽象类中不做事，或者只做默认的事情，子类可以选择要不要去覆盖它。</p></blockquote><p><strong>NameService</strong> 还有很多东西的哈我这里就介绍它的启动流程，大家还可以去看看代码，还是很有意思的，比如路由注册会发送心跳包，还有<strong>心跳包的处理流程</strong>，<strong>路由删除</strong>，<strong>路由发现</strong>等。</p><h4 id="Producer-1"><a href="#Producer-1" class="headerlink" title="Producer"></a>Producer</h4><p>链路很长涉及的细节也多，我就发一下链路图。</p><p><img src="https://s1.ax1x.com/2020/05/09/YQPcw9.jpg" alt="Producer 链路"></p><p><strong>Producer</strong> 是消息发送方，那它怎么发送的呢？</p><p>通过轮训，<strong>Producer</strong> 轮询某个 <strong>Topic</strong> 下面的所有队列实现发送方的负载均衡。</p><p><img src="https://s1.ax1x.com/2020/05/09/YQF8Ej.png" alt="消息发送"></p><h4 id="Broker-1"><a href="#Broker-1" class="headerlink" title="Broker"></a>Broker</h4><p><strong>Broker</strong> 在 RocketMQ 中是进行处理 Producer 发送消息请求，Consumer 消费消息的请求，并且进行消息的持久化，以及 HA 策略和服务端过滤的模块，就是集群中很重的工作都是交给了 <strong>Broker</strong> 进行处理。</p><p><strong>Broker</strong> 模块是通过 BrokerStartup 进行启动的，会实例化 <strong>BrokerController</strong> ，并且调用其初始化方法。</p><p><img src="https://s1.ax1x.com/2020/05/09/YQFIVH.jpg" alt="Broker"></p><p>大家去看 <strong>Broker</strong> 的源码的话会发现，它的<strong>初始化流程很冗长</strong>，会根据配置创建很多线程池主要用来<strong>发送消息</strong>、<strong>拉取消息</strong>、<strong>查询消息</strong>、<strong>客户端管理</strong>和<strong>消费者管理</strong>，也有很多<strong>定时任务</strong>，同时也注册了很多<strong>请求处理器</strong>，用来发送拉取消息查询消息的。</p><h4 id="Consumer-1"><a href="#Consumer-1" class="headerlink" title="Consumer"></a>Consumer</h4><p>不说了直接怼图吧！</p><p><img src="https://s1.ax1x.com/2020/05/09/YQkMJ1.jpg" alt="Consumer"></p><p><strong>Consumer</strong> 是消息接收，那它怎么接收消息的呢？</p><p><img src="https://s1.ax1x.com/2020/05/09/YQk5lV.jpg" alt="消息接收"></p><p>消费端会通过 <strong>RebalanceService</strong> 线程，10 秒钟做一次基于 <strong>Topic</strong> 下的所有队列负载。</p><h2 id="面试常见问题分析"><a href="#面试常见问题分析" class="headerlink" title="面试常见问题分析"></a>面试常见问题分析</h2><h3 id="它的优缺点是啥？"><a href="#它的优缺点是啥？" class="headerlink" title="它的优缺点是啥？"></a>它的优缺点是啥？</h3><p><strong>RocketMQ 优点：</strong></p><ul><li><p>单机吞吐量：十万级。</p></li><li><p>可用性：非常高，分布式架构。</p></li><li><p>消息可靠性：经过参数优化配置，消息可以做到 0 丢失。</p></li><li><p>功能支持：MQ 功能较为完善，还是分布式的，扩展性好。</p></li><li><p>支持 10 亿级别的消息堆积，不会因为堆积导致性能下降。</p></li><li><p>源码是 Java ，我们可以自己阅读源码，定制自己公司的 MQ ，可以掌控 。</p></li><li><p>天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。</p></li><li><p><strong>RocketMQ</strong> 在稳定性上可能更值得信赖，这些业务场景在阿里双11已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 <strong>RocketMQ</strong> 。</p></li></ul><p><strong>RocketMQ 缺点：</strong></p><ul><li><p>支持的客户端语言不多，目前是 Java 及 C++ ，其中 C++ 不成熟。</p></li><li><p>社区活跃度不是特别活跃那种。</p></li><li><p>没有在 MQ 核心中去实现 <strong>JMS</strong> 等接口，有些系统要迁移需要修改大量代码。</p></li></ul><h3 id="消息去重"><a href="#消息去重" class="headerlink" title="消息去重"></a>消息去重</h3><p><strong>去重原则：</strong>使用业务端逻辑保持幂等性。</p><p><strong>幂等性：</strong>就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用，数据库的结果都是唯一的，不可变的。</p><p>只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样，需要业务端来实现。</p><p><strong>去重策略：</strong>保证每条消息都有唯一编号<strong>（比如唯一流水号）</strong>，且保证消息处理成功与去重表的日志同时出现。</p><p>建立一个消息表，拿到这个消息做数据库的 Insert 操作。给这个消息做一个唯一主键（Primary Key）或者唯一约束，那么就算出现重复消费的情况，就会导致主键冲突，那么就不再处理这条消息。</p><h3 id="消息重复"><a href="#消息重复" class="headerlink" title="消息重复"></a>消息重复</h3><p>消息领域有一个对消息投递的 QoS（Quality of Service，服务质量）定义，分为：</p><ul><li>最多一次（At Most Once）</li><li>至少一次（At Least Once）</li><li>仅一次（ Exactly Once）</li></ul><p>几乎所有的 MQ 产品都声称自己做到了<strong>At Least Once</strong> 。</p><p>既然是至少一次，那避免不了消息重复，尤其是在分布式网络环境下。</p><p>比如：网络原因闪断，ACK 返回失败等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将该消息分发给其它的消费者。</p><p>不同的消息队列发送的确认信息形式不同，例如 <strong>RabbitMQ</strong> 是发送一个 ACK 确认消息，<strong>RocketMQ</strong> 是返回一个 <strong>CONSUME_SUCCESS</strong> 成功标志，<strong>Kafka</strong> 实际上有个 <strong>Offset</strong> 的概念。</p><p><strong>RocketMQ</strong> 没有内置消息去重的解决方案，最新版本是否支持还需确认。</p><h3 id="消息的可用性"><a href="#消息的可用性" class="headerlink" title="消息的可用性"></a>消息的可用性</h3><p>当我们选择好了集群模式之后，那么我们需要关心的就是怎么去存储和复制这个数据，<strong>RocketMQ</strong> 对消息的刷盘提供了同步和异步的策略来满足我们的需求，当我们选择同步刷盘之后，如果刷盘超时会给返回 <strong>FLUSH_DISK_TIMEOUT</strong> ，如果是异步刷盘不会返回刷盘相关信息，选择同步刷盘可以尽最大程度满足我们的消息不会丢失。</p><p>除了存储有选择之后，我们的主从同步提供了同步和异步两种模式来进行复制，当然选择同步可以提升可用性，但是消息的发送 RT 时间会下降 10% 左右。</p><p><strong>RocketMQ</strong> 采用的是<strong>混合型</strong>的存储结构，即为 <strong>Broker</strong> 单个实例下所有的队列共用一个日志数据文件（即为 CommitLog ）来存储。</p><p>而 <strong>Kafka</strong> 采用的是<strong>独立型</strong>的存储结构，每个队列一个文件。</p><p>这里我认为，<strong>RocketMQ</strong> 采用混合型存储结构的缺点在于，会存在较多的随机读操作，因此读的效率偏低。同时消费消息需要依赖 <strong>ConsumeQueue</strong> ，构建该逻辑消费队列需要一定开销。</p><h3 id="RocketMQ-刷盘实现"><a href="#RocketMQ-刷盘实现" class="headerlink" title="RocketMQ 刷盘实现"></a>RocketMQ 刷盘实现</h3><p><strong>Broker</strong> 在消息的存取时直接操作的是内存（内存映射文件），这可以提供系统的吞吐量，但是无法避免机器掉电时数据丢失，所以需要持久化到磁盘中。</p><p>刷盘的最终实现都是使用 <strong>NIO</strong> 中的 <code>MappedByteBuffer.force()</code> 将映射区的数据写入到磁盘，如果是同步刷盘的话，在 <strong>Broker</strong> 把消息写到 <strong>CommitLog</strong> 映射区后，就会等待写入完成。</p><p>异步而言，只是唤醒对应的线程，不保证执行的时机，流程如图所示。</p><p><img src="https://s1.ax1x.com/2020/05/09/YQEtPA.jpg" alt="RocketMQ 刷盘实现"></p><ul><li><strong>同步刷盘方式：</strong>在返回写成功状态时，消息已经被写入磁盘。具体流程是，消息写入内存的 <strong>PAGECACHE</strong> 后，立刻通知刷盘线程刷盘，然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写成功的状态。</li><li><strong>异步刷盘方式：</strong>在返回写成功状态时，消息可能只是被写入了内存的 <strong>PAGECACHE</strong> ，写操作的返回快，吞吐量大；当内存里的消息量积累到一定程度时，统一触发写磁盘操作，快速写入。</li></ul><p><img src="https://s1.ax1x.com/2020/05/09/YQVMJs.png" alt="同步刷盘与异步刷盘"></p><blockquote><p>同步刷盘还是异步刷盘，是通过 Broker 配置文件里的 <code>flushDiskType</code> 参数设置的，这个参数被设置成 <strong>SYNC_FLUSH</strong> 、<strong>ASYNC_FLUSH</strong> 中的一个。</p></blockquote><h3 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h3><p>我简单的说一下我们使用的 <strong>RocketMQ</strong> 里面的一个简单实现吧。</p><p>生产者消费者一般需要保证顺序消息的话，可能就是一个业务场景下的，比如订单的创建、支付、发货、收货。</p><p>那这些东西是不是一个订单号呢？一个订单的肯定是一个订单号的说，那简单了呀。</p><p><strong>一个 Topic 下有多个队列</strong>，为了保证发送有序，<strong>RocketMQ</strong> 提供了 <strong>MessageQueueSelector</strong> 队列选择机制，它有三种实现：</p><p><img src="https://s1.ax1x.com/2020/05/09/YMGEi6.png" alt=""></p><p>我们可使用 <strong>Hash 取模法</strong>，让同一个订单发送到同一个队列中，再使用同步发送，只有同个订单的创建消息发送成功，再发送支付消息。这样，我们保证了发送有序。</p><p><strong>RocketMQ</strong> 的 Topic 内的队列机制，可以保证存储满足 <strong>FIFO</strong>（First Input First Output ，简单说就是指先进先出），剩下的只需要消费者顺序消费即可。</p><p><strong>RocketMQ</strong> 仅保证顺序发送，顺序消费由消费者业务保证！！！</p><p>这里很好理解，一个订单你发送的时候放到一个队列里面去，你同一个的订单号 Hash 一下是不是还是一样的结果，那肯定是一个消费者消费，那顺序是不是就保证了？</p><p>真正的顺序消费不同的中间件都有自己的不同实现我这里就举个例子，大家思路理解下。</p><blockquote><p><strong>Tips：</strong>有人问我，一个队列有序出去，一个消费者消费不就好了，我想说的是<strong>消费者是多线程</strong>的，你消息是有序的给它的，你能保证它是有序的处理的？还是一个消费成功了再发下一个<strong>稳妥</strong>。</p></blockquote><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><h4 id="Half-Message（半消息）"><a href="#Half-Message（半消息）" class="headerlink" title="Half Message（半消息）"></a>Half Message（半消息）</h4><p><strong>是指暂不能被 Consumer 消费的消息</strong>。Producer 已经把消息成功发送到了 Broker 端，但此消息被标记为 <code>暂不能投递</code> 状态，处于该种状态下的消息称为半消息。需要 Producer 对消息的 <code>二次确认</code> 后，Consumer 才能去消费它。</p><h4 id="消息回查"><a href="#消息回查" class="headerlink" title="消息回查"></a>消息回查</h4><p>由于网络闪段，生产者应用重启等原因。导致 <strong>Producer</strong> 端一直没有对 <strong>Half Message（半消息）</strong>进行<strong>二次确认</strong>。这时 <strong>Brock</strong> 服务器会定时扫描 <code>长期处于半消息的消息</code> ，会主动询问 <strong>Producer</strong> 端该消息的最终状态（ <strong>Commit</strong> 或者 <strong>Rollback</strong> ），该消息即为<strong>消息回查</strong>。</p><p><img src="https://s1.ax1x.com/2020/05/09/YQZVpR.jpg" alt="消息回查"></p><ol><li>A 服务先发送个 Half Message 给 Broker 端，消息中携带 B 服务 即将要 +100 元的信息。 </li><li>当 A 服务知道 Half Message 发送成功后，那么开始第 3 步执行本地事务。 </li><li>执行本地事务会有三种情况（1、执行成功 2、执行失败 3、网络等原因导致没有响应）。 </li><li>如果本地事务成功，那么 Producer 向 Broker 服务器发送 <strong>COMMIT_MESSAGE</strong> ，这样 B 服务就可以消费该 Message 。 </li><li>如果本地事务失败，那么 Producer 向 Broker 服务器发送 <strong>ROLLBACK_MESSAGE</strong> ，那么就会直接删除上面这条半消息。</li><li>如果因为网络等原因迟迟没有返回失败还是成功（<strong>UNKNOW</strong>），那么会执行 RocketMQ 的回调接口，来进行事务的回查。</li></ol><h3 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h3><ul><li><strong>Broker</strong> 端消息过滤：<br>在 <strong>Broker</strong> 中，按照 <strong>Consumer</strong> 的要求做过滤，优点是减少了对于 <strong>Consumer</strong> 无用消息的网络传输。缺点是增加了 Broker 的负担，实现相对复杂。</li><li><strong>Consumer</strong> 端消息过滤：<br>这种过滤方式可由应用完全自定义实现，但是缺点是很多无用的消息要传输到 <strong>Consumer</strong> 端。</li></ul><h3 id="Broker-的-Buffer-问题"><a href="#Broker-的-Buffer-问题" class="headerlink" title="Broker 的 Buffer 问题"></a>Broker 的 Buffer 问题</h3><p>Broker 的 <strong>Buffer</strong> 通常指的是 Broker 中一个队列的内存 Buffer 大小，这类 <strong>Buffer</strong> 通常大小有限。</p><p>另外，RocketMQ 没有内存 <strong>Buffer</strong> 概念，RocketMQ 的队列都是持久化磁盘，数据定期清除。</p><p>RocketMQ 同其它 MQ 有非常显著的区别，RocketMQ 的内存 <strong>Buffer</strong> 抽象成一个无限长度的队列，不管有多少数据进来都能装得下，这个无限是有前提的，Broker 会定期删除过期的数据。</p><p>例如 Broker 只保存 3 天的消息，那么这个 <strong>Buffer</strong> 虽然长度无限，但是 3 天前的数据会被从<strong>队尾</strong>删除。</p><h3 id="回溯消费"><a href="#回溯消费" class="headerlink" title="回溯消费"></a>回溯消费</h3><p>回溯消费是指 Consumer 已经消费成功的消息，由于业务上的需求需要重新消费，要支持此功能，Broker 在向 Consumer 投递成功消息后，消息仍然需要保留。并且重新消费一般是按照时间维度。</p><p>例如由于 Consumer 系统故障，恢复后需要重新消费 1 小时前的数据，那么 Broker 要提供一种机制，可以按照时间维度来回退消费进度。</p><p><strong>RocketMQ</strong> 支持按照<strong>时间</strong>回溯消费，时间维度精确到毫秒，可以向前回溯，也可以向后回溯。</p><h3 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h3><p>消息中间件的主要功能是异步解耦，还有个重要功能是挡住前端的数据洪峰，保证后端系统的稳定性，这就要求消息中间件具有一定的消息堆积能力，消息堆积分以下两种情况：</p><ul><li>消息堆积在内存 <strong>Buffer</strong> ，一旦超过内存 <strong>Buffer</strong> ，可以根据一定的丢弃策略来丢弃消息，如 <strong>CORBA Notification</strong> 规范中描述。适合能容忍丢弃消息的业务，这种情况消息的堆积能力主要在于内存 <strong>Buffer</strong> 大小，而且消息堆积后，性能下降不会太大，因为内存中数据多少对于对外提供的访问能力影响有限。</li><li>消息堆积到持久化存储系统中，例如 DB ，KV 存储，文件记录形式。 当消息不能在内存 Cache 命中时，要不可避免的访问磁盘，会产生大量读 IO ，读 IO 的吞吐量直接决定了消息堆积后的访问能力。</li><li>评估消息堆积能力主要有以下四点：<ul><li>消息能堆积多少条，多少字节？即消息的堆积容量。</li><li>消息堆积后，发消息的吞吐量大小，是否会受堆积影响？</li><li>消息堆积后，正常消费的 Consumer 是否会受影响？</li><li>消息堆积后，访问堆积在磁盘的消息时，吞吐量有多大？</li></ul></li></ul><h3 id="定时消息"><a href="#定时消息" class="headerlink" title="定时消息"></a>定时消息</h3><p>定时消息是指消息发到 <strong>Broker</strong> 后，不能立刻被 <strong>Consumer</strong> 消费，要到特定的时间点或者等待特定的时间后才能被消费。</p><p>如果要支持任意的时间精度，在 <strong>Broker</strong> 层面，必须要做<strong>消息排序</strong>，如果再涉及到持久化，那么消息排序要不可避免的产生巨大性能开销。</p><p><strong>RocketMQ</strong> 支持定时消息，但是不支持任意时间精度，支持特定的 Level ，例如定时 5s ，10s ，1m 等。</p><h3 id="RocketMQ-如何保证消息不丢失？"><a href="#RocketMQ-如何保证消息不丢失？" class="headerlink" title="RocketMQ 如何保证消息不丢失？"></a>RocketMQ 如何保证消息不丢失？</h3><p>分别从 Producer 发送机制、Broker 的持久化机制，以及 Consumer 的 Offset 机制来最大程度保证消息不易丢失。</p><ul><li><strong>从 Producer 的视角来看：</strong>如果消息未能正确的存储在 MQ 中，或者消费者未能正确的消费到这条消息，都是消息丢失。</li><li><strong>从 Broker 的视角来看：</strong>如果消息已经存在 Broker 里面了，如何保证不会丢失呢（宕机、磁盘崩溃）？</li><li><strong>从 Consumer 的视角来看：</strong>如果消息已经完成持久化了，但是 Consumer 取了，但是未消费成功且没有反馈，就是消息丢失。</li></ul><h4 id="Producer-如何保证消息不丢失？"><a href="#Producer-如何保证消息不丢失？" class="headerlink" title="Producer 如何保证消息不丢失？"></a>Producer 如何保证消息不丢失？</h4><ul><li>默认情况下，可以通过同步的方式阻塞式的发送，检查发送状态，状态是 <strong>OK</strong> ，表示消息一定成功的投递到了 Broker ，状态超时或者失败，则会触发默认的 <strong>2</strong> 次重试。此方法的发送结果，可能 Broker 存储成功了，也可能没成功。</li><li>采取事务消息的投递方式，并不能保证消息 100% 投递成功到了 Broker ，但是如果消息发送 ACK 失败的话，此消息会存储在 <code>CommitLog</code> 当中，但是对 ConsumerQueue 是不可见的。可以在日志中查看到这条异常的消息，严格意义上来讲，也并没有完全丢失。</li><li>RocketMQ 支持日志的索引，如果一条消息发送之后超时，也可以通过查询日志的 API ，来检查是否在 Broker 存储成功。</li></ul><h4 id="Broker-如何保证消息不丢失？"><a href="#Broker-如何保证消息不丢失？" class="headerlink" title="Broker 如何保证消息不丢失？"></a>Broker 如何保证消息不丢失？</h4><ul><li>消息支持持久化到 <code>CommitLog</code> 里面，即使宕机后重启，未消费的消息也是可以加载出来的。</li><li>Broker 自身支持<strong>同步刷盘</strong>、<strong>异步刷盘</strong>的策略，可以保证接收到的消息一定存储在本地的内存中。</li><li>Broker 集群支持 1 主 N 从的策略，支持<strong>同步复制</strong>和<strong>异步复制</strong>的方式，同步复制可以保证即使 Master 磁盘崩溃，消息仍然不会丢失。</li></ul><h4 id="Consumer-如何保证消息不丢失？"><a href="#Consumer-如何保证消息不丢失？" class="headerlink" title="Consumer 如何保证消息不丢失？"></a>Consumer 如何保证消息不丢失？</h4><ul><li>Consumer 自身维护一个持久化的 <strong>Offset</strong>（对应 MessageQueue 里面的 <code>min offset</code> ），标记已经成功消费或者已经成功发回到 Broker 的消息下标。</li><li>如果 Consumer 消费失败，那么它会把这个消息发回给 Broker ，发回成功后，再更新自己的 Offset 。</li><li>如果 Consumer 消费失败，发回给 Broker 时，Broker挂掉了，那么 Consumer 会定时重试这个操作。</li><li>如果 Consumer 和 Broker 一起挂了，消息也不会丢失，因为 Consumer 里面的 Offset 是定时持久化的，重启之后，继续拉取 Offset 之前的消息到本地。</li></ul><blockquote><p>重试队列（默认重试 16 次） -&gt; 死信队列</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，以上就是这篇文章的全部内容了，能看到这里的人呀，都是<strong>人才</strong>，祝各位看官都能成为 offer 收割机^∨^。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列基础</title>
      <link href="/2020/05/09/fen-bu-shi/xiao-xi-dui-lie-ji-chu/"/>
      <url>/2020/05/09/fen-bu-shi/xiao-xi-dui-lie-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="消息队列基础"><a href="#消息队列基础" class="headerlink" title="消息队列基础"></a>消息队列基础</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>消息队列</strong>在互联网技术存储方面使用如此广泛，几乎所有的后端技术面试官都要在<strong>消息队列</strong>的使用和原理方面对小伙伴们进行 360° 的刁难。</p><p>作为一个在互联网公司面一次拿一次 offer 的面霸，打败了无数竞争对手，每次都只能看到无数落寞的身影失望的离开，略感愧疚（<strong>请允许我使用一下夸张的修辞手法</strong>）。</p><p>于是在一个寂寞难耐的夜晚，<strong>暖男</strong>我痛定思痛，决定开始写<strong>《吊打面试官》</strong>系列，希望能帮助各位读者以后面试势如破竹，对面试官进行 360° 的反击，吊打问你的面试官，让一同面试的同僚瞠目结舌，疯狂收割大厂 offer ！</p><h2 id="面试开始"><a href="#面试开始" class="headerlink" title="面试开始"></a>面试开始</h2><blockquote><p>一个风度翩翩，穿着格子衬衣的中年男子，拿着一个满是划痕的 Mac 向你走来，看着铮亮的头，心想着肯定是尼玛顶级架构师吧！但是我们腹有诗书气自华，虚都不虚。</p></blockquote><p><img src="https://s1.ax1x.com/2020/05/08/YMSlLR.jpg" alt=""></p><h3 id="你项目中用过消息队列么？你为啥用消息队列？"><a href="#你项目中用过消息队列么？你为啥用消息队列？" class="headerlink" title="你项目中用过消息队列么？你为啥用消息队列？"></a>你项目中用过消息队列么？你为啥用消息队列？</h3><p>噗此，这也叫问题？别人用了我能不用么？别人用了我就用了呗，我就是为了用而用。</p><p>面试官你好：我们公司本身的业务体量很小，所以直接<strong>单机一把梭</strong>啥都能搞定了，但是后面业务体量不断扩大，采用<strong>微服务的设计思想</strong>，<strong>分布式的部署方式</strong>，所以拆分了很多的服务，随着体量的增加以及业务场景越来越复杂了，很多场景单机的技术栈和中间件以及不够用了，而且对系统的友好性也下降了，最后做了很多技术选型的工作，我们决定引入<strong>消息队列中间件</strong>。</p><h3 id="哦？你说到业务场景越来越复杂，你那说一下你都在什么场景用到了消息队列？"><a href="#哦？你说到业务场景越来越复杂，你那说一下你都在什么场景用到了消息队列？" class="headerlink" title="哦？你说到业务场景越来越复杂，你那说一下你都在什么场景用到了消息队列？"></a>哦？你说到业务场景越来越复杂，你那说一下你都在什么场景用到了消息队列？</h3><p>嗯，我从三个方面去说一下我使用的场景吧。</p><blockquote><p><strong>Tips：</strong>这三个场景也是消息队列的经典场景，大家基本上要烂熟于心那种，就是一说到消息队列你脑子就要想到<strong>异步、削峰、解耦</strong>，条件反射那种。</p></blockquote><h4 id="异步："><a href="#异步：" class="headerlink" title="异步："></a>异步：</h4><p>我们之前的场景里面有很多步骤都是在一个流程里面需要做完的，就比如说我的下单系统吧，本来我们业务简单，下单了付了钱就好了，流程就走完了。</p><p>但是后面来了个产品经理，搞了个<strong>优惠券系统</strong>，OK 问题不大，流程里面多 100ms 去扣减优惠券。</p><p>后来产品经理灵光一闪说我们可以搞个<strong>积分系统</strong>啊，也行吧，流程里面多了 200ms 去增减积分。</p><p>再后来后来隔壁的产品老王说：下单成功后我们要给用户发短信，也将就吧，100ms 去发个短信。</p><p>再后来。。。</p><p><img src="https://s1.ax1x.com/2020/05/08/YMSwyd.jpg" alt=""></p><p>反正就流程有点像这样 ↓</p><p><img src="https://s1.ax1x.com/2020/05/08/YMSgfS.jpg" alt=""></p><p>你们可以看到这才加了三个，我可以<strong>斩钉截铁</strong>的告诉你真正的下单流程涉及的系统绝对在 10 个以上（主流电商），越大的越多。</p><p>这个链路这样下去，<strong>时间长得一批</strong>，用户发现我买个东西你特么要花几十秒，垃圾电商我不在你这里买了，不过要是都像<strong>拼夕夕</strong>这么便宜，<strong>真香</strong>！</p><p>但是我们公司没有夕夕的那个经济实力啊，那只能优化系统了。</p><p><img src="https://s1.ax1x.com/2020/05/08/YMSjX9.jpg" alt=""></p><p><strong>大家感受一下这个 QPS 。</strong></p><h3 id="嗯不错，链路长了就慢了，那你怎么解决的？"><a href="#嗯不错，链路长了就慢了，那你怎么解决的？" class="headerlink" title="嗯不错，链路长了就慢了，那你怎么解决的？"></a>嗯不错，链路长了就慢了，那你怎么解决的？</h3><p>那链路长了就慢了，但是我们发现上面的流程其实可以<strong>同时做</strong>的呀，你支付成功后，我去校验优惠券的同时我可以去增减积分啊，还可以同时发个短信啊。</p><p>那正常的流程我们是没办法实现的呀，怎么办，<strong>异步</strong>。</p><p>你对比一下是不是发现，这样子最多只用 100ms 用户知道下单成功了，至于短信你迟几秒发给他他根本不在意是吧。</p><p><img src="https://s1.ax1x.com/2020/05/08/YMp09U.jpg" alt=""></p><h3 id="小伙子我打断你一下，你说了异步，那我用线程，线程池去做不是一样的么？"><a href="#小伙子我打断你一下，你说了异步，那我用线程，线程池去做不是一样的么？" class="headerlink" title="小伙子我打断你一下，你说了异步，那我用线程，线程池去做不是一样的么？"></a>小伙子我打断你一下，你说了异步，那我用线程，线程池去做不是一样的么？</h3><p>诶呀，面试官你<strong>不要急嘛</strong>，我后面还会说到的，骚等。</p><h4 id="解耦："><a href="#解耦：" class="headerlink" title="解耦："></a>解耦：</h4><p>既然面试官这么问了，我就说一下为啥我们不能用线程去做，因为用线程去做，你是不是要写代码？</p><p>你一个订单流程，你扣积分，扣优惠券，发短信，扣库存。。。等等这么多业务要调用这么多的接口，<strong>每次加一个你要调用一个接口然后还要重新发布系统</strong>，写一次两次还好，写多了你就说：老子不干了！</p><p>而且真的全部都写在一起的话，不单单是耦合这一个问题，你出问题排查也麻烦，流程里面随便一个地方出问题搞不好会影响到其他的点，小伙伴说我每个流程都 <strong>try catch</strong> 不就行了，相信我别这么做，这样的代码就像个<strong>定时炸弹💣</strong>，你不知道什么时候爆炸，平时不炸偏偏在你做活动的时候炸，你就领个 <strong>P0 故障</strong>收拾书包<strong>提前回家过年</strong>吧。</p><p>但是你用了<strong>消息队列</strong>，耦合这个问题就迎刃而解了呀。</p><h3 id="哦，怎么说？"><a href="#哦，怎么说？" class="headerlink" title="哦，怎么说？"></a>哦，怎么说？</h3><p>且听我娓娓道来：</p><p>你下单了，你就把你<strong>支付成功的消息告诉别的系统</strong>，它们收到了去处理就好了，你只用走完自己的流程，把自己的消息发出去，那后面要接入什么系统简单，直接订阅你发送的支付成功消息，你支付成功了我<strong>监听就好了</strong>。</p><p><img src="https://s1.ax1x.com/2020/05/08/YM9Z2F.jpg" alt=""></p><h3 id="那你的流程走完了，你不用管别人是否成功么？比如你下单了积分没加，优惠券没扣怎么办？"><a href="#那你的流程走完了，你不用管别人是否成功么？比如你下单了积分没加，优惠券没扣怎么办？" class="headerlink" title="那你的流程走完了，你不用管别人是否成功么？比如你下单了积分没加，优惠券没扣怎么办？"></a>那你的流程走完了，你不用管别人是否成功么？比如你下单了积分没加，优惠券没扣怎么办？</h3><p>问题是个好问题，但是没必要考虑，业务系统本身就是自己的开发人员维护的，你积分扣失败关我下单的什么事情？你管好自己下单系统的就好了。</p><blockquote><p><strong>Tips：</strong>话是这么说，但是这其实是用了消息队列的一个缺点，涉及到<strong>分布式事务</strong>的知识点，我下面会提到。</p></blockquote><h4 id="削峰："><a href="#削峰：" class="headerlink" title="削峰："></a>削峰：</h4><p>就拿秒杀来说，你平时流量很低，但是你要做秒杀活动 00 : 00 的时候流量疯狂怼进来，你的服务器、<strong>Redis</strong> 、<strong>MySQL</strong> 各自的承受能力都不一样，你直接<strong>全部流量照单全收</strong>肯定有问题啊，直接就打挂了。</p><h3 id="那怎么办？"><a href="#那怎么办？" class="headerlink" title="那怎么办？"></a>那怎么办？</h3><p>简单，把请求放到队列里面，然后至于每秒消费多少请求，就看自己的<strong>服务器处理能力</strong>，你能处理 5000 QPS 你就消费这么多，可能会比正常的慢一点，但是<strong>不至于打挂服务器</strong>，等流量高峰下去了，你的服务也就没压力了。</p><p>你看阿里双十一 12：00 的时候这么多流量瞬间涌进去，它有时候是不是会慢一点，但是人家没挂啊，或者降级给你个友好的提示页面，等高峰过去了又是一条好汉了。</p><p><img src="https://s1.ax1x.com/2020/05/08/YM9oGT.jpg" alt=""></p><h3 id="听你说了辣么多，怎么都是好处，那我问你使用了消息队列有啥问题么？"><a href="#听你说了辣么多，怎么都是好处，那我问你使用了消息队列有啥问题么？" class="headerlink" title="听你说了辣么多，怎么都是好处，那我问你使用了消息队列有啥问题么？"></a>听你说了辣么多，怎么都是好处，那我问你使用了消息队列有啥问题么？</h3><p>诶，看过前面我写的文章的<strong>人才</strong>都知道，我经常说的就是，<strong>技术是把双刃剑</strong>！</p><p>没错面试官，我使用它是因为它带给我们很多好处，但是使用之后问题也是<strong>接踵而至</strong>。</p><p>同样的暖男我呀，也从三个点介绍它主要的缺点：</p><h4 id="系统复杂性"><a href="#系统复杂性" class="headerlink" title="系统复杂性"></a>系统复杂性</h4><p>本来蛮简单的一个系统，我代码随便写都没事，现在你凭空接入一个中间件在那，我是不是要考虑去维护它，而且使用的过程中是不是要考虑各种问题，比如消息<strong>重复消费</strong>、<strong>消息丢失</strong>、<strong>消息的顺序消费</strong>等等，反正用了之后就是贼烦。</p><h4 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h4><p>这个其实是分布式服务本身就存在的一个问题，<strong>不仅仅是消息队列的问题</strong>，但是放在这里说是因为用了消息队列这个问题会暴露得比较严重一点。</p><p>就像我开头说的，你下单的服务自己保证自己的逻辑成功处理了，你成功发了消息，但是优惠券系统，积分系统等等这么多系统，<strong>它们成功还是失败你就不管了？</strong></p><p>我说了保证自己的业务数据对的就好了，其实还是比较不负责任的一种说法，这样就<strong>像个渣男，没有格局</strong>，<strong>这样呀你的路会越走越窄的</strong>。</p><p><img src="https://s1.ax1x.com/2020/05/08/YMCFLd.jpg" alt=""></p><p><strong>所有的服务都成功才能算这一次下单是成功的</strong>，那怎么才能保证数据一致性呢？</p><p><strong>分布式事务：</strong>把下单，优惠券，积分。。。都放在一个事务里面一样，要成功一起成功，要失败一起失败。</p><p><img src="https://s1.ax1x.com/2020/05/08/YMCRSO.jpg" alt=""></p><blockquote><p><strong>Tips：分布式事务</strong>在互联网公司里面实在常见，我也不在这里大篇幅介绍了，后面都会专门说的。</p></blockquote><h4 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h4><p>你搞个系统本身没啥问题，你现在突然接入一个中间件在那放着，万一挂了怎么办？我下个单 <strong>MQ 挂了</strong>，优惠券不扣了，积分不减了，这不是杀一个程序员能搞定的吧，感觉得杀一片。</p><p>至于怎么保证高可用，还是那句话，也不在这里展开讨论了。</p><h3 id="看不出来啊，你有点东西呀，那我问一下你，你们是怎么做技术选型的？"><a href="#看不出来啊，你有点东西呀，那我问一下你，你们是怎么做技术选型的？" class="headerlink" title="看不出来啊，你有点东西呀，那我问一下你，你们是怎么做技术选型的？"></a>看不出来啊，你有点东西呀，那我问一下你，你们是怎么做技术选型的？</h3><p>目前在市面上比较主流的消息队列中间件主要有 <strong>Kafka 、ActiveMQ 、RabbitMQ 、RocketMQ</strong> 等这几种。</p><p>不过我想说的是，<strong>ActiveMQ</strong> 和 <strong>RabbitMQ</strong> 这两者因为吞吐量还有 <strong>GitHub</strong> 社区活跃度的原因，在各大互联网公司都已经基本上绝迹了，业务体量一般的公司会是有在用的，但是越来越多的公司更青睐 <strong>RocketMQ</strong> 这样的消息中间件了。</p><p><strong>Kafka</strong> 和 <strong>RocketMQ</strong> 一直在各自擅长的领域发光发亮，不过大部分公司如蚂蚁金服，字节跳动和美团，用的都是各自的中间件，可能做过修改，也可能是<strong>自研</strong>的，大多<strong>没有开源</strong>。</p><p>我们回归正题，我这里用网上找的对比图让大家看看差距到底在哪里：</p><p><img src="https://s1.ax1x.com/2020/05/08/YMPJnH.jpg" alt="主流消息队列中间件对比"></p><p>大家其实一下子就能看到差距了，就拿<strong>吞吐量</strong>来说，早期比较活跃的 <strong>ActiveMQ</strong> 和 <strong>RabbitMQ</strong> 基本上不是后两者的对手了，在现在这样大数据的年代<strong>吞吐量是真的很重要</strong>。</p><p>比如现在突然爆发了一个超级热点新闻，你的 APP 注册用户高达亿数，你要想办法第一时间把突发全部推送到每个人手上，你没有<strong>大吞吐量的消息队列</strong>中间件用啥去推？</p><p>再说这些用户大量涌进来看了你的新闻产生了一系列的附带流量，你怎么应对这些数据，<strong>很多场景离开消息队列基本上难以为继</strong>。</p><p>就<strong>部署方式</strong>而言前两者也是大不如后面两个<strong>天然分布式架构的哥哥</strong>，都是高可用的分布式架构，而且数据多个副本的数据也能做到 0 丢失。</p><p>我们再聊一下 <strong>RabbitMQ</strong> 这个中间件其实还行，但是这玩意开发语言居然是 <strong>Erlang</strong> ，我敢说绝大部分工程师肯定不会为了一个中间件去刻意学习一门语言的，开发维护成本你想都想不到，出个问题查都查半天。</p><p>至于 <strong>RocketMQ</strong>（阿里开源的），GitHub 活跃度还可以。基本上你 Push 了自己的 Bug 确认了有问题都有阿里大佬跟你试试解答并修复的，我个人推荐的也是这个，它的架构设计部分跟同样是阿里开源的一个 <strong>RPC</strong> 框架（<strong>Dubbo</strong>）是真的很像，可能是因为师出同门的原因吧。</p><p><strong>Kafka</strong> 我放到最后说，你们也应该知道了，压轴的这是个大哥，大数据领域，公司的日志采集，实时计算等场景，都离不开它的身影，它基本上算得上是<strong>世界范围级别的消息队列标杆</strong>了。</p><p>以上这些都只是一些我自己的<strong>个人意见</strong>，真正的选型还是要去<strong>深入研究</strong>的，不然那你公司一天 UV 就 1000 你告诉我你要去用 <strong>Kafka</strong> 我只能说你吃饱撑的。</p><p><strong>记住，没有最好的技术，只有最适合的技术，不要为了用而用</strong>。</p><h3 id="上次说到了消息队列的消息重复消费，你能跟我介绍这是怎么样子的场景么？"><a href="#上次说到了消息队列的消息重复消费，你能跟我介绍这是怎么样子的场景么？" class="headerlink" title="上次说到了消息队列的消息重复消费，你能跟我介绍这是怎么样子的场景么？"></a>上次说到了消息队列的消息重复消费，你能跟我介绍这是怎么样子的场景么？</h3><p>消息<strong>重复消费</strong>是使用消息队列之后，必须考虑的一个问题，也是比较严重和常见的问题，我在开发过程中，但凡用到了消息队列，我第一时间考虑的就是<strong>重复消费</strong>的问题。</p><p>就比如有这样的一个场景，用户下单成功后我需要去一个活动页面给他加 <strong>GMV</strong>（销售总额），最后根据他的 GMV 去给他发奖励，这是电商活动很常见的玩法。</p><p>类似累计下单金额到哪个梯度给你返回什么梯度的奖励这样。</p><p><img src="https://s1.ax1x.com/2020/05/08/YMirPx.jpg" alt=""></p><p>我只能告诉你这样的活动页面 <strong>10000%</strong> 是用<strong>异步</strong>去加的，不然你想，你一个用户下一单就给他加一下，那就意味着对那张表就要操作一下，你考虑下双十一当天多少次对这个表的操作？这数据库或者缓存都顶不住吧。</p><p>而且大家应该也有这样的体会，你下单了马上去看一些活动页面，有时候马上就有了，有时候却延迟有很久，为啥？这个速度<strong>取决于消息队列的消费速度</strong>，消费慢堵塞了就迟点看到呗。</p><p>你下个单<strong>支付成功</strong>你就发个消息出去，我们上面那个活动的开发人员就<strong>监听</strong>你的<strong>支付成功消息</strong>，我监听到你这个订单成功支付的消息，那我就去我活动 GMV 表里给你加上去，听到这里大家可能<strong>觉得顺理成章</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g982pptuarj30hz0cwmxs.jpg" alt=""></p><p><strong>但是</strong>我告诉大家一般消息队列的使用，我们都是有<strong>重试机制</strong>的，就是说我下游的业务发生异常了，我会抛出异常并且要求你<strong>重新发一次</strong>。</p><p>我这个活动这里发生错误，你要求重发肯定没问题。但是大家<strong>仔细想一下</strong>问题在哪里？</p><p>是的，不止你一个人监听这个消息啊，<strong>还有别的服务也在监听</strong>，它们也会失败啊，它一失败它也要求重发，但是你这里其实是成功的，重发了，你的钱不就加了两次了？</p><p><strong>对不对？？？是不是这个道理？？？</strong></p><p>还不理解？看下面  <strong>↓</strong></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g982ss9ku2j30ir0gcjs7.jpg" alt=""></p><p>就好比上面的这样，我们的<strong>积分系统处理失败</strong>了，它这个系统肯定要求你<strong>重新发送</strong>一次这个消息对吧，积分的系统重新接收并且处理成功了，但是别人的活动，优惠券等等服务<strong>也监听了这个消息</strong>呀，那不就可能出现活动系统给他加 GMV 加两次，优惠券扣两次这种情况么？</p><p>真实的情况其实重试是很正常的，服务的<strong>网络抖动</strong>，<strong>开发人员代码Bug</strong>，还有<strong>数据问题</strong>等都可能处理失败要求重发的。</p><h3 id="嗯小伙子分析得很仔细嘛，那你在开发过程中是怎么去保证的呀？"><a href="#嗯小伙子分析得很仔细嘛，那你在开发过程中是怎么去保证的呀？" class="headerlink" title="嗯小伙子分析得很仔细嘛，那你在开发过程中是怎么去保证的呀？"></a>嗯小伙子分析得很仔细嘛，那你在开发过程中是怎么去保证的呀？</h3><p>一般我们叫这样的处理叫接口<strong>幂等</strong>。</p><blockquote><p><strong>幂等（Idempotent、Idempotence）</strong>是一个数学与计算机学概念，常见于抽象代数中。</p><p>在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。</p><p>幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。</p><p>例如，<code>setTrue()</code> 函数就是一个幂等函数，<strong>无论多次执行，其结果都是一样的</strong>。更复杂的操作幂等保证是利用唯一交易号(流水号)实现.</p></blockquote><p>通俗了讲就是你<strong>同样的参数调用我这个接口，调用多少次结果都是一个</strong>，你加 GMV 同一个订单号你加一次是多少钱，你加 N 次都还是多少钱。</p><p>但是如果<strong>不做幂等</strong>，你一个订单调用多次钱不就加多次嘛，同理你退款调用多次钱也就减多次了。</p><p>大致处理流程如下：</p><p><img src="https://s1.ax1x.com/2020/05/09/YM8zzF.jpg" alt=""></p><h3 id="那怎么保证呢？"><a href="#那怎么保证呢？" class="headerlink" title="那怎么保证呢？"></a>那怎么保证呢？</h3><p>一般我是这么回答的：</p><p>帅气面试官您好，一般<strong>幂等</strong>，我会<strong>分场景去考虑</strong>，看是<strong>强校验</strong>还是<strong>弱校验</strong>，比如跟金钱相关的场景那就很关键呀，就做强校验，别不是很重要的场景做弱校验。</p><h4 id="强校验："><a href="#强校验：" class="headerlink" title="强校验："></a>强校验：</h4><p>比如你监听到用户支付成功的消息，你监听到了去加 GMV 是不是要调用加钱的接口，那加钱接口下面再调用一个加流水的接口，<strong>两个放在一个事务，成功一起成功失败一起失败</strong>。</p><p>每次消息过来都要拿着<strong>订单号+业务场景这样的唯一标识</strong>（比如天猫双十一活动）去流水表查，看看有没有这条流水，有就直接 return 不要走下面的流程了，没有就执行后面的逻辑。</p><p>之所以用<strong>流水表</strong>，是因为涉及到金钱这样的活动，有啥问题后面也可以去流水表<strong>对账</strong>，还有就是帮助开发人员定位问题。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 强校验幂等伪代码演示，这都是简单的伪代码，真实情况复杂一点，但是大的逻辑是这样。 * @param orderId */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>String orderId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 查询这个订单是否存在这个活动加 GMV 的流水</span>        Object gmvFlow <span class="token operator">=</span> <span class="token function">getFlowByOrderId</span><span class="token punctuation">(</span><span class="token string">"addGmv"</span> <span class="token operator">+</span> orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>gmvFlow<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 不存在流水，去加 GMV 和流水，注意这两个在一个事务的，回滚就一起回滚了。</span>            <span class="token function">addGmvAndFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 存在流水证明加过了，返回就好了。</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 发送异常，触发消息队列重试机制。</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="弱校验："><a href="#弱校验：" class="headerlink" title="弱校验："></a>弱校验：</h4><p>这个简单，一些不重要的场景，比如给谁发短信啥的，我就把这个 Id + 场景唯一标识作为 <strong>Redis</strong> 的 Key ，放到缓存里面失效时间看你场景，<strong>一定时间内</strong>的这个消息就去 Redis 判断。</p><p>用 KV 就算消息丢了可能这样的场景也没关系，反正丢条<strong>无关痛痒</strong>的通知短信嘛（你敢说你没验证码短信丢失的情况？）。<br><img src="https://s1.ax1x.com/2020/05/09/YMGpM4.jpg" alt=""></p><p>还有很多公司的弱校验用 <strong>Token</strong> 啊什么的，反正花样很多，但是<strong>重要的场景一定要强校验</strong>，真正查问题的时候没有在磁盘持久化的数据，心里还是空空的，就像你和女朋友分开的时候的心里状态一样。（我单身的怎么知道这种感觉？猜的）</p><h3 id="你们有接触过消息顺序消费这样的场景么？你怎么保证的？"><a href="#你们有接触过消息顺序消费这样的场景么？你怎么保证的？" class="headerlink" title="你们有接触过消息顺序消费这样的场景么？你怎么保证的？"></a>你们有接触过消息顺序消费这样的场景么？你怎么保证的？</h3><p>没有！over ！ </p><p>乖，你肯定不能说没有啊，就是算真的没有，你都要说有！</p><blockquote><p><strong>Tips：</strong>但是说实话<strong>顺序消费</strong>这里很难介绍，开发过程中这样的场景不多，网上更多的都是介绍 <code>binlog</code> 的同步，好像更多的场景就没了。</p></blockquote><p>一般都是<strong>同个业务场景下不同几个操作的消息同时过去</strong>，本身顺序是对的，但是你发出去的时候同时发出去了，消费的时候却乱掉了，这样就有问题了。</p><p>我之前做电商活动也是有这样的例子，我们都知道数据量大的时候数据同步压力还是很大的，有时候数据量大的表需要同步几个亿的数据。（并不是主从同步，主从延迟大的话会有问题，可能是从数据库或者主数据库同步到<strong>备库</strong>）</p><p>这种情况我们都是怼到队列里面去，然后慢慢消费的，那问题就来了呀，我们在数据库同时对一个 Id 的数据进行了增、改、删三个操作，但是你消息发过去消费的时候变成了改，删、增，这样数据就不对了。</p><p>本来一条数据应该删掉了，结果在你那却还在，这不是<strong>出大问题</strong>！</p><p><img src="https://s1.ax1x.com/2020/05/09/YMGFd1.jpg" alt=""></p><p>两者的结果是不是完全不一样了 <strong>↑</strong></p><h3 id="那你怎么解决呢？"><a href="#那你怎么解决呢？" class="headerlink" title="那你怎么解决呢？"></a>那你怎么解决呢？</h3><p>我简单的说一下我们使用的 <strong>RocketMQ</strong> 里面的一个简单实现吧。</p><p>生产者消费者一般需要保证顺序消息的话，可能就是一个业务场景下的，比如订单的创建、支付、发货、收货。</p><p>那这些东西是不是一个订单号呢？一个订单的肯定是一个订单号的说，那简单了呀。</p><p><strong>一个 Topic 下有多个队列</strong>，为了保证发送有序，<strong>RocketMQ</strong> 提供了 <strong>MessageQueueSelector</strong> 队列选择机制，它有三种实现：</p><p><img src="https://s1.ax1x.com/2020/05/09/YMGEi6.png" alt=""></p><p>我们可使用 <strong>Hash 取模法</strong>，让同一个订单发送到同一个队列中，再使用同步发送，只有同个订单的创建消息发送成功，再发送支付消息。这样，我们保证了发送有序。</p><p><strong>RocketMQ</strong> 的 Topic 内的队列机制，可以保证存储满足 <strong>FIFO</strong>（First Input First Output ，简单说就是指先进先出），剩下的只需要消费者顺序消费即可。</p><p><strong>RocketMQ</strong> 仅保证顺序发送，顺序消费由消费者业务保证！！！</p><p>这里很好理解，一个订单你发送的时候放到一个队列里面去，你同一个的订单号 Hash 一下是不是还是一样的结果，那肯定是一个消费者消费，那顺序是不是就保证了？</p><p>真正的顺序消费不同的中间件都有自己的不同实现我这里就举个例子，大家思路理解下。</p><blockquote><p><strong>Tips：</strong>有人问我，一个队列有序出去，一个消费者消费不就好了，我想说的是<strong>消费者是多线程</strong>的，你消息是有序的给它的，你能保证它是有序的处理的？还是一个消费成功了再发下一个<strong>稳妥</strong>。</p></blockquote><h3 id="你能跟我聊一下分布式事务么？"><a href="#你能跟我聊一下分布式事务么？" class="headerlink" title="你能跟我聊一下分布式事务么？"></a>你能跟我聊一下分布式事务么？</h3><p><strong>分布式事务</strong>在现在遍地都是分布式部署的系统中几乎是必要的。</p><p>我们先聊一下啥是<strong>事务</strong>？</p><p><strong>分布式事务</strong>、<strong>事务隔离级别</strong>、<strong>ACID</strong> 我相信大家这些东西都耳熟能详了，那什么是事务呢？</p><h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h4><blockquote><p><strong>一般是指要做的或所做的事情。</strong></p><p>在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元（unit）。</p><p>事务通常由高级数据库操纵语言或编程语言（如 SQL ，C++ 或 Java ）书写的用户程序的执行所引起，并用形如 <strong>begin transaction</strong> 和 <strong>end transaction</strong> 语句（或函数调用）来界定。</p><p>事务由事务开始（<strong>begin transaction</strong>）和事务结束（<strong>end transaction</strong>）之间执行的全体操作组成。</p></blockquote><h4 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h4><blockquote><p>事务是恢复和并发控制的基本单位。</p><p>事务应该具有 4 个属性：<strong>原子性、一致性、隔离性、持久性</strong>。这四个属性通常称为 <strong>ACID 特性</strong>。</p><p><strong>原子性（Atomicity）：</strong>一个事务是一个不可分割的工作单位，事务中的操作要么都执行，要么都不执行。</p><p><strong>一致性（Consistency）：</strong>事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。</p><p><strong>隔离性（Isolation）：</strong>一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p><p><strong>持久性（Durability）：持久性也称永久性（Permanence）</strong>，指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</p></blockquote><p>那有同学还是不理解，我总结了一下就是：<strong>事务就是一系列操作，要么同时成功，要么同时失败。</strong>然后会从事务的 <strong>ACID</strong> 特性<strong>（原子性、一致性、隔离性、持久性）展开叙述</strong>。</p><p>事务就是为了保证一系列操作可以正常执行，它必须同时满足 <strong>ACID</strong> 特性。</p><h3 id="那什么是分布式事务呢？"><a href="#那什么是分布式事务呢？" class="headerlink" title="那什么是分布式事务呢？"></a>那什么是分布式事务呢？</h3><p>大家可以想一下，你下单流程可能涉及到 10 多个环节，你下单付钱都成功了，但是你优惠券扣减失败了，积分新增失败了，前者公司会被薅羊毛，后者用户会不开心，但是<strong>这些都在不同的服务怎么保证大家都成功呢</strong>？</p><p>聪明，<strong>分布式事务</strong>，你看你都会抢答了！</p><blockquote><p><strong>Tips：</strong>真实的应用场景可能比我介绍的场景复杂数倍，我只是为了举例方便一下大家理解所以用了很简单的例子。</p></blockquote><p>我接触和了解到的分布式事务大概分为：</p><ul><li>2PC（两段式提交）</li><li>3PC（三段式提交）</li><li>TCC（Try、Confirm、Cancel）</li><li>最大努力通知</li><li>XA</li><li>本地消息表（ebay 研发出的）</li><li>半消息/最终一致性（RocketMQ）</li></ul><p>这里我就介绍下最简单的 <strong>2PC（两段式）</strong>，以及大家以后可能比较常用的<strong>半消息事务</strong>也就是<strong>最终一致性</strong>，目的是让大家理解下分布式事务里面<strong>消息中间件的作用</strong>，别的事务都大同小异，都有很多优点。</p><p>当然也都有<strong>种种弊端：</strong></p><p>例如<strong>长时间锁定数据库资源</strong>，导致系统的<strong>响应不快</strong>，<strong>并发上不去</strong>。</p><p>网络抖动出现<strong>脑裂</strong>情况，导致事物参与者，不能很好地执行协调者的指令，导致<strong>数据不一致</strong>。</p><p><strong>单点故障</strong>：例如事物协调者，在某一时刻宕机，虽然可以通过选举机制产生新的 Leader ，但是这过程中，必然出现问题，而 TCC ，只有强悍的技术团队，才能支持开发，<strong>成本太高</strong>。</p><p>不多 BB 了，我们先来介绍这个 2PC 吧。</p><p><strong>2PC（两段式提交）：</strong></p><p><img src="https://s1.ax1x.com/2020/05/09/YMGZRO.jpg" alt="2PC"></p><p><strong>2pc（两段式提交）</strong>可以说是分布式事务的最开始的样子了，像极了<strong>媒婆</strong>，就是通过消息中间件协调多个系统，在两个系统操作事务的时候都锁定资源但是不提交事务，等两者都准备好了，告诉消息中间件，然后再分别提交事务。</p><p><strong>但是我不知道大家看到问题所在没有？</strong></p><p>是的你可能已经发现了，如果 A 系统事务提交成功了，但是 B 系统在提交的时候网络波动或者各种原因提交失败了，其实还是会失败的。</p><p><strong>3PC（三段式提交）：</strong></p><p><img src="https://s1.ax1x.com/2020/05/09/YMGNQg.png" alt="3PC"></p><p>3PC 是 2PC 的改进版本，与 2PC 不同的是，3PC 有两个改动点：</p><ul><li>引入超时机制。同时在协调者和参与者中都引入超时机制。</li><li>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</li></ul><p>也就是说，除了引入超时机制之外，3PC 把 2PC 的准备阶段再次一分为二，这样三段式提交就有 <code>CanCommit</code> 、<code>PreCommit</code> 、<code>DoCommit</code> 三个阶段。</p><p><strong>最终一致性：</strong></p><p><img src="https://s1.ax1x.com/2020/05/09/YMGUyQ.jpg" alt="最终一致性"></p><p>整个流程中，我们能保证是：</p><ul><li><p>业务主动方本地事务提交失败，业务被动方不会收到消息的投递。</p></li><li><p>只要业务主动方本地事务执行成功，那么消息服务一定会投递消息给下游的业务被动方，并最终保证业务被动方一定能成功消费该消息（消费成功或失败，即最终一定会有一个最终态）。</p></li></ul><p>不过呢技术就是这样，<strong>各种极端的情况我们都需要考虑</strong>，也很难有完美的方案，所以才会有这么多的方案<strong>三段式</strong>、<strong>TCC</strong> 、<strong>最大努力通知</strong>等等分布式事务方案，大家只需要知道为啥要做，做了有啥好处，有啥坏处，在实际开发的时候都注意下就好好了，<strong>系统都是根据业务场景设计出来的，离开业务的技术没有意义，离开技术的业务没有底气</strong>。</p><p>还是那句话：<strong>没有最完美的系统，只有最适合的系统。</strong></p><h2 id="面试结束"><a href="#面试结束" class="headerlink" title="面试结束"></a>面试结束</h2><h3 id="小伙子看不出来啊，还是有点东西的嘛，这几个点都回答的不错，明天你能跟我聊一下-RocketMQ-么？"><a href="#小伙子看不出来啊，还是有点东西的嘛，这几个点都回答的不错，明天你能跟我聊一下-RocketMQ-么？" class="headerlink" title="小伙子看不出来啊，还是有点东西的嘛，这几个点都回答的不错，明天你能跟我聊一下 RocketMQ 么？"></a>小伙子看不出来啊，还是有点东西的嘛，这几个点都回答的不错，明天你能跟我聊一下 RocketMQ 么？</h3><p>嗯嗯好的面试官，不过不确定能不能一口气说完，毕竟还没开始<strong>白嫖</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>消息队列的基础知识</strong>我就先介绍这么多，消息队列在面试里面基本上也是跟我前面写的 <strong>Redis</strong> 一样必问的。</p><p>面试的思路还是一样，<strong>要知其然，也要知其所以然，就是要知道为啥用，用了有啥好处，有啥坑。</strong></p><p>面试官不喜欢<strong>只知道用</strong>的，你只会用那哪天线上出问题怎么办？你难道在旁边拜佛？</p><p><img src="https://s1.ax1x.com/2020/05/09/YMG0wn.jpg" alt=""></p><p>好了，以上就是这篇文章的全部内容了，能看到这里的人呀，都是<strong>人才</strong>，祝各位看官都能成为 offer 收割机^∨^。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入剖析Linux IO原理和几种零拷贝机制的实现</title>
      <link href="/2020/05/08/linux/shen-ru-pou-xi-linux-io-yuan-li-he-ji-chong-ling-kao-bei-ji-zhi-de-shi-xian/"/>
      <url>/2020/05/08/linux/shen-ru-pou-xi-linux-io-yuan-li-he-ji-chong-ling-kao-bei-ji-zhi-de-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="深入剖析-Linux-IO-原理和几种零拷贝机制的实现"><a href="#深入剖析-Linux-IO-原理和几种零拷贝机制的实现" class="headerlink" title="深入剖析 Linux IO 原理和几种零拷贝机制的实现"></a>深入剖析 Linux IO 原理和几种零拷贝机制的实现</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>零拷贝（Zero-copy）技术指在计算机执行操作时，CPU 不需要先将数据从一个内存区域复制到另一个内存区域，从而可以减少上下文切换以及 CPU 的拷贝时间。它的作用是在数据报从网络设备到用户程序空间传递的过程中，减少数据拷贝次数，减少系统调用，实现 CPU 的零参与，彻底消除 CPU 在这方面的负载。实现零拷贝用到的最主要技术是 DMA（直接内存存取）数据传输技术和内存区域映射技术。</p><ul><li>零拷贝机制可以减少数据在内核缓冲区和用户进程缓冲区之间反复的 I/O 拷贝操作。</li><li>零拷贝机制可以减少用户进程地址空间和内核地址空间之间因为上下文切换而带来的 CPU 开销。</li></ul><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-物理内存和虚拟内存"><a href="#1-物理内存和虚拟内存" class="headerlink" title="1. 物理内存和虚拟内存"></a>1. 物理内存和虚拟内存</h3><p>由于操作系统的进程与进程之间是共享 CPU 和内存资源的，因此需要一套完善的内存管理机制防止进程之间内存泄漏的问题。为了更加有效地管理内存并减少出错，现代操作系统提供了一种对主存的抽象概念，即是虚拟内存（Virtual Memory）。虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）。</p><h4 id="1-1-物理内存"><a href="#1-1-物理内存" class="headerlink" title="1.1. 物理内存"></a>1.1. 物理内存</h4><p>物理内存（Physical memory）是相对于虚拟内存（Virtual Memory）而言的。物理内存指通过物理内存条而获得的内存空间，而虚拟内存则是指将硬盘的一块区域划分来作为内存。内存主要作用是在计算机运行时为操作系统和各种程序提供临时储存。在应用中，自然是顾名思义，物理上，真实存在的插在主板内存槽上的内存条的容量的大小。</p><h4 id="1-2-虚拟内存"><a href="#1-2-虚拟内存" class="headerlink" title="1.2. 虚拟内存"></a>1.2. 虚拟内存</h4><p>虚拟内存是计算机系统内存管理的一种技术。 它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间）。而实际上，虚拟内存通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换，加载到物理内存中来。 目前，大多数操作系统都使用了虚拟内存，如 Windows 系统的虚拟内存、Linux 系统的交换空间等等。</p><p>虚拟内存地址和用户进程紧密相关，一般来说不同进程里的同一个虚拟地址指向的物理地址是不一样的，所以离开进程谈虚拟内存没有任何意义。每个进程所能使用的虚拟地址大小和 CPU 位数有关。在 32 位的系统上，虚拟地址空间大小是 2 ^ 32 = 4G ，在 64位系统上，虚拟地址空间大小是 2 ^ 64 = 2 ^ 34G ，而实际的物理内存可能远远小于虚拟内存的大小。每个用户进程维护了一个单独的页表（Page Table），虚拟内存和物理内存就是通过这个页表实现地址空间的映射的。下面给出两个进程 A、B 各自的虚拟内存空间以及对应的物理内存之间的地址映射示意图：</p><p><img src="https://s1.ax1x.com/2020/05/07/Ym7Wan.png" alt="虚拟内存"></p><p>当进程执行一个程序时，需要先从先内存中读取该进程的指令，然后执行，获取指令时用到的就是虚拟地址。这个虚拟地址是程序链接时确定的（内核加载并初始化进程时会调整动态库的地址范围）。为了获取到实际的数据，CPU 需要将虚拟地址转换成物理地址，CPU 转换地址时需要用到进程的页表（Page Table），而页表（Page Table）里面的数据由操作系统维护。</p><p>其中页表（Page Table）可以简单的理解为单个内存映射（Memory Mapping）的链表（当然实际结构很复杂），里面的每个内存映射（Memory Mapping）都将一块虚拟地址映射到一个特定的地址空间（物理内存或者磁盘存储空间）。每个进程拥有自己的页表（Page Table），和其它进程的页表（Page Table）没有关系。</p><p>通过上面的介绍，我们可以简单的将用户进程申请并访问物理内存（或磁盘存储空间）的过程总结如下：</p><ol><li>用户进程向操作系统发出内存申请请求；</li><li>系统会检查进程的虚拟地址空间是否被用完，如果有剩余，给进程分配虚拟地址；</li><li>系统为这块虚拟地址创建的内存映射（Memory Mapping），并将它放进该进程的页表（Page Table）；</li><li>系统返回虚拟地址给用户进程，用户进程开始访问该虚拟地址；</li><li>CPU 根据虚拟地址在此进程的页表（Page Table）中找到了相应的内存映射（Memory Mapping），但是这个内存映射（Memory Mapping）没有和物理内存关联，于是产生缺页中断；</li><li>操作系统收到缺页中断后，分配真正的物理内存并将它关联到页表相应的内存映射（Memory Mapping）。中断处理完成后 CPU 就可以访问内存了；</li><li>当然缺页中断不是每次都会发生，只有系统觉得有必要延迟分配内存的时候才用的着，也即很多时候在上面的第 3 步系统会分配真正的物理内存并和内存映射（Memory Mapping）进行关联。</li></ol><p>在用户进程和物理内存（磁盘存储器）之间引入虚拟内存主要有以下的优点：</p><ul><li><strong>地址空间：</strong>提供更大的地址空间，并且地址空间是连续的，使得程序编写、链接更加简单。</li><li><strong>进程隔离：</strong>不同进程的虚拟地址之间没有关系，所以一个进程的操作不会对其它进程造成影响。</li><li><strong>数据保护：</strong>每块虚拟内存都有相应的读写属性，这样就能保护程序的代码段不被修改，数据块不能被执行等，增加了系统的安全性。</li><li><strong>内存映射：</strong>有了虚拟内存之后，可以直接映射磁盘上的文件（可执行文件或动态库）到虚拟地址空间。这样可以做到物理内存延时分配，只有在需要读相应的文件的时候，才将它真正的从磁盘上加载到内存中来，而在内存吃紧的时候又可以将这部分内存清空掉，提高物理内存利用效率，并且所有这些对应用程序是都透明的。</li><li><strong>共享内存：</strong>比如动态库只需要在内存中存储一份，然后将它映射到不同进程的虚拟地址空间中，让进程觉得自己独占了这个文件。进程间的内存共享也可以通过映射同一块物理内存到进程的不同虚拟地址空间来实现共享。</li><li><strong>物理内存管理：</strong>物理地址空间全部由操作系统管理，进程无法直接分配和回收，从而系统可以更好的利用内存，平衡进程间对内存的需求。</li></ul><h3 id="2-内核空间和用户空间"><a href="#2-内核空间和用户空间" class="headerlink" title="2. 内核空间和用户空间"></a>2. 内核空间和用户空间</h3><p>操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的权限。为了避免用户进程直接操作内核，保证内核安全，操作系统将虚拟内存划分为两部分，一部分是内核空间（Kernel-space），一部分是用户空间（User-space）。 在 Linux 系统中，内核模块运行在内核空间，对应的进程处于内核态；而用户程序运行在用户空间，对应的进程处于用户态。</p><p>内核进程和用户进程所占的虚拟内存比例是 1:3 ，而 Linux x86_32 系统的寻址空间（虚拟存储空间）为 4G（2 的 32 次方），将最高的 1G 的字节（从虚拟地址 0xC0000000 到 0xFFFFFFFF）供内核进程使用，称为内核空间；而较低的 3G 的字节（从虚拟地址 0x00000000 到 0xBFFFFFFF），供各个用户进程使用，称为用户空间。下图是一个进程的用户空间和内核空间的内存布局：</p><p><img src="https://s1.ax1x.com/2020/05/08/Ymbd9P.png" alt="用户空间和内核空间"></p><h4 id="2-1-内核空间"><a href="#2-1-内核空间" class="headerlink" title="2.1. 内核空间"></a>2.1. 内核空间</h4><p>内核空间总是驻留在内存中，它是为操作系统的内核保留的。应用程序是不允许直接在该区域进行读写或直接调用内核代码定义的函数的。上图左侧区域为内核进程对应的虚拟内存，按访问权限可以分为进程私有和进程共享两块区域。</p><ul><li><strong>进程私有的虚拟内存：</strong>每个进程都有单独的内核栈、页表、<code>task</code> 结构以及 <code>mem_map</code> 结构等。</li><li><strong>进程共享的虚拟内存：</strong>属于所有进程共享的内存区域，包括物理存储器、内核数据和内核代码区域。</li></ul><h4 id="2-2-用户空间"><a href="#2-2-用户空间" class="headerlink" title="2.2. 用户空间"></a>2.2. 用户空间</h4><p>每个普通的用户进程都有一个单独的用户空间，处于用户态的进程不能访问内核空间中的数据，也不能直接调用内核函数的 ，因此<strong>要进行系统调用的时候，就要将进程切换到内核态</strong>才行。用户空间包括以下几个内存区域：</p><ul><li><strong>运行时栈：</strong>由编译器自动释放，存放函数的参数值，局部变量和方法返回值等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存储到栈顶，调用结束后调用信息会被弹出弹出并释放掉内存。栈区是从高地址位向低地址位增长的，是一块连续的内在区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。</li><li><strong>运行时堆：</strong>用于存放进程运行中被动态分配的内存段，位于 BSS 和栈中间的地址位。由开发人员申请分配（malloc）和释放（free）。堆是从低地址位向高地址位增长，采用<strong>链式</strong>存储结构。频繁地 <code>malloc/free</code> 造成内存空间的不连续，产生大量碎片。当申请堆空间时，库函数按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要低的多。</li><li><strong>代码段：</strong>存放 CPU 可以执行的机器指令，该部分内存只能读不能写。通常代码区是共享的，即其它执行程序可调用它。假如机器中有数个进程运行相同的一个程序，那么它们就可以使用同一个代码段。</li><li><strong>未初始化的数据段：</strong>存放未初始化的全局变量，BSS 的数据在程序开始执行之前被初始化为 0 或 NULL 。</li><li><strong>已初始化的数据段：</strong>存放已初始化的全局变量，包括静态全局变量、静态局部变量以及常量。</li><li><strong>内存映射区域：</strong>例如将动态库，共享内存等虚拟空间的内存映射到物理空间的内存，一般是 <code>mmap</code> 函数所分配的虚拟内存空间。</li></ul><h3 id="3-Linux-的内部层级结构"><a href="#3-Linux-的内部层级结构" class="headerlink" title="3. Linux 的内部层级结构"></a>3. Linux 的内部层级结构</h3><p>内核态可以执行任意命令，调用系统的一切资源，而用户态只能执行简单的运算，不能直接调用系统资源。用户态必须通过系统接口（System Call），才能向内核发出指令。比如，当用户进程启动一个 <code>bash</code> 时，它会通过 <code>getpid()</code> 对内核的 <code>pid</code> 服务发起系统调用，获取当前用户进程的 <code>ID</code> ；当用户进程通过 <code>cat</code> 命令查看主机配置时，它会对内核的文件子系统发起系统调用。</p><p><img src="https://s1.ax1x.com/2020/05/08/YmLAo9.png" alt=""></p><ul><li>内核空间可以访问所有的 CPU 指令和所有的内存空间、I/O 空间和硬件设备。</li><li>用户空间只能访问受限的资源，如果需要特殊权限，可以通过系统调用获取相应的资源。</li><li>用户空间允许页面中断，而内核空间则不允许。</li><li>内核空间和用户空间是针对线性地址空间的。</li><li>x86 CPU 中用户空间是 0 - 3G 的地址范围，内核空间是 3G - 4G 的地址范围。x86_64 CPU 用户空间地址范围为 0x0000000000000000 – 0x00007fffffffffff ，内核地址空间为 0xffff880000000000 - 最大地址。</li><li>所有内核进程（线程）共用一个地址空间，而用户进程都有各自的地址空间。</li></ul><p>有了用户空间和内核空间的划分后，Linux 内部层级结构可以分为三部分，从最底层到最上层依次是<strong>硬件</strong>、<strong>内核空间</strong>和<strong>用户空间</strong>，如下图所示：</p><p><img src="https://s1.ax1x.com/2020/05/08/YmL1dH.png" alt="Linux 内部层级结构"></p><h3 id="4-Linux-I-O-读写方式"><a href="#4-Linux-I-O-读写方式" class="headerlink" title="4. Linux I/O 读写方式"></a>4. Linux I/O 读写方式</h3><p>Linux 提供了<strong>轮询</strong>、<strong>I/O 中断</strong>以及 <strong>DMA 传输</strong>这 3 种磁盘与主存之间的数据传输机制。其中轮询方式是基于<strong>死循环</strong>对 I/O 端口进行不断检测。I/O 中断方式是指当数据到达时，磁盘主动向 CPU 发起中断请求，由 CPU 自身负责数据的传输过程。 DMA 传输则在 I/O 中断的基础上引入了 <strong>DMA 磁盘控制器</strong>，由 DMA 磁盘控制器负责数据的传输，降低了 I/O 中断操作对 CPU 资源的大量消耗。</p><h4 id="4-1-I-O-中断原理"><a href="#4-1-I-O-中断原理" class="headerlink" title="4.1. I/O 中断原理"></a>4.1. I/O 中断原理</h4><p>在 DMA 技术出现之前，应用程序与磁盘之间的 I/O 操作都是通过 CPU 的中断完成的。每次用户进程读取磁盘数据时，都需要 CPU 中断，然后发起 I/O 请求等待数据读取和拷贝完成，每次的 I/O 中断都导致 CPU 的上下文切换。</p><p><img src="https://s1.ax1x.com/2020/05/08/YmOZ7Q.png" alt="I/O 中断原理"></p><ol><li>用户进程向 CPU 发起 <code>read</code> 系统调用读取数据，由用户态切换为内核态，然后一直阻塞等待数据的返回。</li><li>CPU 在接收到指令以后对磁盘发起 I/O 请求，将磁盘数据先放入<strong>磁盘控制器缓冲区</strong>。</li><li>数据准备完成以后，磁盘向 CPU 发起 I/O 中断。</li><li>CPU 收到 I/O 中断以后将磁盘控制器缓冲区中的数据拷贝到<strong>内核缓冲区</strong>，然后再从内核缓冲区拷贝到<strong>用户缓冲区</strong>。</li><li>用户进程由内核态切换回用户态，解除阻塞状态，然后等待 CPU 的下一个执行时间钟。</li></ol><h4 id="4-2-DMA-传输原理"><a href="#4-2-DMA-传输原理" class="headerlink" title="4.2. DMA 传输原理"></a>4.2. DMA 传输原理</h4><p>DMA 的全称叫直接内存存取（Direct Memory Access），是一种允许外围设备（硬件子系统）直接访问系统主内存的机制。也就是说，基于 DMA 访问方式，系统主内存于硬盘或网卡之间的数据传输可以绕开 CPU 的全程调度。目前大多数的硬件设备，包括磁盘控制器、网卡、显卡以及声卡等都支持 DMA 技术。</p><p><img src="https://s1.ax1x.com/2020/05/08/YmO0c6.png" alt=""></p><p>整个数据传输操作在一个 DMA 控制器的控制下进行的。CPU 除了在数据传输开始和结束时做一点处理外（开始和结束时候要做<strong>中断处理</strong>），在传输过程中 CPU 可以继续进行其他的工作。这样在大部分时间里，CPU 计算和 I/O 操作都处于并行操作，使整个计算机系统的效率大大提高。</p><p><img src="https://s1.ax1x.com/2020/05/08/YmOrnO.png" alt="DMA 传输原理"></p><p>有了 DMA 磁盘控制器接管数据读写请求以后，CPU 从繁重的 I/O 操作中解脱，数据读取操作的流程如下：</p><ol><li>用户进程向 CPU 发起 <code>read</code> 系统调用读取数据，由用户态切换为内核态，然后一直阻塞等待数据的返回。</li><li>CPU 在接收到指令以后对 DMA 磁盘控制器发起调度指令。</li><li>DMA 磁盘控制器对磁盘发起 I/O 请求，将磁盘数据先放入磁盘控制器缓冲区，CPU 全程不参与此过程。</li><li>数据读取完成后，DMA 磁盘控制器会接受到磁盘的通知，将数据从磁盘控制器缓冲区拷贝到内核缓冲区。</li><li>DMA 磁盘控制器向 CPU 发出数据读完的信号，由 CPU 负责将数据从内核缓冲区拷贝到用户缓冲区。</li><li>用户进程由内核态切换回用户态，解除阻塞状态，然后等待 CPU 的下一个执行时间钟。</li></ol><h3 id="5-传统-I-O-方式"><a href="#5-传统-I-O-方式" class="headerlink" title="5. 传统 I/O 方式"></a>5. 传统 I/O 方式</h3><p>为了更好的理解零拷贝解决的问题，我们首先了解一下传统 I/O 方式存在的问题。在 Linux 系统中，传统的访问方式是通过 <code>write()</code> 和 <code>read()</code> 两个系统调用实现的，通过 <code>read()</code> 函数读取文件到到缓存区中，然后通过 <code>write()</code> 方法把缓存中的数据输出到网络端口，伪代码如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">read</span><span class="token punctuation">(</span>file_fd<span class="token punctuation">,</span> tmp_buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">write</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> tmp_buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>下图分别对应传统 I/O 操作的数据读写流程，整个过程涉及 2 次 CPU 拷贝、2 次 DMA 拷贝总共 4 次拷贝，以及 4 次上下文切换，下面简单地阐述一下相关的概念。</p><p><img src="https://s1.ax1x.com/2020/05/08/YmXCE4.png" alt=""></p><ul><li><strong>上下文切换：</strong>当用户程序向内核发起系统调用时，CPU 将用户进程从用户态切换到内核态；当系统调用返回时，CPU 将用户进程从内核态切换回用户态。</li><li><strong>CPU 拷贝：</strong>由 CPU 直接处理数据的传送，数据拷贝时会一直占用 CPU 的资源。</li><li><strong>DMA 拷贝：</strong>由 CPU 向 DMA 磁盘控制器下达指令，让 DMA 控制器来处理数据的传送，数据传送完毕再把信息反馈给 CPU ，从而减轻了 CPU 资源的占有率。</li></ul><h4 id="5-1-传统读操作"><a href="#5-1-传统读操作" class="headerlink" title="5.1. 传统读操作"></a>5.1. 传统读操作</h4><p>当应用程序执行 <code>read</code> 系统调用读取一块数据的时候，如果这块数据已经存在于用户进程的页内存中，就直接从内存中读取数据；如果数据不存在，则先将数据从磁盘加载数据到内核空间的读缓存（read buffer）中，再从读缓存拷贝到用户进程的页内存中。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">read</span><span class="token punctuation">(</span>file_fd<span class="token punctuation">,</span> tmp_buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>基于传统的 I/O 读取方式，<code>read</code> 系统调用会触发 2 次上下文切换，1 次 DMA 拷贝和 1 次 CPU 拷贝，发起数据读取的流程如下：</p><ol><li>用户进程通过 <code>read()</code> 函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。</li><li>CPU 利用 DMA 控制器将数据从主存或硬盘拷贝到内核空间（kernel space）的读缓冲区（read buffer）。</li><li>CPU 将读缓冲区（read buffer）中的数据拷贝到用户空间（user space）的用户缓冲区（user buffer）。</li><li>上下文从内核态（kernel space）切换回用户态（user space），<code>read</code> 调用执行返回。</li></ol><h4 id="5-2-传统写操作"><a href="#5-2-传统写操作" class="headerlink" title="5.2. 传统写操作"></a>5.2. 传统写操作</h4><p>当应用程序准备好数据，执行 <code>write</code> 系统调用发送网络数据时，先将数据从用户空间的页缓存拷贝到内核空间的网络缓冲区（socket buffer）中，然后再将写缓存中的数据拷贝到网卡设备完成数据发送。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">write</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> tmp_buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>基于传统的 I/O 写入方式，<code>write()</code> 系统调用会触发 2 次上下文切换，1 次 CPU 拷贝和 1 次 DMA 拷贝，用户程序发送网络数据的流程如下：</p><ol><li>用户进程通过 <code>write()</code> 函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。</li><li>CPU 将用户缓冲区（user buffer）中的数据拷贝到内核空间（kernel space）的网络缓冲区（socket buffer）。</li><li>CPU 利用 DMA 控制器将数据从网络缓冲区（socket buffer）拷贝到网卡进行数据传输。</li><li>上下文从内核态（kernel space）切换回用户态（user space），<code>write</code> 系统调用执行返回。</li></ol><h3 id="6-零拷贝方式"><a href="#6-零拷贝方式" class="headerlink" title="6. 零拷贝方式"></a>6. 零拷贝方式</h3><p>在 Linux 中零拷贝技术主要有 3 个实现思路：用户态直接 I/O 、减少数据拷贝次数以及写时复制技术。</p><ul><li><strong>用户态直接 I/O ：</strong>应用程序可以直接访问硬件存储，操作系统内核只是辅助数据传输。这种方式依旧存在用户空间和内核空间的上下文切换，硬件上的数据直接拷贝至了用户空间，不经过内核空间。因此，直接 I/O 不存在内核空间缓冲区和用户空间缓冲区之间的数据拷贝。</li><li><strong>减少数据拷贝次数：</strong>在数据传输过程中，避免数据在用户空间缓冲区和系统内核空间缓冲区之间的 CPU 拷贝，以及数据在系统内核空间内的 CPU 拷贝，这也是当前主流零拷贝技术的实现思路。</li><li><strong>写时复制技术：</strong>写时复制指的是当多个进程共享同一块数据时，如果其中一个进程需要对这份数据进行修改，那么将其拷贝到自己的进程地址空间中，如果只是数据读取操作则不需要进行拷贝操作。</li></ul><h4 id="6-1-用户态直接-I-O"><a href="#6-1-用户态直接-I-O" class="headerlink" title="6.1. 用户态直接 I/O"></a>6.1. 用户态直接 I/O</h4><p>用户态直接 I/O 使得应用进程或运行在用户态（user space）下的库函数直接访问硬件设备，数据直接跨过内核进行传输，内核在数据传输过程除了进行必要的虚拟存储配置工作之外，不参与任何其他工作，这种方式能够直接绕过内核，极大提高了性能。</p><p><img src="https://s1.ax1x.com/2020/05/08/YuYjI0.png" alt="用户态直接 I/O"></p><p>用户态直接 I/O 只能适用于不需要内核缓冲区处理的应用程序，这些应用程序通常在进程地址空间有自己的数据缓存机制，称为<strong>自缓存应用程序</strong>，如数据库管理系统就是一个代表。其次，这种零拷贝机制会直接操作磁盘 I/O ，由于 CPU 和磁盘 I/O 之间的执行时间差距，会造成大量资源的浪费，解决方案是配合异步 I/O 使用。</p><h4 id="6-2-mmap-write"><a href="#6-2-mmap-write" class="headerlink" title="6.2. mmap + write"></a>6.2. mmap + write</h4><p>一种零拷贝方式是使用 <code>mmap + write</code> 代替原来的 <code>read + write</code> 方式，减少了 1 次 CPU 拷贝操作。<code>mmap</code> 是 Linux 提供的一种<strong>内存映射文件方法</strong>，即将一个进程的地址空间中的一段虚拟地址映射到磁盘文件地址，<code>mmap + write</code> 的伪代码如下：</p><pre class=" language-cpp"><code class="language-cpp">tmp_buf <span class="token operator">=</span> <span class="token function">mmap</span><span class="token punctuation">(</span>file_fd<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">write</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> tmp_buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>使用 <code>mmap</code> 的目的是将内核中读缓冲区（read buffer）的地址与用户空间的缓冲区（user buffer）进行映射，从而实现内核缓冲区与应用程序内存的共享，省去了将数据从内核读缓冲区（read buffer）拷贝到用户缓冲区（user buffer）的过程，然而内核读缓冲区（read buffer）仍需将数据到内核写缓冲区（socket buffer），大致的流程如下图所示：</p><p><img src="https://s1.ax1x.com/2020/05/08/YuNGnJ.png" alt="mmap + write"></p><p>基于 <code>mmap + write</code> 系统调用的零拷贝方式，整个拷贝过程会发生 4 次上下文切换，1 次 CPU 拷贝和 2 次 DMA 拷贝，用户程序读写数据的流程如下：</p><ol><li>用户进程通过 <code>mmap()</code> 函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。</li><li>将用户进程的内核空间的读缓冲区（read buffer）与用户空间的缓存区（user buffer）进行内存地址映射。</li><li>CPU 利用 DMA 控制器将数据从主存或硬盘拷贝到内核空间（kernel space）的读缓冲区（read buffer）。</li><li>上下文从内核态（kernel space）切换回用户态（user space），<code>mmap</code> 系统调用执行返回。</li><li>用户进程通过 <code>write()</code> 函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。</li><li>CPU 将读缓冲区（read buffer）中的数据拷贝到的网络缓冲区（socket buffer）。</li><li>CPU 利用 DMA 控制器将数据从网络缓冲区（socket buffer）拷贝到网卡进行数据传输。</li><li>上下文从内核态（kernel space）切换回用户态（user space），<code>write</code> 系统调用执行返回。</li></ol><p><code>mmap</code> 主要的用处是提高 I/O 性能，特别是针对大文件。对于小文件，内存映射文件反而会导致碎片空间的浪费，因为内存映射总是要对齐页边界，最小单位是 4 KB ，一个 5 KB 的文件将会映射占用 8 KB 内存，也就会浪费 3 KB 内存。</p><p><code>mmap</code> 的拷贝虽然减少了 1 次拷贝，提升了效率，但也存在一些<strong>隐藏的问题</strong>。当 <code>mmap</code> 一个文件时，如果这个文件被另一个进程所截获，那么 <code>write</code> 系统调用会因为访问非法地址被 <strong>SIGBUS</strong> 信号终止，<strong>SIGBUS</strong> 默认会杀死进程并产生一个 <code>coredump</code> ，服务器可能因此被终止。</p><h4 id="6-3-sendfile"><a href="#6-3-sendfile" class="headerlink" title="6.3. sendfile"></a>6.3. sendfile</h4><p><code>sendfile</code> 系统调用在 Linux 内核版本 2.1 中被引入，目的是简化通过网络在两个通道之间进行的数据传输过程。<code>sendfile</code> 系统调用的引入，不仅减少了 CPU 拷贝的次数，还减少了上下文切换的次数，它的伪代码如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">sendfile</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> file_fd<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>通过 <code>sendfile</code> 系统调用，数据可以直接在内核空间内部进行 I/O 传输，从而省去了数据在用户空间和内核空间之间的来回拷贝。与 <code>mmap</code> 内存映射方式不同的是， <code>sendfile</code> 调用中 I/O 数据对用户空间是<strong>完全不可见</strong>的。也就是说，这是一次完全意义上的数据传输过程。</p><p><img src="https://s1.ax1x.com/2020/05/08/YuwzJ1.png" alt="sendfile"></p><p>基于 <code>sendfile</code> 系统调用的零拷贝方式，整个拷贝过程会发生 2 次上下文切换，1 次 CPU 拷贝和 2 次 DMA 拷贝，用户程序读写数据的流程如下：</p><ol><li>用户进程通过 <code>sendfile()</code> 函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。</li><li>CPU 利用 DMA 控制器将数据从主存或硬盘拷贝到内核空间（kernel space）的读缓冲区（read buffer）。</li><li>CPU 将读缓冲区（read buffer）中的数据拷贝到的网络缓冲区（socket buffer）。</li><li>CPU 利用 DMA 控制器将数据从网络缓冲区（socket buffer）拷贝到网卡进行数据传输。</li><li>上下文从内核态（kernel space）切换回用户态（user space），<code>sendfile</code> 系统调用执行返回。</li></ol><p>相比较于 <code>mmap</code> 内存映射的方式，<code>sendfile</code> 少了 2 次上下文切换，但是仍然有 1 次 CPU 拷贝操作。<code>sendfile</code> 存在的问题是<strong>用户程序不能对数据进行修改，而只是单纯地完成了一次数据传输过程</strong>。</p><h4 id="6-4-sendfile-DMA-gather-copy"><a href="#6-4-sendfile-DMA-gather-copy" class="headerlink" title="6.4. sendfile + DMA gather copy"></a>6.4. sendfile + DMA gather copy</h4><p>Linux 2.4 版本的内核对 <code>sendfile</code> 系统调用进行修改，为  DMA 拷贝引入了 <code>gather</code> 操作。它将内核空间（kernel space）的读缓冲区（read buffer）中对应的数据描述信息（内存地址、地址偏移量）记录到相应的网络缓冲区（socket  buffer）中，由 DMA 根据内存地址、地址偏移量将数据批量地从读缓冲区（read buffer）拷贝到网卡设备中，这样就省去了内核空间中仅剩的 1 次 CPU 拷贝操作，<code>sendfile</code> 的伪代码如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">sendfile</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> file_fd<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在硬件的支持下，<code>sendfile</code> 拷贝方式不再从内核缓冲区的数据拷贝到 socket 缓冲区，取而代之的仅仅是缓冲区文件描述符和数据长度的拷贝，这样 DMA 引擎直接利用 <code>gather</code> 操作将页缓存中数据打包发送到网络中即可，本质就是和虚拟内存映射的思路类似。</p><p><img src="https://s1.ax1x.com/2020/05/08/Yu0L1P.png" alt="sendfile + DMA gather copy"></p><p>基于 <code>sendfile + DMA gather copy</code> 系统调用的零拷贝方式，整个拷贝过程会发生 2 次上下文切换、0 次 CPU 拷贝以及 2 次 DMA 拷贝，用户程序读写数据的流程如下：</p><ol><li>用户进程通过 <code>sendfile()</code> 函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。</li><li>CPU 利用 DMA 控制器将数据从主存或硬盘拷贝到内核空间（kernel space）的读缓冲区（read buffer）。</li><li>CPU 把读缓冲区（read buffer）的文件描述符（file descriptor）和数据长度拷贝到网络缓冲区（socket buffer）。</li><li>基于已拷贝的文件描述符（file descriptor）和数据长度，CPU 利用 DMA 控制器的 <code>gather/scatter</code> 操作直接批量地将数据从内核的读缓冲区（read buffer）拷贝到网卡进行数据传输。</li><li>上下文从内核态（kernel space）切换回用户态（user space），<code>sendfile</code> 系统调用执行返回。</li></ol><p><code>sendfile + DMA gather copy</code> 拷贝方式同样<strong>存在用户程序不能对数据进行修改的问题，而且本身需要硬件的支持</strong>，它只适用于将数据从文件拷贝到 socket 套接字上的传输过程。</p><h4 id="6-5-splice"><a href="#6-5-splice" class="headerlink" title="6.5. splice"></a>6.5. splice</h4><p><code>sendfile</code> 只适用于将数据从文件拷贝到 socket 套接字上，同时需要硬件的支持，这也限定了它的使用范围。Linux 在 2.6.17 版本引入 <code>splice</code> 系统调用，不仅不需要硬件支持，还实现了两个文件描述符之间的数据零拷贝。splice 的伪代码如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">splice</span><span class="token punctuation">(</span>fd_in<span class="token punctuation">,</span> off_in<span class="token punctuation">,</span> fd_out<span class="token punctuation">,</span> off_out<span class="token punctuation">,</span> len<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>splice</code> 系统调用可以在内核空间的读缓冲区（read buffer）和网络缓冲区（socket buffer）之间建立<strong>管道</strong>（pipeline），从而避免了两者之间的 CPU 拷贝操作。</p><p><img src="https://s1.ax1x.com/2020/05/08/YuBl1x.png" alt="splice"></p><p>基于 <code>splice</code> 系统调用的零拷贝方式，整个拷贝过程会发生 2 次上下文切换，0 次 CPU 拷贝以及 2 次 DMA 拷贝，用户程序读写数据的流程如下：</p><ol><li>用户进程通过 <code>splice()</code> 函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。</li><li>CPU 利用 DMA 控制器将数据从主存或硬盘拷贝到内核空间（kernel space）的读缓冲区（read buffer）。</li><li>CPU 在内核空间的读缓冲区（read buffer）和网络缓冲区（socket buffer）之间建立管道（pipeline）。</li><li>CPU 利用 DMA 控制器将数据从网络缓冲区（socket buffer）拷贝到网卡进行数据传输。</li><li>上下文从内核态（kernel space）切换回用户态（user space），<code>splice</code> 系统调用执行返回。</li></ol><p><code>splice</code> 拷贝方式也同样<strong>存在用户程序不能对数据进行修改的问题</strong>。除此之外，它使用了 Linux 的<strong>管道缓冲机制</strong>，可以用于任意两个文件描述符中传输数据，但是它的两个文件描述符参数中有一个必须是管道设备。</p><h4 id="6-6-写时复制"><a href="#6-6-写时复制" class="headerlink" title="6.6. 写时复制"></a>6.6. 写时复制</h4><p>在某些情况下，内核缓冲区可能被多个进程所共享，如果某个进程想要这个共享区进行 <code>write</code> 操作，由于 <code>write</code> 不提供任何的锁操作，那么就会对共享区中的数据造成破坏，写时复制的引入就是 Linux 用来保护数据的。</p><p>写时复制指的是当多个进程共享同一块数据时，如果其中一个进程需要对这份数据进行修改，那么就需要将其拷贝到自己的进程地址空间中。这样做并不影响其他进程对这块数据的操作，每个进程要修改的时候才会进行拷贝，所以叫写时拷贝。这种方法在某种程度上能够降低系统开销，如果某个进程永远不会对所访问的数据进行更改，那么也就永远不需要拷贝。</p><h4 id="6-7-缓冲区共享"><a href="#6-7-缓冲区共享" class="headerlink" title="6.7. 缓冲区共享"></a>6.7. 缓冲区共享</h4><p>缓冲区共享方式完全改写了传统的 I/O 操作，因为传统 I/O 接口都是基于数据拷贝进行的，要避免拷贝就得去掉原先的那套接口并重新改写，所以这种方法是比较全面的零拷贝技术，目前比较成熟的一个方案是在 Solaris 上实现的 <code>fbuf</code>（Fast Buffer，快速缓冲区）。</p><p><code>fbuf</code> 的思想是每个进程都维护着一个缓冲区池，这个缓冲区池能被同时映射到用户空间（user space）和内核态（kernel space），内核和用户共享这个缓冲区池，这样就避免了一系列的拷贝操作。</p><p><img src="https://s1.ax1x.com/2020/05/08/YuBbE4.png" alt="fbuf"></p><p>缓冲区共享的难度在于管理共享缓冲区池需要<strong>应用程序</strong>、<strong>网络软件</strong>以及<strong>设备驱动程序</strong>之间的紧密合作，而且如何改写 API 目前还处于试验阶段并不成熟。</p><h3 id="7-Linux-零拷贝对比"><a href="#7-Linux-零拷贝对比" class="headerlink" title="7. Linux 零拷贝对比"></a>7. Linux 零拷贝对比</h3><p>无论是传统 I/O 拷贝方式还是引入零拷贝的方式，2 次 DMA Copy 是都少不了的，因为两次 DMA 都是依赖硬件完成的。下面从 CPU 拷贝次数、DMA 拷贝次数以及系统调用几个方面总结一下上述几种 I/O 拷贝方式的差别。</p><table><thead><tr><th>拷贝方式</th><th align="center">CPU拷贝</th><th align="center">DMA拷贝</th><th align="center">系统调用</th><th align="center">上下文切换</th></tr></thead><tbody><tr><td>传统方式（read + write）</td><td align="center">2</td><td align="center">2</td><td align="center">read / write</td><td align="center">4</td></tr><tr><td>内存映射（mmap + write）</td><td align="center">1</td><td align="center">2</td><td align="center">mmap / write</td><td align="center">4</td></tr><tr><td>sendfile</td><td align="center">1</td><td align="center">2</td><td align="center">sendfile</td><td align="center">2</td></tr><tr><td>sendfile + DMA gather copy</td><td align="center">0</td><td align="center">2</td><td align="center">sendfile</td><td align="center">2</td></tr><tr><td>splice</td><td align="center">0</td><td align="center">2</td><td align="center">splice</td><td align="center">2</td></tr></tbody></table><h3 id="8-Java-NIO-零拷贝实现"><a href="#8-Java-NIO-零拷贝实现" class="headerlink" title="8. Java NIO 零拷贝实现"></a>8. Java NIO 零拷贝实现</h3><p>在 Java NIO 中的通道（Channel）就相当于操作系统的内核空间（kernel space）的缓冲区，而缓冲区（Buffer）对应的相当于操作系统的用户空间（user space）中的用户缓冲区（user buffer）。</p><ul><li>通道（Channel）是<strong>全双工</strong>的（双向传输），它既可能是读缓冲区（read buffer），也可能是网络缓冲区（socket buffer）。</li><li>缓冲区（Buffer）分为<strong>堆内存</strong>（HeapBuffer）和<strong>堆外内存</strong>（DirectBuffer），这是通过 <code>malloc()</code> 分配出来的用户态内存。</li></ul><p>堆外内存（DirectBuffer）在使用后需要应用程序<strong>手动回收</strong>，而堆内存（HeapBuffer）的数据在 GC 时可能会被<strong>自动回收</strong>。因此，在使用 HeapBuffer 读写数据时，为了避免缓冲区数据因为 GC 而丢失，NIO 会先把 HeapBuffer 内部的数据拷贝到一个临时的 DirectBuffer 中的<strong>本地内存</strong>（native memory），这个拷贝涉及到 <code>sun.misc.Unsafe.copyMemory()</code> 的调用，背后的实现原理与 <code>memcpy()</code> 类似。 最后，将临时生成的 DirectBuffer 内部的数据的内存地址传给 I/O 调用函数，这样就避免了再去访问 Java 对象处理 I/O 读写。</p><h4 id="8-1-MappedByteBuffer"><a href="#8-1-MappedByteBuffer" class="headerlink" title="8.1. MappedByteBuffer"></a>8.1. MappedByteBuffer</h4><p><strong>MappedByteBuffer</strong> 是 NIO 基于内存映射（mmap）这种零拷贝方式的提供的一种实现，它继承自 ByteBuffer 。FileChannel 定义了一个 <code>map()</code> 方法，它可以把一个文件从 position 位置开始的 size 大小的区域映射为<strong>内存映像文件</strong>。抽象方法 <code>map()</code> 方法在 FileChannel 中的定义如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> MappedByteBuffer <span class="token function">map</span><span class="token punctuation">(</span>MapMode mode<span class="token punctuation">,</span> <span class="token keyword">long</span> position<span class="token punctuation">,</span> <span class="token keyword">long</span> size<span class="token punctuation">)</span>        <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span></code></pre><ul><li><strong>mode ：</strong>限定内存映射区域（MappedByteBuffer）对内存映像文件的访问模式，包括<strong>只可读</strong>（READ_ONLY）、<strong>可读可写</strong>（READ_WRITE）和写<strong>时拷贝</strong>（PRIVATE）三种模式。</li><li><strong>position ：</strong>文件映射的起始地址，对应内存映射区域（MappedByteBuffer）的首地址。</li><li><strong>size ：</strong>文件映射的字节长度，从 position 往后的字节数，对应内存映射区域（MappedByteBuffer）的大小。</li></ul><p>MappedByteBuffer 相比 ByteBuffer 新增了 <code>force()</code> 、<code>load()</code> 和 <code>isLoad()</code> 三个重要的方法：</p><ul><li><strong>force() ：</strong>对于处于 <strong>READ_WRITE</strong> 模式下的缓冲区，把对缓冲区内容的修改强制刷新到本地文件。</li><li><strong>load() ：</strong>将缓冲区的内容载入物理内存中，并返回这个缓冲区的引用。</li><li><strong>isLoaded() ：</strong>如果缓冲区的内容在物理内存中，则返回 true，否则返回 false。</li></ul><p>下面给出一个利用 MappedByteBuffer 对文件进行读写的使用示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> String CONTENT <span class="token operator">=</span> <span class="token string">"Zero copy implemented by MappedByteBuffer"</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> String FILE_NAME <span class="token operator">=</span> <span class="token string">"/mmap.txt"</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> String CHARSET <span class="token operator">=</span> <span class="token string">"UTF-8"</span><span class="token punctuation">;</span></code></pre><ul><li><strong>写文件数据：</strong>打开文件通道 fileChannel 并提供读权限、写权限和数据清空权限，通过 fileChannel 映射到一个可写的内存缓冲区 mappedByteBuffer ，将目标数据写入 mappedByteBuffer ，通过 <code>force()</code> 方法把缓冲区更改的内容强制写入本地文件。</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeToFileByMappedByteBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Path path <span class="token operator">=</span> Paths<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span>FILE_NAME<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> CONTENT<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>Charset<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>CHARSET<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">(</span>FileChannel fileChannel <span class="token operator">=</span> FileChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> StandardOpenOption<span class="token punctuation">.</span>READ<span class="token punctuation">,</span>            StandardOpenOption<span class="token punctuation">.</span>WRITE<span class="token punctuation">,</span> StandardOpenOption<span class="token punctuation">.</span>TRUNCATE_EXISTING<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        MappedByteBuffer mappedByteBuffer <span class="token operator">=</span> fileChannel<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>READ_WRITE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> bytes<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mappedByteBuffer <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            mappedByteBuffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>            mappedByteBuffer<span class="token punctuation">.</span><span class="token function">force</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li><strong>读文件数据：</strong>打开文件通道 fileChannel 并提供只读权限，通过 fileChannel 映射到一个只可读的内存缓冲区 mappedByteBuffer，读取 mappedByteBuffer 中的字节数组即可得到文件数据。</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">readFromFileByMappedByteBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Path path <span class="token operator">=</span> Paths<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span>FILE_NAME<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> CONTENT<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>Charset<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>CHARSET<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">(</span>FileChannel fileChannel <span class="token operator">=</span> FileChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> StandardOpenOption<span class="token punctuation">.</span>READ<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        MappedByteBuffer mappedByteBuffer <span class="token operator">=</span> fileChannel<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>READ_ONLY<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mappedByteBuffer <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>            mappedByteBuffer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>            String content <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> StandardCharsets<span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">assertEquals</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> <span class="token string">"Zero copy implemented by MappedByteBuffer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>下面介绍 <code>map()</code> 方法的底层实现原理。<code>map()</code> 方法是 <code>java.nio.channels.FileChannel</code> 的抽象方法，由子类 <code>sun.nio.ch.FileChannelImpl.java</code> 实现，下面是和内存映射相关的核心代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> MappedByteBuffer <span class="token function">map</span><span class="token punctuation">(</span>MapMode mode<span class="token punctuation">,</span> <span class="token keyword">long</span> position<span class="token punctuation">,</span> <span class="token keyword">long</span> size<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token keyword">int</span> pagePosition <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>position <span class="token operator">%</span> allocationGranularity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> mapPosition <span class="token operator">=</span> position <span class="token operator">-</span> pagePosition<span class="token punctuation">;</span>    <span class="token keyword">long</span> mapSize <span class="token operator">=</span> size <span class="token operator">+</span> pagePosition<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        addr <span class="token operator">=</span> <span class="token function">map0</span><span class="token punctuation">(</span>imode<span class="token punctuation">,</span> mapPosition<span class="token punctuation">,</span> mapSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">OutOfMemoryError</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            addr <span class="token operator">=</span> <span class="token function">map0</span><span class="token punctuation">(</span>imode<span class="token punctuation">,</span> mapPosition<span class="token punctuation">,</span> mapSize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">OutOfMemoryError</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IOException</span><span class="token punctuation">(</span><span class="token string">"Map failed"</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> isize <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>size<span class="token punctuation">;</span>    Unmapper um <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Unmapper</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span> mapSize<span class="token punctuation">,</span> isize<span class="token punctuation">,</span> mfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>writable<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>imode <span class="token operator">==</span> MAP_RO<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Util<span class="token punctuation">.</span><span class="token function">newMappedByteBufferR</span><span class="token punctuation">(</span>isize<span class="token punctuation">,</span> addr <span class="token operator">+</span> pagePosition<span class="token punctuation">,</span> mfd<span class="token punctuation">,</span> um<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Util<span class="token punctuation">.</span><span class="token function">newMappedByteBuffer</span><span class="token punctuation">(</span>isize<span class="token punctuation">,</span> addr <span class="token operator">+</span> pagePosition<span class="token punctuation">,</span> mfd<span class="token punctuation">,</span> um<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>map()</code> 方法通过本地方法 <code>map0()</code>  为文件分配一块虚拟内存，作为它的内存映射区域，然后返回这块内存映射区域的起始地址。</p><ol><li>文件映射需要在 Java 堆中创建一个 <strong>MappedByteBuffer</strong> 的实例。如果第一次文件映射导致 OOM，则手动触发垃圾回收，休眠 100ms 后再尝试映射，如果失败则抛出异常。</li><li>通过 Util 的 <code>newMappedByteBuffer</code>（可读可写）方法或者 <code>newMappedByteBufferR</code>（仅读） 方法反射创建一个 <strong>DirectByteBuffer</strong> 实例，其中 DirectByteBuffer 是 MappedByteBuffer 的子类。</li></ol><p><code>map()</code> 方法返回的是内存映射区域的起始地址，通过（起始地址 + 偏移量）就可以获取指定内存的数据。这样一定程度上替代了 <code>read()</code> 或 <code>write()</code> 方法，底层直接采用 <code>sun.misc.Unsafe</code> 类的 <code>getByte()</code> 和 <code>putByte()</code> 方法对数据进行读写。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">native</span> <span class="token keyword">long</span> <span class="token function">map0</span><span class="token punctuation">(</span><span class="token keyword">int</span> prot<span class="token punctuation">,</span> <span class="token keyword">long</span> position<span class="token punctuation">,</span> <span class="token keyword">long</span> mapSize<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span></code></pre><p>上面是本地方法（native method）<code>map0</code> 的定义，它通过 JNI（Java Native Interface）调用底层 C 的实现，这个 native 函数（Java_sun_nio_ch_FileChannelImpl_map0）的实现位于 JDK 源码包下的  native/sun/nio/ch/FileChannelImpl.c 这个源文件里面。</p><pre class=" language-c"><code class="language-c">JNIEXPORT jlong JNICALL<span class="token function">Java_sun_nio_ch_FileChannelImpl_map0</span><span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span>env<span class="token punctuation">,</span> jobject this<span class="token punctuation">,</span>                                     jint prot<span class="token punctuation">,</span> jlong off<span class="token punctuation">,</span> jlong len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token operator">*</span>mapAddress <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    jobject fdo <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">GetObjectField</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> this<span class="token punctuation">,</span> chan_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    jint fd <span class="token operator">=</span> <span class="token function">fdval</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> fdo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> protections <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prot <span class="token operator">==</span> sun_nio_ch_FileChannelImpl_MAP_RO<span class="token punctuation">)</span> <span class="token punctuation">{</span>        protections <span class="token operator">=</span> PROT_READ<span class="token punctuation">;</span>        flags <span class="token operator">=</span> MAP_SHARED<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>prot <span class="token operator">==</span> sun_nio_ch_FileChannelImpl_MAP_RW<span class="token punctuation">)</span> <span class="token punctuation">{</span>        protections <span class="token operator">=</span> PROT_WRITE <span class="token operator">|</span> PROT_READ<span class="token punctuation">;</span>        flags <span class="token operator">=</span> MAP_SHARED<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>prot <span class="token operator">==</span> sun_nio_ch_FileChannelImpl_MAP_PV<span class="token punctuation">)</span> <span class="token punctuation">{</span>        protections <span class="token operator">=</span>  PROT_WRITE <span class="token operator">|</span> PROT_READ<span class="token punctuation">;</span>        flags <span class="token operator">=</span> MAP_PRIVATE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    mapAddress <span class="token operator">=</span> <span class="token function">mmap64</span><span class="token punctuation">(</span>        <span class="token number">0</span><span class="token punctuation">,</span>                    <span class="token comment" spellcheck="true">/* Let OS decide location */</span>        len<span class="token punctuation">,</span>                  <span class="token comment" spellcheck="true">/* Number of bytes to map */</span>        protections<span class="token punctuation">,</span>          <span class="token comment" spellcheck="true">/* File permissions */</span>        flags<span class="token punctuation">,</span>                <span class="token comment" spellcheck="true">/* Changes are shared */</span>        fd<span class="token punctuation">,</span>                   <span class="token comment" spellcheck="true">/* File descriptor of mapped file */</span>        off<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">/* Offset into file */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mapAddress <span class="token operator">==</span> MAP_FAILED<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> ENOMEM<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">JNU_ThrowOutOfMemoryError</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> <span class="token string">"Map failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> IOS_THROWN<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">handle</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Map failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>jlong<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> mapAddress<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以看出 <code>map0()</code> 函数最终是通过 <code>mmap64()</code> 这个函数对 Linux 底层内核发出内存映射的调用， <code>mmap64()</code> 函数的原型如下：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/mman.h></span></span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mmap64</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> size_t len<span class="token punctuation">,</span> <span class="token keyword">int</span> prot<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> off64_t offset<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>下面详细介绍一下 <code>mmap64()</code> 函数各个参数的含义以及参数可选值：</p><ul><li><strong>addr ：</strong>文件在用户进程空间的内存 映射区中的起始地址，是一个建议的参数，通常可设置为 0 或 NULL，此时由内核去决定真实的起始地址。当 <code>flags</code> 为 <strong>MAP_FIXED</strong> 时，<code>addr</code> 就是一个必选的参数，即需要提供一个存在的地址。</li><li><strong>len ：</strong>文件需要进行内存映射的字节长度。</li><li><strong>prot ：</strong>控制用户进程对内存映射区的访问权限。<ul><li>PROT_READ：读权限</li><li>PROT_WRITE：写权限</li><li>PROT_EXEC：执行权限</li><li>PROT_NONE：无权限</li></ul></li><li><strong>flags ：</strong>控制内存映射区的修改是否被多个进程共享。<ul><li>MAP_PRIVATE：对内存映射区数据的修改不会反映到真正的文件，数据修改发生时采用写时复制机制</li><li>MAP_SHARED：对内存映射区的修改会同步到真正的文件，修改对共享此内存映射区的进程是可见的</li><li>MAP_FIXED：不建议使用，这种模式下 addr 参数指定的必须的提供一个存在的 addr 参数</li></ul></li><li><strong>fd ：</strong>文件描述符。每次 map 操作会导致文件的引用计数加 1，每次 <code>unmap</code> 操作或者结束进程会导致引用计数减 1 。</li><li><strong>offset ：</strong>文件偏移量。进行映射的文件位置，从文件起始地址向后的位移量。</li></ul><p>下面总结一下 <strong>MappedByteBuffer</strong> 的特点和不足之处：</p><ul><li>MappedByteBuffer 使用是堆外的虚拟内存，因此分配（map）的内存大小不受 JVM 的 <code>-Xmx</code> 参数限制，但是也是有大小限制的。</li><li>如果当文件超出 <strong>Integer.MAX_VALUE</strong> 字节限制时，可以通过 <code>position</code> 参数重新 <code>map</code> 文件后面的内容。</li><li>MappedByteBuffer 在处理大文件时性能的确很高，但也存内存占用、文件关闭不确定等问题，被其打开的文件只有在垃圾回收的才会被关闭，而且这个时间点是不确定的。</li><li>MappedByteBuffer 提供了文件映射内存的 <code>mmap()</code> 方法，也提供了释放映射内存的 <code>unmap()</code> 方法。然而 <code>unmap()</code> 是 FileChannelImpl 中的私有方法，无法直接显示调用。因此，用户程序需要通过 Java 反射的调用 <code>sun.misc.Cleaner</code> 类的 <code>clean()</code> 方法手动释放映射占用的内存区域。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">clean</span><span class="token punctuation">(</span><span class="token keyword">final</span> Object buffer<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token punctuation">(</span>PrivilegedAction<span class="token operator">&lt;</span>Void<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Method getCleanerMethod <span class="token operator">=</span> buffer<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"cleaner"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            getCleanerMethod<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Cleaner cleaner <span class="token operator">=</span> <span class="token punctuation">(</span>Cleaner<span class="token punctuation">)</span> getCleanerMethod<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cleaner<span class="token punctuation">.</span><span class="token function">clean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="8-2-DirectByteBuffer"><a href="#8-2-DirectByteBuffer" class="headerlink" title="8.2. DirectByteBuffer"></a>8.2. DirectByteBuffer</h4><p><strong>DirectByteBuffer</strong> 的对象引用位于 Java 内存模型的堆里面，JVM 可以对 DirectByteBuffer 的对象进行内存分配和回收管理，一般使用 DirectByteBuffer 的静态方法 <code>allocateDirect()</code> 创建 DirectByteBuffer 实例并分配内存。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ByteBuffer <span class="token function">allocateDirect</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DirectByteBuffer</span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>DirectByteBuffer 内部的字节缓冲区位在于堆外的（用户态）直接内存，它是通过 Unsafe 的本地方法 <code>allocateMemory()</code> 进行内存分配，底层调用的是操作系统的 <code>malloc()</code> 函数。</p><pre class=" language-java"><code class="language-java"><span class="token function">DirectByteBuffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> cap<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> pa <span class="token operator">=</span> VM<span class="token punctuation">.</span><span class="token function">isDirectMemoryPageAligned</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ps <span class="token operator">=</span> Bits<span class="token punctuation">.</span><span class="token function">pageSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> size <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>1L<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>cap <span class="token operator">+</span> <span class="token punctuation">(</span>pa <span class="token operator">?</span> ps <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Bits<span class="token punctuation">.</span><span class="token function">reserveMemory</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> base <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        base <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">allocateMemory</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">OutOfMemoryError</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Bits<span class="token punctuation">.</span><span class="token function">unreserveMemory</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    unsafe<span class="token punctuation">.</span><span class="token function">setMemory</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pa <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>base <span class="token operator">%</span> ps <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        address <span class="token operator">=</span> base <span class="token operator">+</span> ps <span class="token operator">-</span> <span class="token punctuation">(</span>base <span class="token operator">&amp;</span> <span class="token punctuation">(</span>ps <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        address <span class="token operator">=</span> base<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cleaner <span class="token operator">=</span> Cleaner<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Deallocator</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> size<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    att <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>除此之外，初始化 DirectByteBuffer 时还会创建一个 <strong>Deallocator</strong> 线程，并通过 Cleaner 的 <code>freeMemory()</code> 方法来对直接内存进行回收操作，<code>freeMemory()</code> 底层调用的是操作系统的 <code>free()</code> 函数。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Deallocator</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Unsafe unsafe <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> address<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Deallocator</span><span class="token punctuation">(</span><span class="token keyword">long</span> address<span class="token punctuation">,</span> <span class="token keyword">long</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">assert</span> <span class="token punctuation">(</span>address <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>address <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        unsafe<span class="token punctuation">.</span><span class="token function">freeMemory</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>        address <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        Bits<span class="token punctuation">.</span><span class="token function">unreserveMemory</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>由于使用 DirectByteBuffer 分配的是系统本地的内存，不在 JVM 的管控范围之内，因此直接内存的回收和堆内存的回收不同，直接内存如果使用不当，很容易造成 <strong>OutOfMemoryError</strong> 。</p><blockquote><p>说了这么多，那么 DirectByteBuffer 和零拷贝有什么关系？</p></blockquote><p>前面有提到在 MappedByteBuffer 进行内存映射时，它的 <code>map()</code> 方法会通过 <code>Util.newMappedByteBuffer()</code> 来创建一个缓冲区实例，初始化的代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> MappedByteBuffer <span class="token function">newMappedByteBuffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">,</span> <span class="token keyword">long</span> addr<span class="token punctuation">,</span> FileDescriptor fd<span class="token punctuation">,</span>                                            Runnable unmapper<span class="token punctuation">)</span> <span class="token punctuation">{</span>    MappedByteBuffer dbb<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>directByteBufferConstructor <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token function">initDBBConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        dbb <span class="token operator">=</span> <span class="token punctuation">(</span>MappedByteBuffer<span class="token punctuation">)</span>directByteBufferConstructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>            <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Long</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> unmapper <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InstantiationException</span> <span class="token operator">|</span> IllegalAccessException <span class="token operator">|</span> InvocationTargetException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InternalError</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dbb<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">initDBBRConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrivilegedAction</span><span class="token operator">&lt;</span>Void<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> Void <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> cl <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.nio.DirectByteBufferR"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Constructor<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> ctor <span class="token operator">=</span> cl<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span>                    <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">long</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> FileDescriptor<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>                                    Runnable<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                ctor<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                directByteBufferRConstructor <span class="token operator">=</span> ctor<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> <span class="token operator">|</span> NoSuchMethodException <span class="token operator">|</span>                     IllegalArgumentException <span class="token operator">|</span> ClassCastException x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InternalError</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>DirectByteBuffer 是 MappedByteBuffer 的具体实现类。实际上，<code>Util.newMappedByteBuffer()</code> 方法通过反射机制获取  DirectByteBuffer 的构造器，然后创建一个 DirectByteBuffer 的实例，对应的是一个单独用于内存映射的构造方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token function">DirectByteBuffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">,</span> <span class="token keyword">long</span> addr<span class="token punctuation">,</span> FileDescriptor fd<span class="token punctuation">,</span> Runnable unmapper<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> cap<span class="token punctuation">,</span> cap<span class="token punctuation">,</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    address <span class="token operator">=</span> addr<span class="token punctuation">;</span>    cleaner <span class="token operator">=</span> Cleaner<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> unmapper<span class="token punctuation">)</span><span class="token punctuation">;</span>    att <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>因此，除了允许分配操作系统的直接内存以外，DirectByteBuffer 本身也具有文件内存映射的功能，这里不做过多说明。我们需要关注的是，DirectByteBuffer 在 MappedByteBuffer 的基础上提供了内存映像文件的随机读取 <code>get()</code> 和写入 <code>write()</code> 的操作。</p><ul><li>内存映像文件的随机读操作：</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">byte</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">getByte</span><span class="token punctuation">(</span><span class="token function">ix</span><span class="token punctuation">(</span><span class="token function">nextGetIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">byte</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">getByte</span><span class="token punctuation">(</span><span class="token function">ix</span><span class="token punctuation">(</span><span class="token function">checkIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>内存映像文件的随机写操作：</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ByteBuffer <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">byte</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    unsafe<span class="token punctuation">.</span><span class="token function">putByte</span><span class="token punctuation">(</span><span class="token function">ix</span><span class="token punctuation">(</span><span class="token function">nextPutIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> ByteBuffer <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">byte</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    unsafe<span class="token punctuation">.</span><span class="token function">putByte</span><span class="token punctuation">(</span><span class="token function">ix</span><span class="token punctuation">(</span><span class="token function">checkIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>内存映像文件的随机读写都是借助 <code>ix()</code> 方法实现定位的， <code>ix()</code> 方法通过内存映射空间的内存首地址（address）和给定偏移量 <strong>i</strong> 计算出指针地址，然后由 unsafe 类的 <code>get()</code> 和 <code>put()</code> 方法和对指针指向的数据进行读取或写入。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">long</span> <span class="token function">ix</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> address <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>i <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="8-3-FileChannel"><a href="#8-3-FileChannel" class="headerlink" title="8.3. FileChannel"></a>8.3. FileChannel</h4><p><strong>FileChannel</strong> 是一个用于文件读写、映射和操作的通道，同时它在并发环境下是线程安全的，基于 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 <code>getChannel()</code> 方法可以创建并打开一个文件通道。FileChannel 定义了 <code>transferFrom()</code> 和 <code>transferTo()</code> 两个抽象方法，它通过在通道和通道之间建立连接实现数据传输的。</p><ul><li><strong>transferTo() ：</strong>通过 FileChannel 把文件里面的源数据写入一个 WritableByteChannel 的目的通道。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">long</span> <span class="token function">transferTo</span><span class="token punctuation">(</span><span class="token keyword">long</span> position<span class="token punctuation">,</span> <span class="token keyword">long</span> count<span class="token punctuation">,</span> WritableByteChannel target<span class="token punctuation">)</span>        <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span></code></pre><ul><li><strong>transferFrom() ：</strong>把一个源通道 ReadableByteChannel 中的数据读取到当前 FileChannel 的文件里面。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">long</span> <span class="token function">transferFrom</span><span class="token punctuation">(</span>ReadableByteChannel src<span class="token punctuation">,</span> <span class="token keyword">long</span> position<span class="token punctuation">,</span> <span class="token keyword">long</span> count<span class="token punctuation">)</span>        <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span></code></pre><p>下面给出 FileChannel 利用 <code>transferTo()</code> 和 <code>transferFrom()</code> 方法进行数据传输的使用示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String CONTENT <span class="token operator">=</span> <span class="token string">"Zero copy implemented by FileChannel"</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String SOURCE_FILE <span class="token operator">=</span> <span class="token string">"/source.txt"</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String TARGET_FILE <span class="token operator">=</span> <span class="token string">"/target.txt"</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String CHARSET <span class="token operator">=</span> <span class="token string">"UTF-8"</span><span class="token punctuation">;</span></code></pre><p>首先在类加载根路径下创建 <code>source.txt</code> 和 <code>target.txt</code> 两个文件，对源文件 <code>source.txt</code> 文件写入初始化数据。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Before</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Path source <span class="token operator">=</span> Paths<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token function">getClassPath</span><span class="token punctuation">(</span>SOURCE_FILE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> CONTENT<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>Charset<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>CHARSET<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">(</span>FileChannel fromChannel <span class="token operator">=</span> FileChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> StandardOpenOption<span class="token punctuation">.</span>READ<span class="token punctuation">,</span>            StandardOpenOption<span class="token punctuation">.</span>WRITE<span class="token punctuation">,</span> StandardOpenOption<span class="token punctuation">.</span>TRUNCATE_EXISTING<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        fromChannel<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>ByteBuffer<span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>对于 <code>transferTo()</code> 方法而言，目的通道 toChannel 可以是任意的单向字节写通道 <strong>WritableByteChannel</strong> ；而对于 <code>transferFrom()</code> 方法而言，源通道 fromChannel 可以是任意的单向字节读通道 <strong>ReadableByteChannel</strong> 。</p><p>其中，<strong>FileChannel</strong> 、<strong>SocketChannel</strong> 和 <strong>DatagramChannel</strong> 等通道实现了 WritableByteChannel 和 ReadableByteChannel 接口，都是同时支持读写的双向通道。为了方便测试，下面给出基于 FileChannel 完成 channel-to-channel 的数据传输示例。</p><ul><li>通过 <code>transferTo()</code> 将 fromChannel 中的数据拷贝到 toChannel ：</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transferTo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">(</span>FileChannel fromChannel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RandomAccessFile</span><span class="token punctuation">(</span>             <span class="token function">getClassPath</span><span class="token punctuation">(</span>SOURCE_FILE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"rw"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         FileChannel toChannel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RandomAccessFile</span><span class="token punctuation">(</span>             <span class="token function">getClassPath</span><span class="token punctuation">(</span>TARGET_FILE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"rw"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> position <span class="token operator">=</span> 0L<span class="token punctuation">;</span>        <span class="token keyword">long</span> offset <span class="token operator">=</span> fromChannel<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        fromChannel<span class="token punctuation">.</span><span class="token function">transferTo</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> toChannel<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>通过 <code>transferFrom()</code> 将 fromChannel 中的数据拷贝到 toChannel ：</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transferFrom</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">(</span>FileChannel fromChannel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RandomAccessFile</span><span class="token punctuation">(</span>             <span class="token function">getClassPath</span><span class="token punctuation">(</span>SOURCE_FILE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"rw"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         FileChannel toChannel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RandomAccessFile</span><span class="token punctuation">(</span>             <span class="token function">getClassPath</span><span class="token punctuation">(</span>TARGET_FILE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"rw"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> position <span class="token operator">=</span> 0L<span class="token punctuation">;</span>        <span class="token keyword">long</span> offset <span class="token operator">=</span> fromChannel<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        toChannel<span class="token punctuation">.</span><span class="token function">transferFrom</span><span class="token punctuation">(</span>fromChannel<span class="token punctuation">,</span> position<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>下面介绍 <code>transferTo()</code> 和 <code>transferFrom()</code> 方法的底层实现原理，这两个方法也是 <code>java.nio.channels.FileChannel</code> 的抽象方法，由子类 <code>sun.nio.ch.FileChannelImpl.java</code> 实现。</p><p><code>transferTo()</code> 和 <code>transferFrom()</code> 底层都是基于 <code>sendfile</code> 实现数据传输的，其中 <code>FileChannelImpl.java</code> 定义了 3 个常量，用于标示当前操作系统的内核是否支持 <code>sendfile</code> 以及 <code>sendfile</code> 的相关特性。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> transferSupported <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> pipeSupported <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> fileSupported <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></code></pre><ul><li><strong>transferSupported ：</strong>用于标记当前的系统内核是否支持 <code>sendfile()</code> 调用，默认为 true 。</li><li><strong>pipeSupported ：</strong>用于标记当前的系统内核是否支持文件描述符（fd）基于管道（pipe）的 <code>sendfile()</code> 调用，默认为 true 。</li><li><strong>fileSupported ：</strong>用于标记当前的系统内核是否支持文件描述符（fd）基于文件（file）的 <code>sendfile()</code> 调用，默认为 true 。</li></ul><p>下面以 <code>transferTo()</code> 的源码实现为例。FileChannelImpl 首先执行 <code>transferToDirectly()</code> 方法，以 <code>sendfile</code> 的零拷贝方式尝试数据拷贝。如果系统内核不支持 <code>sendfile</code> ，进一步执行 <code>transferToTrustedChannel()</code> 方法，以 <code>mmap</code> 的零拷贝方式进行内存映射，这种情况下目的通道必须是 FileChannelImpl 或者 SelChImpl 类型。如果以上两步都失败了，则执行 <code>transferToArbitraryChannel()</code> 方法，基于传统的 I/O 方式完成读写，具体步骤是初始化一个临时的 DirectBuffer，将源通道 FileChannel 的数据读取到 DirectBuffer ，再写入目的通道 WritableByteChannel 里面。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">transferTo</span><span class="token punctuation">(</span><span class="token keyword">long</span> position<span class="token punctuation">,</span> <span class="token keyword">long</span> count<span class="token punctuation">,</span> WritableByteChannel target<span class="token punctuation">)</span>        <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 计算文件的大小</span>    <span class="token keyword">long</span> sz <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 校验起始位置</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">></span> sz<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> icount <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 校验偏移量</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sz <span class="token operator">-</span> position<span class="token punctuation">)</span> <span class="token operator">&lt;</span> icount<span class="token punctuation">)</span>        icount <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>sz <span class="token operator">-</span> position<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> n<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">transferToDirectly</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> icount<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> n<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">transferToTrustedChannel</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> icount<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> n<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">transferToArbitraryChannel</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> icount<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>接下来重点分析一下 <code>transferToDirectly()</code> 方法的实现，也就是 <code>transferTo()</code> 通过 <code>sendfile</code> 实现零拷贝的精髓所在。可以看到，<code>transferToDirectlyInternal()</code> 方法先获取到目的通道 WritableByteChannel 的文件描述符 <strong>targetFD</strong> ，获取同步锁然后执行 <code>transferToDirectlyInternal()</code> 方法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">long</span> <span class="token function">transferToDirectly</span><span class="token punctuation">(</span><span class="token keyword">long</span> position<span class="token punctuation">,</span> <span class="token keyword">int</span> icount<span class="token punctuation">,</span> WritableByteChannel target<span class="token punctuation">)</span>        <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 省略从target获取targetFD的过程</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nd<span class="token punctuation">.</span><span class="token function">transferToDirectlyNeedsPositionLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>positionLock<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">long</span> pos <span class="token operator">=</span> <span class="token function">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token function">transferToDirectlyInternal</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> icount<span class="token punctuation">,</span>                        target<span class="token punctuation">,</span> targetFD<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                <span class="token function">position</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">transferToDirectlyInternal</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> icount<span class="token punctuation">,</span> target<span class="token punctuation">,</span> targetFD<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最终由 <code>transferToDirectlyInternal()</code> 调用本地方法 <code>transferTo0()</code> ，尝试以 <code>sendfile</code> 的方式进行数据传输。如果系统内核完全不支持 <code>sendfile</code>，比如 Windows 操作系统，则返回 <strong>UNSUPPORTED</strong> 并把 <code>transferSupported</code> 标识为 <strong>false</strong> 。如果系统内核不支持 <code>sendfile</code> 的一些特性，比如说低版本的 Linux 内核不支持 <code>DMA gather copy</code> 操作，则返回 <strong>UNSUPPORTED_CASE</strong> 并把 <code>pipeSupported</code> 或者 <code>fileSupported</code> 标识为 <strong>false</strong> 。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">long</span> <span class="token function">transferToDirectlyInternal</span><span class="token punctuation">(</span><span class="token keyword">long</span> position<span class="token punctuation">,</span> <span class="token keyword">int</span> icount<span class="token punctuation">,</span>                                        WritableByteChannel target<span class="token punctuation">,</span>                                        FileDescriptor targetFD<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token keyword">assert</span> <span class="token operator">!</span>nd<span class="token punctuation">.</span><span class="token function">transferToDirectlyNeedsPositionLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span>            Thread<span class="token punctuation">.</span><span class="token function">holdsLock</span><span class="token punctuation">(</span>positionLock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> n <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ti <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ti <span class="token operator">=</span> threads<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            n <span class="token operator">=</span> <span class="token function">transferTo0</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> position<span class="token punctuation">,</span> icount<span class="token punctuation">,</span> targetFD<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">==</span> IOStatus<span class="token punctuation">.</span>INTERRUPTED<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> IOStatus<span class="token punctuation">.</span>UNSUPPORTED_CASE<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token keyword">instanceof</span> <span class="token class-name">SinkChannelImpl</span><span class="token punctuation">)</span>                pipeSupported <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token keyword">instanceof</span> <span class="token class-name">FileChannelImpl</span><span class="token punctuation">)</span>                fileSupported <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> IOStatus<span class="token punctuation">.</span>UNSUPPORTED_CASE<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> IOStatus<span class="token punctuation">.</span>UNSUPPORTED<span class="token punctuation">)</span> <span class="token punctuation">{</span>            transferSupported <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> IOStatus<span class="token punctuation">.</span>UNSUPPORTED<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> IOStatus<span class="token punctuation">.</span><span class="token function">normalize</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        threads<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>ti<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">end</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>本地方法（native method）<code>transferTo0()</code> 通过 JNI（Java Native Interface）调用底层 C 的函数，这个 native 函数（Java_sun_nio_ch_FileChannelImpl_transferTo0）同样位于 JDK 源码包下的  native/sun/nio/ch/FileChannelImpl.c 源文件里面。JNI 函数 Java_sun_nio_ch_FileChannelImpl_transferTo0() 基于条件编译对不同的系统进行预编译，下面是 JDK 基于 Linux 系统内核对 <code>transferTo()</code> 提供的调用封装。</p><pre class=" language-java"><code class="language-java">#<span class="token keyword">if</span> <span class="token function">defined</span><span class="token punctuation">(</span>__linux__<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">defined</span><span class="token punctuation">(</span>__solaris__<span class="token punctuation">)</span>#include <span class="token operator">&lt;</span>sys<span class="token operator">/</span>sendfile<span class="token punctuation">.</span>h<span class="token operator">></span>#elif <span class="token function">defined</span><span class="token punctuation">(</span>_AIX<span class="token punctuation">)</span>#include <span class="token operator">&lt;</span>sys<span class="token operator">/</span>socket<span class="token punctuation">.</span>h<span class="token operator">></span>#elif <span class="token function">defined</span><span class="token punctuation">(</span>_ALLBSD_SOURCE<span class="token punctuation">)</span>#include <span class="token operator">&lt;</span>sys<span class="token operator">/</span>types<span class="token punctuation">.</span>h<span class="token operator">></span>#include <span class="token operator">&lt;</span>sys<span class="token operator">/</span>socket<span class="token punctuation">.</span>h<span class="token operator">></span>#include <span class="token operator">&lt;</span>sys<span class="token operator">/</span>uio<span class="token punctuation">.</span>h<span class="token operator">></span>#define lseek64 lseek#define mmap64 mmap#endifJNIEXPORT jlong JNICALL<span class="token function">Java_sun_nio_ch_FileChannelImpl_transferTo0</span><span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span>env<span class="token punctuation">,</span> jobject <span class="token keyword">this</span><span class="token punctuation">,</span>                                            jobject srcFDO<span class="token punctuation">,</span>                                            jlong position<span class="token punctuation">,</span> jlong count<span class="token punctuation">,</span>                                            jobject dstFDO<span class="token punctuation">)</span><span class="token punctuation">{</span>    jint srcFD <span class="token operator">=</span> <span class="token function">fdval</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> srcFDO<span class="token punctuation">)</span><span class="token punctuation">;</span>    jint dstFD <span class="token operator">=</span> <span class="token function">fdval</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> dstFDO<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> <span class="token function">defined</span><span class="token punctuation">(</span>__linux__<span class="token punctuation">)</span>    off64_t offset <span class="token operator">=</span> <span class="token punctuation">(</span>off64_t<span class="token punctuation">)</span>position<span class="token punctuation">;</span>    jlong n <span class="token operator">=</span> <span class="token function">sendfile64</span><span class="token punctuation">(</span>dstFD<span class="token punctuation">,</span> srcFD<span class="token punctuation">,</span> <span class="token operator">&amp;</span>offset<span class="token punctuation">,</span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> n<span class="token punctuation">;</span>#elif <span class="token function">defined</span><span class="token punctuation">(</span>__solaris__<span class="token punctuation">)</span>    result <span class="token operator">=</span> <span class="token function">sendfilev64</span><span class="token punctuation">(</span>dstFD<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sfv<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>numBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>#elif <span class="token function">defined</span><span class="token punctuation">(</span>__APPLE__<span class="token punctuation">)</span>    result <span class="token operator">=</span> <span class="token function">sendfile</span><span class="token punctuation">(</span>srcFD<span class="token punctuation">,</span> dstFD<span class="token punctuation">,</span> position<span class="token punctuation">,</span> <span class="token operator">&amp;</span>numBytes<span class="token punctuation">,</span> NULL<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>#endif<span class="token punctuation">}</span></code></pre><p>对 Linux、Solaris 以及 Apple 系统而言，<code>transferTo0()</code> 函数底层会执行 <code>sendfile64</code> 这个系统调用完成零拷贝操作，<code>sendfile64()</code> 函数的原型如下：</p><pre class=" language-java"><code class="language-java">#include <span class="token operator">&lt;</span>sys<span class="token operator">/</span>sendfile<span class="token punctuation">.</span>h<span class="token operator">></span>ssize_t <span class="token function">sendfile64</span><span class="token punctuation">(</span><span class="token keyword">int</span> out_fd<span class="token punctuation">,</span> <span class="token keyword">int</span> in_fd<span class="token punctuation">,</span> off_t <span class="token operator">*</span>offset<span class="token punctuation">,</span> size_t count<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>下面简单介绍一下 <code>sendfile64()</code> 函数各个参数的含义：</p><ul><li><strong>out_fd ：</strong>待写入的文件描述符。</li><li><strong>in_fd ：</strong>待读取的文件描述符。</li><li><strong>offset ：</strong>指定 <code>in_fd</code> 对应文件流的读取位置，如果为空，则默认从起始位置开始。</li><li><strong>count ：</strong>指定在文件描述符 <code>in_fd</code> 和 <code>out_fd</code> 之间传输的字节数。</li></ul><p>在 Linux 2.6.3 之前，<code>out_fd</code> 必须是一个 <strong>socket</strong> ，而从 Linux 2.6.3 以后，<code>out_fd</code> 可以是任何文件。也就是说，<code>sendfile64()</code> 函数不仅可以进行网络文件传输，还可以对本地文件实现零拷贝操作。</p><h3 id="9-其它的零拷贝实现"><a href="#9-其它的零拷贝实现" class="headerlink" title="9. 其它的零拷贝实现"></a>9. 其它的零拷贝实现</h3><h4 id="9-1-Netty-零拷贝"><a href="#9-1-Netty-零拷贝" class="headerlink" title="9.1. Netty 零拷贝"></a>9.1. Netty 零拷贝</h4><p>Netty 中的零拷贝和上面提到的操作系统层面上的零拷贝不太一样, 我们所说的 Netty 零拷贝完全是基于（Java 层面）用户态的，它的更多的是偏向于数据操作优化这样的概念，具体表现在以下几个方面：</p><ul><li>Netty 通过 <strong>DefaultFileRegion</strong> 类对 java.nio.channels.FileChannel 的 <code>tranferTo()</code> 方法进行包装，在文件传输时可以将文件缓冲区的数据直接发送到目的通道（Channel）。</li><li>ByteBuf 可以通过 <code>wrap</code> 操作把字节数组、ByteBuf、ByteBuffer 包装成一个 <strong>ByteBuf</strong> 对象, 进而避免了拷贝操作。</li><li>ByteBuf 支持 <code>slice</code> 操作，因此可以将 ByteBuf 分解为多个共享同一个存储区域的 ByteBuf ，避免了内存的拷贝。</li><li>Netty 提供了 <strong>CompositeByteBuf</strong> 类，它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf ，避免了各个 ByteBuf 之间的拷贝。</li></ul><p>其中第 1 条属于操作<strong>系统层面</strong>的零拷贝操作，后面 3 条只能算<strong>用户层面</strong>的数据操作优化。</p><h4 id="9-2-RocketMQ-和-Kafka-对比"><a href="#9-2-RocketMQ-和-Kafka-对比" class="headerlink" title="9.2. RocketMQ 和 Kafka 对比"></a>9.2. RocketMQ 和 Kafka 对比</h4><p>RocketMQ 选择了 <code>mmap + write</code> 这种零拷贝方式，适用于业务级消息这种<strong>小块文件</strong>的数据持久化和传输；而 Kafka 采用的是 <code>sendfile</code> 这种零拷贝方式，适用于系统日志消息这种<strong>高吞吐量的大块文件</strong>的数据持久化和传输。但是值得注意的一点是，Kafka 的索引文件使用的是 <code>mmap + write</code> 方式，数据文件使用的是 <code>sendfile</code> 方式。</p><table><thead><tr><th>消息队列</th><th>零拷贝方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>RocketMQ</td><td>mmap + write</td><td>适用于小块文件传输，频繁调用时，效率很高。</td><td>不能很好的利用 DMA 方式，会比 sendfile 多消耗 CPU，内存安全性控制复杂，需要避免 JVM Crash 问题。</td></tr><tr><td>Kafka</td><td>sendfile</td><td>可以利用 DMA 方式，消耗 CPU 较少，大块文件传输效率高，无内存安全性问题。</td><td>小块文件效率低于 mmap 方式，只能是 BIO 方式传输，不能使用 NIO 方式。</td></tr></tbody></table><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文开篇详述了 Linux 操作系统中的<strong>物理内存</strong>和<strong>虚拟内存</strong>，<strong>内核空间</strong>和<strong>用户空间</strong>的概念以及 <strong>Linux 的内部层级结构</strong>。在此基础上，进一步分析和对比传统 I/O 方式和零拷贝方式的区别，然后介绍了 Linux 内核提供的几种<strong>零拷贝</strong>实现，包括内存映射 <code>mmap</code> 、<code>sendfile</code> 、<code>sendfile + DMA gather copy</code> 以及 <code>splice</code> 几种机制，并从系统调用和拷贝次数层面对它们进行了对比。接下来从源码着手分析了 Java NIO 对零拷贝的实现，主要包括基于内存映射（mmap）方式的 <strong>MappedByteBuffer</strong> 以及基于 sendfile 方式的 <strong>FileChannel</strong> 。最后在篇末简单的阐述了一下 Netty 中的零拷贝机制，以及 RocketMQ 和 Kafka 两种消息队列在零拷贝实现方式上的区别。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux IO </tag>
            
            <tag> 零拷贝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS</title>
      <link href="/2020/05/07/408/ji-suan-ji-wang-luo/https/"/>
      <url>/2020/05/07/408/ji-suan-ji-wang-luo/https/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>每篇文章都希望你能收获到东西，这篇将带你<strong>深入 HTTPS 加解密原理</strong>，希望看完能够有这些收获：</p><ul><li>明白 HTTPS 到底解决了什么问题</li><li>理解对称加密与非对称加密的原理和使用场景</li><li>明白 CA 机构和根证书到底起了什么作用</li></ul><h2 id="Why-HTTPS-？"><a href="#Why-HTTPS-？" class="headerlink" title="Why HTTPS ？"></a>Why HTTPS ？</h2><blockquote><p>近几年来，各大公司都在大力推进 HTTPS 的建设。Google Chrome 将非 HTTPS 的网站标注为「不安全」，苹果要求 APP 中需要使用 HTTPS 进行通信，微信小程序也要求使用 HTTPS 协议。那么，我们为什么非要做这么一件事呢？</p></blockquote><p>我们先来看看 HTTP 。HTTP（Hypertext Transfer Protocol）超文本传输协议，是一种用于分布式、协作式和超媒体信息系统的应用层协议，可以说 HTTP 是当代互联网通信的基础。</p><p>但是，HTTP 有着一个致命的缺陷，那就是内容是<strong>明文传输</strong>的，没有经过任何加密，而这些明文数据会经过 <strong>WiFi 、路由器、运营商、机房</strong>等多个物理设备节点，如果在这中间任意一个节点被监听，传输的内容就会完全暴露，这一攻击手法叫做 MITM（Man In The Middle）<strong>中间人</strong>攻击。</p><p><img src="https://s1.ax1x.com/2020/05/06/YVNE8J.png" alt=""></p><p><strong>举个例子，稍微有点长，但这个例子透露出了我对安全如此痴迷的原因😝~~</strong></p><hr><p>可以拿小时候上课传纸条来类比，你坐在教室靠墙的一边，想要传一句<strong>「晚上放学操场我等你」</strong>给坐在窗边的小红，中间要经过六七个人的传递。虽然你把纸条对折了一下，但是防君子不防小人，中间的所有人都可以很轻易地打开纸条看到你想要说什么。</p><p>只是看还好，如果有小刚也喜欢小红，看到你俩马上就要甜甜蜜蜜地回家了，心有不甘，换了一张纸条，改成了<strong>「晚上放学你自己回家吧，我要去网吧玩游戏」</strong>。</p><p>小红看到你要抛弃她自己去玩游戏，非常伤心，开始在纸条上质问<strong>「说好的一起回家呢，为什么要去打游戏，哼」</strong>。</p><p>在小红的纸条传回来的路上，小刚又改了纸条<strong>「你玩你的游戏去吧，我要和小刚回家」</strong>。</p><p>于是，你和小红都倍感伤心，小刚横刀夺爱，而你一头雾水。</p><hr><p>回忆一下几年前遍地都是的<strong>运营商劫持</strong>，当你访问一个本来很正常的网页，但页面上却莫名其妙出现了一些广告标签、跳转脚本、欺骗性的红包按钮，甚至有时候本来要下载一个文件，最后下下来却变成了另外一个完全不同的东西，这些都是被运营商劫持了 HTTP 明文数据的现象。</p><p><img src="https://s1.ax1x.com/2020/05/06/YVNfaT.png" alt="运营商劫持"></p><p>还有各大公司的员工<strong>安全培训</strong>里都有一条「不要连陌生的 WiFi 」，也是类似的原因，恶意 WiFi 的控制者可以看到和篡改 HTTP 明文传输的信息。</p><p>为了解决 HTTP 明文传输数据可能导致的安全问题，1994 年网景公司提出了 HTTPS（HyperText Transfer Protocol Secure）超文本传输安全协议，数据通信仍然是 HTTP ，但利用 <strong>SSL/TLS</strong> 加密数据包。</p><h2 id="HTTPS-实现原理"><a href="#HTTPS-实现原理" class="headerlink" title="HTTPS 实现原理"></a>HTTPS 实现原理</h2><blockquote><p>前面说到，HTTPS 其实就是将 HTTP 的数据包再通过 SSL/TLS 加密后传输，那么 SSL/TLS 又是什么呢？</p></blockquote><p>SSL（Secure Sockets Layer）安全套接层和 TLS（Transport Layer Security）传输层安全协议其实是<strong>一套东西</strong>。</p><p>网景公司在 1994 年提出 HTTPS 协议时，使用的是 SSL 进行加密。后来 IETF（Internet Engineering Task Force）互联网工程任务组将 SSL 进一步标准化，于 1999 年公布第一版 TLS 协议文件 TLS 1.0 。目前最新版的 TLS 协议是 TLS 1.3 ，于 2018 年公布。</p><h3 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h3><p>SSL 协议位于传输层与应用层之间，为数据通讯提供安全支持。应用层数据不再直接传递给传输层，而是传递给 SSL 层，SSL 层对从应用层收到的数据进行加密，并增加自己的 SSL 头。SSL 协议可分为两层：</p><ul><li><strong>SSL 握手协议（SSL Handshake Protocol）：</strong>它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行<strong>身份认证、协商加密算法、交换加密密钥</strong>等。</li><li><strong>SSL 记录协议（SSL Record Protocol）：</strong>它建立在可靠的传输协议（如 TCP ）之上，为高层协议提供<strong>数据封装、压缩、加密</strong>等基本功能的支持。</li></ul><p><img src="https://s1.ax1x.com/2020/05/07/YVwEo6.png" alt="SSL"></p><h4 id="握手协议"><a href="#握手协议" class="headerlink" title="握手协议"></a>握手协议</h4><p>握手协议是客户机和服务器用 SSL 连接通信时使用的<strong>第一个</strong>子协议，握手协议包括客户机与服务器之间的一系列消息。SSL 中最复杂的协议就是握手协议。该协议允许服务器和客户机相互验证，协商加密和 MAC（Message Authentication Codes）算法以及保密密钥，用来保护在 SSL 记录中发送的数据。握手协议是在应用程序的数据传输之前使用的。</p><p>每个握手协议包含以下 3 个字段：</p><ul><li><strong>Type ：</strong>表示 10 种消息类型之一。</li><li><strong>Length ：</strong>表示消息长度字节数。</li><li><strong>Content ：</strong>与消息相关的参数。</li></ul><h4 id="记录协议"><a href="#记录协议" class="headerlink" title="记录协议"></a>记录协议</h4><p>记录协议在客户机和服务器握手成功后使用，即客户机和服务器鉴别对方和确定安全信息交换使用的算法后，进入 SSL 记录协议，记录协议向 SSL 连接提供两个服务：</p><ul><li><strong>保密性：</strong>使用握手协议定义的秘密密钥实现。</li><li><strong>完整性：</strong>握手协议定义了 MAC ，用于保证消息完整性。</li></ul><p><strong>发送方的工作过程为：</strong></p><ul><li>从上层接受要发送的数据（包括各种消息和数据）；</li><li>对信息进行分段，分成若干纪录；</li><li>使用指定的压缩算法进行数据压缩（可选）；</li><li>使用指定的 MAC 算法生成 MAC ；</li><li>使用指定的加密算法进行数据加密；</li><li>添加 SSL 记录协议的头，发送数据。</li></ul><p><strong>接收方的工作过程为：</strong></p><ul><li>接收数据，从 SSL 记录协议的头中获取相关信息；</li><li>使用指定的解密算法解密数据；</li><li>使用指定的 MAC 算法校验 MAC ；</li><li>使用压缩算法对数据解压缩（在需要进行）；</li><li>将记录进行数据重组；</li><li>将数据发送给高层。</li></ul><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>我们先来看看 HTTPS 的加解密流程。</p><p><img src="https://s1.ax1x.com/2020/05/06/YVUW6A.png" alt="HTTPS 加解密流程"><strong>HTTPS 加解密流程：</strong></p><ol><li>用户在浏览器发起 HTTPS 请求（如 <a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a> ），默认使用服务端的 <strong>443</strong> 端口进行连接；</li><li>HTTPS 需要使用一套 <strong>CA 数字证书</strong>，证书内会附带一个<strong>公钥 Pub</strong> ，而与之对应的<strong>私钥 Private</strong> 保留在服务端不公开；</li><li>服务端收到请求，返回配置好的包含<strong>公钥 Pub</strong> 的证书给客户端；</li><li>客户端收到<strong>证书</strong>，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示 HTTPS 警告信息，如果通过则继续；</li><li>客户端生成一个用于对称加密的<strong>随机 Key</strong> ，并用证书内的<strong>公钥 Pub</strong> 进行加密，发送给服务端；</li><li>服务端收到<strong>随机 Key</strong> 的密文，使用与<strong>公钥 Pub</strong> 配对的<strong>私钥 Private</strong> 进行解密，得到客户端真正想发送的<strong>随机 Key</strong> ；</li><li>服务端使用客户端发送过来的<strong>随机 Key</strong> 对要传输的 HTTP 数据进行对称加密，将密文返回客户端；</li><li>客户端使用<strong>随机 Key</strong> 对称解密密文，得到 HTTP 数据明文；</li><li>后续 HTTPS 请求使用之前交换好的<strong>随机 Key</strong> 进行对称加解密。</li></ol><p><img src="https://s1.ax1x.com/2020/05/07/YVDEoq.png" alt=""></p><h3 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h3><blockquote><p>又是对称加密又是非对称加密，一会公钥一会私钥一会随机 Key ，为什么要这么复杂呢，一套搞到底不好么？</p></blockquote><p>对称加密是指有一个密钥，用它可以对一段明文加密，加密之后也只能用这个密钥来解密得到明文。如果通信双方都持有密钥，且天知地知你知我知，绝对不会有别的人知道，那么通信安全自然是可以得到保证的（在<strong>密钥足够强</strong>的情况下）。</p><p>然而，在 HTTPS 的传输场景下，服务端事先并不知道客户端是谁，你也<strong>不可能在事先不通过互联网和每一个网站的管理员都悄悄商量好一个通信密钥</strong>出来，那么必然存在一个密钥在互联网上传输的过程，如果在传输过程中被别人监听到了，那么后续的所有加密都是无用功。</p><p>这时，我们就需要另一种神奇的加密类型，非对称加密。</p><p>非对称加密有两个密钥，一个是公钥，另一个是私钥。一般来说，公钥用来加密，这时密文只能用私钥才能解开。</p><p>那么，当客户端发起连接请求，服务端将公钥传输过去，客户端利用公钥加密好信息，再将密文发送给服务端，服务端里有私钥可以解密。</p><p>但是，当服务端要返回数据，如果用公钥加密，那么客户端并没有私钥用来解密，而如果用私钥加密，客户端虽然有公钥可以解密，但这个公钥之前就在<strong>互联网上传输过</strong>，很有可能已经有人拿到，并不安全，所以这一过程只用非对称加密是不能满足的。</p><blockquote><p>注意，严格来讲，私钥并不能用来加密，只能用作签名使用，这是由于密码学中生成公钥私钥时对不同变量的数学要求是不同的，因此公钥私钥抵抗攻击的能力也不同，在实际使用中不可互换。签名的功能在 HTTPS 里也有用到，下文中会说明。</p></blockquote><p>只有一组公钥私钥只能保证单程的加解密，那么如果我们准备<strong>两组公钥私钥</strong>呢，是不是可以解决这个问题？来看下面这个过程。</p><ol><li>服务端有非对称加密的公钥 A1 ，私钥 A2 ；</li><li>客户端有非对称加密的公钥 B1 ，私钥 B2 ；</li><li>客户端向服务端发起请求，服务端将公钥 A1 返回给客户端；</li><li>浏览器收到公钥 A1 ，将自己保存的公钥 B1 发送给服务端；</li><li>之后浏览器所有向客户端发送的数据，使用公钥 B1 加密，客户端可以使用私钥 B2 解密；</li><li>客户端所有向服务端发送的数据，使用公钥 A1 加密，服务端可以使用私钥 A2 解密。</li></ol><p>此时，两条传输方向的数据都经过非对称加密，都能保证安全性，那么为什么不采用这种方案呢？</p><p><img src="https://s1.ax1x.com/2020/05/07/YVrTDH.png" alt=""></p><p>最主要的原因是<strong>非对称加解密耗时要远大于对称加解密</strong>，对性能有很大损耗，大家的使用体验很差。</p><p>所以，我们才最终选用了上文介绍到<strong>非对称加密+对称加密</strong>的方案，再复习一下↓↓↓😝</p><ol><li>服务端有非对称加密的公钥 A1 ，私钥 A2 ；</li><li>客户端发起请求，服务端将公钥 A1 返回给客户端；</li><li>客户端随机生成一个对称加密的密钥 K ，用公钥 A1 加密后发送给服务端；</li><li>服务端收到密文后用自己的私钥 A2 解密，得到对称密钥 K ，此时完成了安全的对称密钥交换，解决了对称加密时密钥传输被人窃取的问题；</li><li>之后双方通信都使用密钥 K 进行对称加解密。</li></ol><p>看起来是一个非常完美的方案，<strong>兼顾</strong>了安全性和性能，但是，真的就安全了么？</p><h3 id="CA-颁发机构"><a href="#CA-颁发机构" class="headerlink" title="CA 颁发机构"></a>CA 颁发机构</h3><p>依然考虑<strong>中间人攻击</strong>的情况，非对称加密的算法都是<strong>公开</strong>的，所有人都可以自己生成一对公钥私钥。</p><p>当服务端向客户端返回公钥 A1 的时候，中间人将其<strong>替换</strong>成自己的公钥 B1 传送给浏览器。</p><p>而浏览器此时一无所知，傻乎乎地使用公钥 B1 加密了密钥 K 发送出去，又被<strong>中间人截获</strong>，中间人利用自己的私钥 B2 解密，得到密钥 K ，再使用服务端的公钥 A1 加密传送给服务端，完成了通信链路，而服务端和客户端毫无感知。</p><p><img src="https://s1.ax1x.com/2020/05/07/YVrxxS.png" alt="HTTPS 中间人"></p><p>出现这一问题的核心原因是<strong>客户端无法确认收到的公钥是不是真的是服务端发来的</strong>。为了解决这个问题，互联网引入了一个公信机构，这就是 CA 。</p><p>服务端在使用 HTTPS 前，去经过认证的 CA 机构申请颁发一份<strong>数字证书</strong>，数字证书里包含有证书持有者、证书有效期、公钥等信息，服务端将证书发送给客户端，客户端校验证书身份和要访问的网站身份确实一致后再进行后续的加密操作。</p><p>但是，如果中间人也聪明一点，<strong>只改动了证书中的公钥部分</strong>，客户端依然不能确认证书<strong>是否被篡改</strong>，这时我们就需要一些防伪技术了。</p><p>前面说过，非对称加密中一般公钥用来加密，私钥用来解密，虽然私钥加密理论上可行，但由于数学上的设计这么做并不适合，那么私钥就只有解密这个功能了么？</p><p>私钥除了解密外的真正用途其实还有一个，就是<strong>数字签名</strong>，其实就是一种防伪技术，只要有人篡改了证书，那么数字签名必然校验失败。具体过程如下：</p><ol><li>CA 机构拥有自己的一对公钥和私钥；</li><li>CA 机构在颁发证书时对证书明文信息进行哈希；</li><li>将哈希值用私钥进行<strong>加签</strong>，得到数字签名。</li></ol><p><strong>明文数据和数字签名组成证书，传递给客户端。</strong></p><ol><li>客户端得到证书，分解成明文部分 <code>Text</code> 和数字签名 <code>Sig1</code> ；</li><li>用 CA 机构的公钥进行<strong>解签</strong>，得到 <code>Sig2</code>（由于 CA 机构是一种公信身份，因此在系统或浏览器中会内置 CA 机构的证书和公钥信息）；</li><li>用证书里声明的哈希算法对明文 <code>Text</code> 部分进行哈希得到 H ；</li><li>当自己计算得到的哈希值 T 与<strong>解签</strong>后的 <code>Sig2</code> <strong>相等</strong>，表示证书可信，<strong>没有被篡改</strong>。</li></ol><p><img src="https://s1.ax1x.com/2020/05/07/YVy4ne.png" alt=""></p><p>这时，签名是由 CA 机构的私钥生成的，中间人篡改信息后无法拿到 CA 机构的私钥，保证了证书可信。</p><blockquote><p>注意，这里有一个比较<strong>难以理解</strong>的地方，非对称加密的签名过程是，私钥将一段消息进行加签，然后将签名部分和消息本身一起发送给对方，收到消息后对签名部分利用公钥验签，如果验签出来的内容和消息本身一致，表明消息没有被篡改。</p></blockquote><p>在这个过程中，系统或浏览器中内置的 CA 机构的证书和公钥成为了至关重要的环节，这也是 CA 机构公信身份的证明，如果系统或浏览器中没有这个 CA 机构，那么客户端可以不接受服务端传回的证书，显示 HTTPS 警告。</p><p>实际上 CA 机构的证书是一条信任链，A 信任 B ，B 信任 C ，以<strong>掘金的证书</strong>为例，掘金向 RapidSSL 申请一张证书，而 RapidSSL 的 CA 身份是由 DigiCert Global 根 CA 认证的，构成了一条信任链。</p><p>各级 CA 机构的私钥是绝对的私密信息，一旦 CA 机构的私钥泄露，其公信力就会一败涂地。之前就有过几次 <strong>CA 机构私钥泄露</strong>，引发信任危机，各大系统和浏览器只能纷纷吊销内置的对应 CA 的根证书。</p><p>有些老旧的网站会要求使用前下载安装他自己的根证书，这就是这个网站使用的证书并不能在系统内置的 CA 机构和根证书之间形成一条信任链，需要自己安装根证书来构成信任链，这里的风险就要<strong>使用者自己承担</strong>了。</p><p><img src="https://s1.ax1x.com/2020/05/07/YVs0II.png" alt="证书明细"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HTTPS 的出发点是<strong>解决 HTTP 明文传输时信息被篡改和监听的问题</strong>。</p><ul><li>为了兼顾性能和安全性，使用了<strong>非对称加密+对称加密</strong>的方案。</li><li>为了保证公钥传输中不被篡改，又使用了<strong>非对称加密的数字签名</strong>功能，借助 CA 机构和系统根证书的机制保证了 HTTPS 证书的公信力。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> HTTPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP</title>
      <link href="/2020/05/06/408/ji-suan-ji-wang-luo/http/"/>
      <url>/2020/05/06/408/ji-suan-ji-wang-luo/http/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="一-、基础概念"><a href="#一-、基础概念" class="headerlink" title="一 、基础概念"></a>一 、基础概念</h2><h3 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h3><p>URI 包含 <strong>URL</strong> 和 <strong>URN</strong> 。</p><p><img src="https://s1.ax1x.com/2020/05/06/YA8FsS.png" alt="URI"></p><h3 id="请求和响应报文"><a href="#请求和响应报文" class="headerlink" title="请求和响应报文"></a>请求和响应报文</h3><h4 id="1-请求报文"><a href="#1-请求报文" class="headerlink" title="1. 请求报文"></a>1. 请求报文</h4><p><img src="https://s1.ax1x.com/2020/05/06/YA8nGq.png" alt="请求报文"></p><h4 id="2-响应报文"><a href="#2-响应报文" class="headerlink" title="2. 响应报文"></a>2. 响应报文</h4><p><img src="https://s1.ax1x.com/2020/05/06/YA8NJ1.png" alt="响应报文"></p><h2 id="二、HTTP-方法"><a href="#二、HTTP-方法" class="headerlink" title="二、HTTP 方法"></a>二、HTTP 方法</h2><p>客户端发送的 <strong>请求报文</strong> 第一行为请求行，包含了方法字段。</p><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><blockquote><p>获取资源</p></blockquote><p>当前网络请求中，绝大部分使用的是 GET 方法。</p><pre class=" language-html"><code class="language-html">GET /index.html HTTP/1.1Host: www.hackr.cn</code></pre><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><blockquote><p>获取报文首部</p></blockquote><p>和 GET 方法类似，但是不返回报文实体主体部分。主要用于确认 URL 的有效性以及资源更新的日期时间等。</p><pre class=" language-html"><code class="language-html">HEAD /index.html HTTP/1.1Host: www.hackr.cn</code></pre><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><blockquote><p>传输实体主体</p></blockquote><p>POST 主要用来传输数据，而 GET 主要用来获取资源。更多 POST 与 GET 的比较请见第九章。</p><pre class=" language-html"><code class="language-html">POST /index.html HTTP/1.1Host: www.hackr.cnContent-Length: 1560</code></pre><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><blockquote><p>上传文件</p></blockquote><p>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p><pre class=" language-html"><code class="language-html">PUT /new.html HTTP/1.1Host: www.example.comContent-type: text/htmlContent-length: 16</code></pre><h3 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h3><blockquote><p>对资源进行部分修改</p></blockquote><p>PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</p><pre class=" language-html"><code class="language-html">PATCH /file.txt HTTP/1.1Host: www.example.comContent-Type: application/exampleIf-Match: "e0023aa4e"Content-Length: 100</code></pre><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><blockquote><p>删除文件</p></blockquote><p>与 PUT 功能相反，并且同样不带验证机制。</p><pre class=" language-html"><code class="language-html">DELETE /file.html HTTP/1.1Host: www.hackr.cn</code></pre><h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><blockquote><p>查询支持的方法</p></blockquote><p>查询指定的 URL 能够支持的方法。会返回 <code>Allow: GET, POST, HEAD, OPTIONS</code> 这样的内容。</p><pre class=" language-html"><code class="language-html">OPTIONS * HTTP/1.1Host: www.hackr.cn</code></pre><h3 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h3><blockquote><p>要求在与代理服务器通信时建立隧道</p></blockquote><p>使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p><pre class=" language-html"><code class="language-html">CONNECT www.example.com:443 HTTP/1.1Host: www.example.com</code></pre><p><img src="https://s1.ax1x.com/2020/05/06/YAJRr8.jpg" alt=""></p><h3 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h3><blockquote><p>追踪路径</p></blockquote><p>服务器会将通信路径返回给客户端。</p><pre class=" language-html"><code class="language-html">TRACE / HTTP/1.1Host: hackr.cnMax-Forwards: 2</code></pre><p>发送请求时，在 <code>Max-Forwards</code> 首部字段中填入数值，每经过一个服务器就会减 1 ，当数值为 0 时就停止传输。</p><p>通常不会使用 TRACE ，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。</p><h2 id="三、HTTP-状态码"><a href="#三、HTTP-状态码" class="headerlink" title="三、HTTP 状态码"></a>三、HTTP 状态码</h2><p>服务器返回的 <strong>响应报文</strong> 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p><table><thead><tr><th align="center">状态码</th><th align="center">类别</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">1XX</td><td align="center">Informational（信息性状态码）</td><td align="center">接收的请求正在处理</td></tr><tr><td align="center">2XX</td><td align="center">Success（成功状态码）</td><td align="center">请求正常处理完毕</td></tr><tr><td align="center">3XX</td><td align="center">Redirection（重定向状态码）</td><td align="center">需要进行附加操作以完成请求</td></tr><tr><td align="center">4XX</td><td align="center">Client Error（客户端错误状态码）</td><td align="center">服务器无法处理请求</td></tr><tr><td align="center">5XX</td><td align="center">Server Error（服务器错误状态码）</td><td align="center">服务器处理请求出错</td></tr></tbody></table><h3 id="1XX-信息"><a href="#1XX-信息" class="headerlink" title="1XX 信息"></a>1XX 信息</h3><ul><li><strong>100 Continue ：</strong>表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li></ul><h3 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h3><ul><li><strong>200 OK ：</strong>表示从客户端发来的请求在服务器端被正常处理了。</li><li><strong>204 No Content ：</strong>代表服务器接收的请求已成功处理，但在返回的响应报文中不包含实体的主体部分。另外，也不允许返回任何实体的主体。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li><li><strong>206 Partial Content ：</strong>表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文包含由 <code>Content-Range</code> 指定范围的实体内容。</li></ul><h3 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h3><ul><li><p><strong>301 Moved Permanently ：</strong>永久性重定向。表示请求的资源已被分配了新的 URI ，以后应使用资源现在所指的 URI 。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 <code>Location</code> 首部字段提示的 URI 重新保存。</p></li><li><p><strong>302 Found ：</strong>临时性重定向。表示请求的资源已被分配了新的 URI ，<strong>希望</strong>用户（本次）能使用新的 URI 访问。</p></li><li><p><strong>303 See Other ：</strong>表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。和 302 有着相同的功能，但是 303 明确表示客户端应当采用 GET 方法获取资源。</p><blockquote><p>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法，并删除请求报文内的主体，之后请求会自动再次发送。</p></blockquote></li><li><p><strong>304 Not Modified ：</strong>如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果服务器端允许请求访问资源，但不满足条件，则服务器会返回 304 状态码。</p></li><li><p><strong>307 Temporary Redirect ：</strong>临时重定向。与 302 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET ，但实际使用时大家并不遵守。307 会遵照浏览器标准，不会从 POST 变成 GET 。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。</p></li></ul><h3 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h3><ul><li><strong>400 Bad Request ：</strong>请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 <strong>200</strong> OK 一样对待该状态码。</li><li><strong>401 Unauthorized ：</strong>该状态码表示发送的请求需要有 HTTP 认证信息（BASIC 认证、DIGEST 认证）。若之前已进行过一次请求，则表示用户认证失败。</li><li><strong>403 Forbidden ：</strong>表明对请求资源的访问被服务器拒绝了。未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因。</li><li><strong>404 Not Found ：</strong>表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</li></ul><h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h3><ul><li><p><strong>500 Internal Server Error ：</strong>表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。</p></li><li><p><strong>503 Service Unavailable ：</strong>表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 <code>RetryAfter</code> 首部字段再返回给客户端。</p><blockquote><p><strong>状态码和状况的不一致</strong></p><p>不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。比如 Web 应用程序内部发生错误，状态码依然返回 200 OK ，这种情况也经常遇到。</p></blockquote></li></ul><h2 id="四、HTTP-首部"><a href="#四、HTTP-首部" class="headerlink" title="四、HTTP 首部"></a>四、HTTP 首部</h2><p>有 4 种类型的首部字段：<strong>通用首部字段</strong>、<strong>请求首部字段</strong>、<strong>响应首部字段</strong>和<strong>实体首部字段</strong>。</p><p>各种首部字段及其含义如下（不需要全记，仅供查阅）：</p><h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Cache-Control</td><td align="center">控制缓存的行为</td></tr><tr><td align="center">Connection</td><td align="center">控制不再转发给代理的首部字段、管理持久连接</td></tr><tr><td align="center">Date</td><td align="center">创建报文的日期时间</td></tr><tr><td align="center">Pragma</td><td align="center">报文指令</td></tr><tr><td align="center">Trailer</td><td align="center">报文末端的首部一览</td></tr><tr><td align="center">Transfer-Encoding</td><td align="center">指定报文主体的传输编码方式</td></tr><tr><td align="center">Upgrade</td><td align="center">升级为其他协议</td></tr><tr><td align="center">Via</td><td align="center">代理服务器的相关信息</td></tr><tr><td align="center">Warning</td><td align="center">错误通知</td></tr></tbody></table><h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Accept</td><td align="center">用户代理可处理的媒体类型</td></tr><tr><td align="center">Accept-Charset</td><td align="center">优先的字符集</td></tr><tr><td align="center">Accept-Encoding</td><td align="center">优先的内容编码</td></tr><tr><td align="center">Accept-Language</td><td align="center">优先的语言（自然语言）</td></tr><tr><td align="center">Authorization</td><td align="center">Web 认证信息</td></tr><tr><td align="center">Expect</td><td align="center">期待服务器的特定行为</td></tr><tr><td align="center">From</td><td align="center">用户的电子邮箱地址</td></tr><tr><td align="center">Host</td><td align="center">请求资源所在服务器</td></tr><tr><td align="center">If-Match</td><td align="center">比较实体标记（ETag）</td></tr><tr><td align="center">If-Modified-Since</td><td align="center">比较资源的更新时间</td></tr><tr><td align="center">If-None-Match</td><td align="center">比较实体标记（与 If-Match 相反）</td></tr><tr><td align="center">If-Range</td><td align="center">资源未更新时发送实体 Byte 的范围请求</td></tr><tr><td align="center">If-Unmodified-Since</td><td align="center">比较资源的更新时间（与 If-Modified-Since 相反）</td></tr><tr><td align="center">Max-Forwards</td><td align="center">最大传输逐跳数</td></tr><tr><td align="center">Proxy-Authorization</td><td align="center">代理服务器要求客户端的认证信息</td></tr><tr><td align="center">Range</td><td align="center">实体的字节范围请求</td></tr><tr><td align="center">Referer</td><td align="center">对请求中 URI 的原始获取方</td></tr><tr><td align="center">TE</td><td align="center">传输编码的优先级</td></tr><tr><td align="center">User-Agent</td><td align="center">HTTP 客户端程序的信息</td></tr></tbody></table><h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Accept-Ranges</td><td align="center">是否接受字节范围请求</td></tr><tr><td align="center">Age</td><td align="center">推算资源创建经过时间</td></tr><tr><td align="center">ETag</td><td align="center">资源的匹配信息</td></tr><tr><td align="center">Location</td><td align="center">令客户端重定向至指定 URI</td></tr><tr><td align="center">Proxy-Authenticate</td><td align="center">代理服务器对客户端的认证信息</td></tr><tr><td align="center">Retry-After</td><td align="center">对再次发起请求的时机要求</td></tr><tr><td align="center">Server</td><td align="center">HTTP 服务器的安装信息</td></tr><tr><td align="center">Vary</td><td align="center">代理服务器缓存的管理信息</td></tr><tr><td align="center">WWW-Authenticate</td><td align="center">服务器对客户端的认证信息</td></tr></tbody></table><h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Allow</td><td align="center">资源可支持的 HTTP 方法</td></tr><tr><td align="center">Content-Encoding</td><td align="center">实体主体适用的编码方式</td></tr><tr><td align="center">Content-Language</td><td align="center">实体主体的自然语言</td></tr><tr><td align="center">Content-Length</td><td align="center">实体主体的大小</td></tr><tr><td align="center">Content-Location</td><td align="center">替代对应资源的 URI</td></tr><tr><td align="center">Content-MD5</td><td align="center">实体主体的报文摘要</td></tr><tr><td align="center">Content-Range</td><td align="center">实体主体的位置范围</td></tr><tr><td align="center">Content-Type</td><td align="center">实体主体的媒体类型</td></tr><tr><td align="center">Expires</td><td align="center">实体主体过期的日期时间</td></tr><tr><td align="center">Last-Modified</td><td align="center">资源的最后修改日期时间</td></tr></tbody></table><h2 id="五、具体应用"><a href="#五、具体应用" class="headerlink" title="五、具体应用"></a>五、具体应用</h2><h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p><img src="https://s1.ax1x.com/2020/05/06/YAtIcq.png" alt="连接管理"></p><h4 id="1-短连接与长连接"><a href="#1-短连接与长连接" class="headerlink" title="1. 短连接与长连接"></a>1. 短连接与长连接</h4><p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。</p><p>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。</p><ul><li>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code> ；</li><li>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code> 。</li></ul><h4 id="2-流水线"><a href="#2-流水线" class="headerlink" title="2. 流水线"></a>2. 流水线</h4><p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p><p>流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>HTTP 协议是<strong>无状态</strong>的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p><p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p><p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB 。</p><h4 id="1-用途"><a href="#1-用途" class="headerlink" title="1. 用途"></a>1. 用途</h4><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h4 id="2-创建过程"><a href="#2-创建过程" class="headerlink" title="2. 创建过程"></a>2. 创建过程</h4><p>服务器发送的响应报文包含 <code>Set-Cookie</code> 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p><pre class=" language-html"><code class="language-html">HTTP/1.0 200 OKContent-type: text/htmlSet-Cookie: yummy_cookie=chocoSet-Cookie: tasty_cookie=strawberry</code></pre><p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p><pre class=" language-html"><code class="language-html">GET /sample_page.html HTTP/1.1Host: www.example.orgCookie: yummy_cookie=choco; tasty_cookie=strawberry</code></pre><h4 id="3-分类"><a href="#3-分类" class="headerlink" title="3. 分类"></a>3. 分类</h4><ul><li><strong>会话期 Cookie ：</strong>浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li><li><strong>持久性 Cookie ：</strong>指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie 。</li></ul><pre class=" language-html"><code class="language-html">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</code></pre><h4 id="4-作用域"><a href="#4-作用域" class="headerlink" title="4. 作用域"></a>4. 作用域</h4><p><strong>Domain</strong> 标识指定了哪些主机可以接受 Cookie 。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain ，则一般包含子域名。例如，如果设置 Domain = mozilla.org ，则 Cookie 也包含在子域名中（如 developer.mozilla.org ）。</p><p><strong>Path</strong> 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 <code>%x2F (&quot;/&quot;)</code> 作为路径分隔符，子路径也会被匹配。例如，设置 <code>Path = /docs</code> ，则以下地址都会匹配：</p><ul><li>/docs</li><li>/docs/Web/</li><li>/docs/Web/HTTP</li></ul><h4 id="5-JavaScript"><a href="#5-JavaScript" class="headerlink" title="5. JavaScript"></a>5. JavaScript</h4><p>浏览器通过 <code>document.cookie</code> 属性可创建新的 Cookie，也可通过该属性访问非 <code>HttpOnly</code> 标记的 Cookie。</p><pre class=" language-html"><code class="language-html">document.cookie = "yummy_cookie=choco";document.cookie = "tasty_cookie=strawberry";console.log(document.cookie);</code></pre><h4 id="6-HttpOnly"><a href="#6-HttpOnly" class="headerlink" title="6. HttpOnly"></a>6. HttpOnly</h4><p>标记为 <strong>HttpOnly</strong> 的 Cookie <strong>不能</strong>被 JavaScript 脚本调用。<strong>跨站脚本攻击（XSS）</strong>常常使用 JavaScript 的 <code>document.cookie</code> API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</p><pre class=" language-html"><code class="language-html">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</code></pre><h4 id="7-Secure"><a href="#7-Secure" class="headerlink" title="7. Secure"></a>7. Secure</h4><p>标记为 <strong>Secure</strong> 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p><h4 id="8-Session"><a href="#8-Session" class="headerlink" title="8. Session"></a>8. Session</h4><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p><p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p><p>使用 Session 维护用户登录状态的过程如下：</p><ul><li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li><li>服务器验证用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID ；</li><li>服务器返回的响应报文的 <code>Set-Cookie</code> 首部字段包含了这个 Session ID ，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li><li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID ，从 Redis 中取出用户信息，继续之前的业务操作。</li></ul><p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID 。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p><h4 id="9-浏览器禁用-Cookie"><a href="#9-浏览器禁用-Cookie" class="headerlink" title="9. 浏览器禁用 Cookie"></a>9. 浏览器禁用 Cookie</h4><p>此时无法使用 Cookie 来保存用户信息，只能使用 Session 。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 <strong>URL 重写</strong>技术，将 Session ID 作为 URL 的参数进行传递。</p><h4 id="10-Cookie-与-Session-选择"><a href="#10-Cookie-与-Session-选择" class="headerlink" title="10. Cookie 与 Session 选择"></a>10. Cookie 与 Session 选择</h4><ul><li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session ；</li><li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li><li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li></ul><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h4><ul><li>缓解服务器压力；</li><li>降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</li></ul><h4 id="2-实现方法"><a href="#2-实现方法" class="headerlink" title="2. 实现方法"></a>2. 实现方法</h4><ul><li>让代理服务器进行缓存；</li><li>让客户端浏览器进行缓存。</li></ul><h4 id="3-Cache-Control"><a href="#3-Cache-Control" class="headerlink" title="3. Cache-Control"></a>3. Cache-Control</h4><p>HTTP/1.1 通过 <code>Cache-Control</code> 首部字段来控制缓存。</p><h5 id="3-1-禁止进行缓存"><a href="#3-1-禁止进行缓存" class="headerlink" title="3.1 禁止进行缓存"></a>3.1 禁止进行缓存</h5><p><code>no-store</code> 指令规定不能对请求或响应的任何一部分进行缓存。</p><pre class=" language-html"><code class="language-html">Cache-Control: no-store</code></pre><h5 id="3-2-强制确认缓存"><a href="#3-2-强制确认缓存" class="headerlink" title="3.2 强制确认缓存"></a>3.2 强制确认缓存</h5><p><code>no-cache</code> 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。</p><pre class=" language-html"><code class="language-html">Cache-Control: no-cache</code></pre><h5 id="3-3-私有缓存和公共缓存"><a href="#3-3-私有缓存和公共缓存" class="headerlink" title="3.3 私有缓存和公共缓存"></a>3.3 私有缓存和公共缓存</h5><p><code>private</code> 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。</p><pre class=" language-html"><code class="language-html">Cache-Control: private</code></pre><p><code>public</code> 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。</p><pre class=" language-html"><code class="language-html">Cache-Control: public</code></pre><h5 id="3-4-缓存过期机制"><a href="#3-4-缓存过期机制" class="headerlink" title="3.4 缓存过期机制"></a>3.4 缓存过期机制</h5><p><code>max-age</code> 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</p><p><code>max-age</code> 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。</p><pre class=" language-html"><code class="language-html">Cache-Control: max-age=31536000</code></pre><p><code>Expires</code> 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</p><pre class=" language-html"><code class="language-html">Expires: Wed, 04 Jul 2012 08:26:05 GMT</code></pre><ul><li>在 HTTP/1.1 中，会优先处理 max-age 指令；</li><li>在 HTTP/1.0 中，max-age 指令会被忽略掉。</li></ul><h4 id="4-缓存验证"><a href="#4-缓存验证" class="headerlink" title="4. 缓存验证"></a>4. 缓存验证</h4><p>需要先了解 <code>ETag</code> 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 <code>http://www.google.com/</code> 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。</p><pre class=" language-html"><code class="language-html">ETag: "82e22293907ce725faf67773957acd12"</code></pre><p>可以将缓存资源的 ETag 值放入 <code>If-None-Match</code> 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 <strong>304</strong> Not Modified 。</p><pre class=" language-html"><code class="language-html">If-None-Match: "82e22293907ce725faf67773957acd12"</code></pre><p><code>Last-Modified</code> 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种<strong>弱校验器</strong>，因为只能精确到<strong>一秒</strong>，所以它通常作为 <code>ETag</code> 的<strong>备用方案</strong>。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 <code>If-Modified-Since</code> 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 <strong>200</strong> OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 <strong>304</strong> Not Modified 响应报文。</p><pre class=" language-html"><code class="language-html">Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT</code></pre><pre class=" language-html"><code class="language-html">If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT</code></pre><h3 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h3><p>通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。</p><h4 id="1-类型"><a href="#1-类型" class="headerlink" title="1. 类型"></a>1. 类型</h4><h5 id="1-1-服务端驱动型"><a href="#1-1-服务端驱动型" class="headerlink" title="1.1 服务端驱动型"></a>1.1 服务端驱动型</h5><p>客户端设置特定的 HTTP 首部字段，例如 <code>Accept</code> 、<code>Accept-Charset</code> 、<code>Accept-Encoding</code> 、<code>Accept-Language</code> ，服务器根据这些字段返回特定的资源。</p><p>它存在以下问题：</p><ul><li>服务器很难知道客户端浏览器的全部信息；</li><li>客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）；</li><li>给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。</li></ul><h5 id="1-2-代理驱动型"><a href="#1-2-代理驱动型" class="headerlink" title="1.2 代理驱动型"></a>1.2 代理驱动型</h5><p>服务器返回 <strong>300</strong> Multiple Choices 或者 <strong>406</strong> Not Acceptable，客户端从中选出最合适的那个资源。</p><h4 id="2-Vary"><a href="#2-Vary" class="headerlink" title="2. Vary"></a>2. Vary</h4><pre class=" language-html"><code class="language-html">Vary: Accept-Language</code></pre><p>在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。</p><blockquote><p>例如，一个客户端发送了一个包含 <code>Accept-Language</code> 首部字段的请求之后，源服务器返回的响应包含 <code>Vary: Accept-Language</code> 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 <code>Accept-Language</code> 与缓存中的对应的值<strong>相同</strong>时才会返回该缓存。</p></blockquote><h3 id="内容编码"><a href="#内容编码" class="headerlink" title="内容编码"></a>内容编码</h3><p>内容编码<strong>将实体主体进行压缩</strong>，从而减少传输的数据量。</p><p>常用的内容编码有：<code>gzip</code> 、<code>compress</code> 、<code>deflate</code> 、<code>identity</code> 。</p><p>浏览器发送 <code>Accept-Encoding</code> 首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 <code>Content-Encoding</code> 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的 <code>Vary</code> 首部字段至少要包含 <code>Content-Encoding</code> 。</p><h3 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h3><p>如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。</p><h4 id="1-Range"><a href="#1-Range" class="headerlink" title="1. Range"></a>1. Range</h4><p>在请求报文中添加 <code>Range</code> 首部字段指定请求的范围。</p><pre class=" language-html"><code class="language-html">GET /z4d4kWk.jpg HTTP/1.1Host: i.imgur.comRange: bytes=0-1023</code></pre><p>请求成功的话服务器返回的响应包含 <strong>206</strong> Partial Content 状态码。</p><pre class=" language-html"><code class="language-html">HTTP/1.1 206 Partial ContentContent-Range: bytes 0-1023/146515Content-Length: 1024...(binary content)</code></pre><h4 id="2-Accept-Ranges"><a href="#2-Accept-Ranges" class="headerlink" title="2. Accept-Ranges"></a>2. Accept-Ranges</h4><p>响应首部字段 <code>Accept-Ranges</code> 用于告知客户端是否能处理范围请求，可以处理使用 <code>bytes</code> ，否则使用 <code>none</code> 。</p><pre class=" language-html"><code class="language-html">Accept-Ranges: bytes</code></pre><h4 id="3-响应状态码"><a href="#3-响应状态码" class="headerlink" title="3. 响应状态码"></a>3. 响应状态码</h4><ul><li>在请求成功的情况下，服务器会返回 <strong>206</strong> Partial Content 状态码。</li><li>在请求的范围越界的情况下，服务器会返回 <strong>416</strong> Requested Range Not Satisfiable 状态码。</li><li>在不支持范围请求的情况下，服务器会返回 <strong>200</strong> OK 状态码。</li></ul><h3 id="分块传输编码"><a href="#分块传输编码" class="headerlink" title="分块传输编码"></a>分块传输编码</h3><p><code>Chunked Transfer Encoding</code> ，可以把数据分割成多块，让浏览器逐步显示页面。</p><h3 id="多部分对象集合"><a href="#多部分对象集合" class="headerlink" title="多部分对象集合"></a>多部分对象集合</h3><p>一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 <code>boundary</code> 字段定义的分隔符进行分隔，每个部分都可以有首部字段。</p><p>例如，上传多个表单时可以使用如下方式：</p><pre class=" language-html"><code class="language-html">Content-Type: multipart/form-data; boundary=AaB03x--AaB03xContent-Disposition: form-data; name="submit-name"Larry--AaB03xContent-Disposition: form-data; name="files"; filename="file1.txt"Content-Type: text/plain... contents of file1.txt ...--AaB03x--</code></pre><h3 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h3><p>HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。</p><h3 id="通信数据转发"><a href="#通信数据转发" class="headerlink" title="通信数据转发"></a>通信数据转发</h3><h4 id="1-代理"><a href="#1-代理" class="headerlink" title="1. 代理"></a>1. 代理</h4><p>代理服务器接受客户端的请求，并且转发给其它服务器。</p><p>使用代理的主要目的是：</p><ul><li>缓存</li><li>负载均衡</li><li>网络访问控制</li><li>访问日志记录</li></ul><p>代理服务器分为<strong>正向代理</strong>和<strong>反向代理</strong>两种：</p><ul><li><p>用户察觉得到正向代理的存在。</p><p><img src="https://s1.ax1x.com/2020/05/06/YAvbLQ.png" alt="正向代理"></p></li><li><p>而反向代理一般位于内部网络中，用户察觉不到。</p><p><img src="https://s1.ax1x.com/2020/05/06/YAxMOe.png" alt="反向代理"></p></li></ul><h4 id="2-网关"><a href="#2-网关" class="headerlink" title="2. 网关"></a>2. 网关</h4><p>与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。</p><h4 id="3-隧道"><a href="#3-隧道" class="headerlink" title="3. 隧道"></a>3. 隧道</h4><p>使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。</p><h2 id="六、HTTPS"><a href="#六、HTTPS" class="headerlink" title="六、HTTPS"></a>六、HTTPS</h2><p>HTTP 有以下安全性问题：</p><ul><li>使用明文进行通信，内容可能会被窃听；</li><li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li><li>无法证明报文的完整性，报文有可能遭篡改。</li></ul><p>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。</p><p>通过使用 SSL ，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p><p><img src="https://s1.ax1x.com/2020/05/06/YAxDTs.jpg" alt="HTTPS"></p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><h4 id="1-对称密钥加密"><a href="#1-对称密钥加密" class="headerlink" title="1. 对称密钥加密"></a>1. 对称密钥加密</h4><p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p><ul><li>优点：运算速度快；</li><li>缺点：无法安全地将密钥传输给通信方。</li></ul><p><img src="https://s1.ax1x.com/2020/05/06/YAxL6O.md.png" alt="对称密钥加密"></p><h4 id="2-非对称密钥加密"><a href="#2-非对称密钥加密" class="headerlink" title="2.非对称密钥加密"></a>2.非对称密钥加密</h4><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p><p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p><p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p><ul><li>优点：可以更安全地将公开密钥传输给通信发送方；</li><li>缺点：运算速度慢。</li></ul><p><img src="https://s1.ax1x.com/2020/05/06/YAzkjS.png" alt="非对称密钥加密"></p><h4 id="3-HTTPS-采用的加密方式"><a href="#3-HTTPS-采用的加密方式" class="headerlink" title="3. HTTPS 采用的加密方式"></a>3. HTTPS 采用的加密方式</h4><p>上面提到对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key 传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key  传输给通信方。HTTPS 采用混合的加密机制，正是利用了上面提到的方案：</p><ul><li>使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性;</li><li>获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key ）</li></ul><p><img src="https://s1.ax1x.com/2020/05/06/YAzhgf.png" alt="HTTPS 加密流程"></p><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><p>通过使用 <strong>证书</strong> 来对通信方进行认证。</p><p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p><p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p><p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p><p><img src="https://s1.ax1x.com/2020/05/06/YVl4eg.png" alt=""></p><h3 id="完整性保护"><a href="#完整性保护" class="headerlink" title="完整性保护"></a>完整性保护</h3><p>SSL 提供<strong>报文摘要</strong>功能来进行完整性保护。</p><p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p><p>HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p><h3 id="HTTPS-的缺点"><a href="#HTTPS-的缺点" class="headerlink" title="HTTPS 的缺点"></a>HTTPS 的缺点</h3><ul><li>因为需要进行加密解密等过程，因此速度会更慢；</li><li>需要支付证书授权的高额费用。</li></ul><h2 id="七、HTTP-2-0"><a href="#七、HTTP-2-0" class="headerlink" title="七、HTTP/2.0"></a>七、HTTP/2.0</h2><h3 id="HTTP-1-x-缺陷"><a href="#HTTP-1-x-缺陷" class="headerlink" title="HTTP/1.x 缺陷"></a>HTTP/1.x 缺陷</h3><p>HTTP/1.x 实现简单是以牺牲性能为代价的：</p><ul><li>客户端需要使用多个连接才能实现并发和缩短延迟；</li><li>不会压缩请求和响应首部，从而导致不必要的网络流量；</li><li>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。</li></ul><h3 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h3><p>HTTP/2.0 将报文分成 <code>HEADERS</code> 帧和 <code>DATA</code> 帧，它们都是二进制格式的。</p><p><img src="https://s1.ax1x.com/2020/05/06/YV3nDU.png" alt="二进制分帧层"></p><p>在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。</p><ul><li>一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。</li><li>消息（Message）是与逻辑请求或响应对应的完整的一系列帧。</li><li>帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</li></ul><p><img src="https://s1.ax1x.com/2020/05/06/YV3UbD.png" alt="数据流"></p><h3 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h3><p>HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。</p><p><img src="https://s1.ax1x.com/2020/05/06/YV3yxP.png" alt="服务端推送"></p><h3 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h3><p>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。</p><p>HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。</p><p>不仅如此，HTTP/2.0 也使用 <code>Huffman</code> 编码对首部字段进行压缩。</p><p><img src="https://s1.ax1x.com/2020/05/06/YV3o2q.png" alt="首部压缩"></p><h2 id="八、HTTP-1-1-新特性"><a href="#八、HTTP-1-1-新特性" class="headerlink" title="八、HTTP/1.1 新特性"></a>八、HTTP/1.1 新特性</h2><p>详细内容请见上文。</p><ul><li>默认是长连接</li><li>支持流水线</li><li>支持同时打开多个 TCP 连接</li><li>支持虚拟主机</li><li>新增状态码 100</li><li>支持分块传输编码</li><li>新增缓存处理指令 max-age</li></ul><h2 id="九、GET-和-POST-比较"><a href="#九、GET-和-POST-比较" class="headerlink" title="九、GET 和 POST 比较"></a>九、GET 和 POST 比较</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>GET 用于获取资源，而 POST 用于传输实体主体。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。</p><p>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code> ，而空格会转换为 <code>%20</code> 。POST 参数支持标准字符集。</p><pre class=" language-html"><code class="language-html">GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1</code></pre><pre class=" language-html"><code class="language-html">POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2</code></pre><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p><p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p><p>安全的方法除了 GET 之外还有：HEAD 、OPTIONS 。</p><p>不安全的方法除了 POST 之外还有 PUT 、DELETE 。</p><h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</p><p>所有的安全方法也都是幂等的。</p><p>在正确实现的条件下，GET ，HEAD ，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</p><p><code>GET /pageX HTTP/1.1</code> 是幂等的，连续调用多次，客户端接收到的结果都是一样的：</p><pre class=" language-html"><code class="language-html">GET /pageX HTTP/1.1GET /pageX HTTP/1.1GET /pageX HTTP/1.1GET /pageX HTTP/1.1</code></pre><p><code>POST /add_row HTTP/1.1</code> 不是幂等的，如果调用多次，就会增加多行记录：</p><pre class=" language-html"><code class="language-html">POST /add_row HTTP/1.1   -> Adds a 1nd rowPOST /add_row HTTP/1.1   -> Adds a 2nd rowPOST /add_row HTTP/1.1   -> Adds a 3rd row</code></pre><p><code>DELETE /idX/delete HTTP/1.1</code> 是幂等的，即使不同的请求接收到的状态码不一样：</p><pre class=" language-html"><code class="language-html">DELETE /idX/delete HTTP/1.1   -> Returns 200 if idX existsDELETE /idX/delete HTTP/1.1   -> Returns 404 as it just got deletedDELETE /idX/delete HTTP/1.1   -> Returns 404</code></pre><h3 id="可缓存"><a href="#可缓存" class="headerlink" title="可缓存"></a>可缓存</h3><p>如果要对响应进行缓存，需要满足以下条件：</p><ul><li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD ，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li><li>响应报文的状态码是可缓存的，包括：200 , 203 , 204 , 206 , 300 , 301 , 404 , 405 , 410 , 414 , and 501 。</li><li>响应报文的 <code>Cache-Control</code> 首部字段没有指定不进行缓存。</li></ul><h3 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h3><p>为了阐述 POST 和 GET 的另一个区别，需要先了解 <code>XMLHttpRequest</code> ：</p><blockquote><p><strong>XMLHttpRequest</strong> 是一个 API ，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。<strong>XMLHttpRequest</strong> 在 AJAX 中被大量使用。</p></blockquote><ul><li>在使用 <code>XMLHttpRequest</code> 的 POST 方法时，浏览器会<strong>先发送 Header 再发送 Data</strong> 。但并不是所有浏览器会这么做，例如火狐就不会。</li><li>而 GET 方法 <strong>Header 和 Data 会一起发送</strong>。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>上野宣. 图解 HTTP[M]. 人民邮电出版社, 2014.</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="noopener">MDN : HTTP</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn" target="_blank" rel="noopener">HTTP/2 简介</a></li><li><a href="http://php.net/manual/zh/function.htmlspecialchars.php" target="_blank" rel="noopener">htmlspecialchars</a></li><li><a href="http://java2db.com/java-io/how-to-get-and-the-difference-between-file-uri-and-url-in-java" target="_blank" rel="noopener">Difference between file URI and URL in java</a></li><li><a href="https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement" target="_blank" rel="noopener">How to Fix SQL Injection Using Java PreparedStatement &amp; CallableStatement</a></li><li><a href="https://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html" target="_blank" rel="noopener">浅谈 HTTP 中 Get 与 Post 的区别</a></li><li><a href="https://www.webdancers.com/are-http-and-www-necesary/" target="_blank" rel="noopener">Are http:// and www really necessary?</a></li><li><a href="https://www.ntu.edu.sg/home/ehchua/programming/webprogramming/HTTP_Basics.html" target="_blank" rel="noopener">HTTP (HyperText Transfer Protocol)</a></li><li><a href="https://www.igvita.com/2011/12/01/web-vpn-secure-proxies-with-spdy-chrome/" target="_blank" rel="noopener">Web-VPN: Secure Proxies with SPDY &amp; Chrome</a></li><li><a href="http://en.wikipedia.org/wiki/File:HTTP_persistent_connection.svg" target="_blank" rel="noopener">File:HTTP persistent connection.svg</a></li><li><a href="https://en.wikipedia.org/wiki/Proxy_server" target="_blank" rel="noopener">Proxy server</a></li><li><a href="https://www.x-cart.com/blog/what-is-https-and-ssl.html" target="_blank" rel="noopener">What Is This HTTPS/SSL Thing And Why Should You Care?</a></li><li><a href="https://securebox.comodo.com/ssl-sniffing/ssl-offloading/" target="_blank" rel="noopener">What is SSL Offloading?</a></li><li><a href="https://docs.oracle.com/cd/E19424-01/820-4811/6ng8i26bn/index.html" target="_blank" rel="noopener">Sun Directory Server Enterprise Edition 7.0 Reference - Key Encryption</a></li><li><a href="https://www.codeproject.com/Articles/326574/An-Introduction-to-Mutual-SSL-Authentication" target="_blank" rel="noopener">An Introduction to Mutual SSL Authentication</a></li><li><a href="https://danielmiessler.com/study/url-uri/" target="_blank" rel="noopener">The Difference Between URLs and URIs</a></li><li><a href="https://juejin.im/entry/5766c29d6be3ff006a31b84e#comment" target="_blank" rel="noopener">Cookie 与 Session 的区别</a></li><li><a href="https://www.zhihu.com/question/19786827" target="_blank" rel="noopener">COOKIE 和 SESSION 有什么区别</a></li><li><a href="https://harttle.land/2015/08/10/cookie-session.html" target="_blank" rel="noopener">Cookie/Session 的机制与安全</a></li><li><a href="https://shijianan.com/2017/06/11/https/" target="_blank" rel="noopener">HTTPS 证书原理</a></li><li><a href="https://stackoverflow.com/questions/176264/what-is-the-difference-between-a-uri-a-url-and-a-urn" target="_blank" rel="noopener">What is the difference between a URI, a URL and a URN?</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">XMLHttpRequest</a></li><li><a href="https://blog.josephscott.org/2009/08/27/xmlhttprequest-xhr-uses-multiple-packets-for-http-post/" target="_blank" rel="noopener">XMLHttpRequest (XHR) Uses Multiple Packets for HTTP POST?</a></li><li><a href="https://www.ssl2buy.com/wiki/symmetric-vs-asymmetric-encryption-what-are-differences" target="_blank" rel="noopener">Symmetric vs. Asymmetric Encryption – What are differences?</a></li><li><a href="https://www.kancloud.cn/digest/web-performance-http2" target="_blank" rel="noopener">Web 性能优化与 HTTP/2</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn" target="_blank" rel="noopener">HTTP/2 简介</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络层</title>
      <link href="/2020/05/06/408/ji-suan-ji-wang-luo/wang-luo-ceng/"/>
      <url>/2020/05/06/408/ji-suan-ji-wang-luo/wang-luo-ceng/</url>
      
        <content type="html"><![CDATA[<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。</p><p>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</p><p><img src="https://s1.ax1x.com/2020/05/06/YkgtUI.png" alt=""></p><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 <strong>ARP</strong>（Address Resolution Protocol）</li><li>网际控制报文协议 <strong>ICMP</strong>（Internet Control Message Protocol）</li><li>网际组管理协议 <strong>IGMP</strong>（Internet Group Management Protocol）</li></ul><h2 id="IP-数据报格式"><a href="#IP-数据报格式" class="headerlink" title="IP 数据报格式"></a>IP 数据报格式</h2><p><img src="https://s1.ax1x.com/2020/05/06/Ykgd8f.jpg" alt="IP 数据报的格式"></p><ul><li><p><strong>版本：</strong>有 4（IPv4）和 6（IPv6）两个值；</p></li><li><p><strong>首部长度：</strong>占 4 位，因此最大值为 15 。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5 。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</p></li><li><p><strong>区分服务：</strong>用来获得更好的服务，一般情况下不使用。</p></li><li><p><strong>总长度：</strong>包括首部长度和数据部分长度。</p></li><li><p><strong>生存时间：</strong>TTL ，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</p></li><li><p><strong>协议：</strong>指出携带的数据应该上交给哪个协议进行处理，例如 ICMP 、TCP 、UDP 等。</p></li><li><p><strong>首部检验和：</strong>因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</p></li><li><p><strong>标识：</strong>在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</p></li><li><p><strong>片偏移：</strong>和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</p></li></ul><p><img src="https://s1.ax1x.com/2020/05/06/Yk2PII.png" alt="数据报的分片举例"></p><h2 id="IP-地址编址方式"><a href="#IP-地址编址方式" class="headerlink" title="IP 地址编址方式"></a>IP 地址编址方式</h2><p>IP 地址的编址方式经历了三个历史阶段：</p><ul><li>分类</li><li>子网划分</li><li>无分类</li></ul><h3 id="1-分类"><a href="#1-分类" class="headerlink" title="1. 分类"></a>1. 分类</h3><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p><p>IP 地址 ::= { &lt; 网络号 &gt;, &lt; 主机号 &gt; }</p><p><img src="https://s1.ax1x.com/2020/05/06/Yk2aw9.png" alt="IP 地址中的网络号字段和主机号字段"></p><h3 id="2-子网划分"><a href="#2-子网划分" class="headerlink" title="2. 子网划分"></a>2. 子网划分</h3><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p><p>IP 地址 ::= { &lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt; }</p><p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0 ，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000 ，也就是 255.255.192.0 。</p><p>注意，外部网络看不到子网的存在。</p><h3 id="3-无分类"><a href="#3-无分类" class="headerlink" title="3. 无分类"></a>3. 无分类</h3><p>无分类域间路由选择 <strong>CIDR</strong> 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p><p>IP 地址 ::= { &lt; 网络前缀号 &gt;, &lt; 主机号 &gt; }</p><p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p><p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p><p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 <strong>构成超网</strong> 。</p><p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用<strong>最长前缀匹配</strong>来确定应该匹配哪一个。</p><h2 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议 ARP"></a>地址解析协议 ARP</h2><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p><p><img src="https://s1.ax1x.com/2020/05/06/YkRmp6.jpg" alt=""></p><p>ARP 实现<strong>由 IP 地址得到 MAC 地址</strong>。</p><p><img src="https://s1.ax1x.com/2020/05/06/YkR96U.jpg" alt="ARP 协议的作用"></p><p>每个主机都有一个 ARP <strong>高速缓存</strong>，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p><p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p><p><img src="https://s1.ax1x.com/2020/05/06/YkRKXD.png" alt="地址解析协议 ARP 的工作原理"></p><h2 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a>网际控制报文协议 ICMP</h2><p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p><p><img src="https://s1.ax1x.com/2020/05/06/YkRGtI.jpg" alt="ICMP 报文的格式"></p><p>ICMP 报文分为<strong>差错报告报文</strong>和<strong>询问报文</strong>。</p><p><img src="https://s1.ax1x.com/2020/05/06/YkR0BQ.png" alt="几种常见的 ICMP 报文类型"></p><h3 id="1-Ping"><a href="#1-Ping" class="headerlink" title="1. Ping"></a>1. Ping</h3><p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p><p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p><h3 id="2-Traceroute"><a href="#2-Traceroute" class="headerlink" title="2. Traceroute"></a>2. Traceroute</h3><p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p><p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p><ul><li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1 ，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1 ，此时 TTL 等于 0 ，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li><li>源主机接着发送第二个数据报 P2 ，并把 TTL 设置为 2 。P2 先到达 R1 ，R1 收下后把 TTL 减 1 再转发给 R2 ，R2 收下后也把 TTL 减 1 ，由于此时 TTL 等于 0 ，R2 就丢弃 P2 ，并向源主机发送一个 ICMP 时间超过差错报文。</li><li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1 。但是因为数据报封装的是无法交付的 UDP ，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li><li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li></ul><h2 id="虚拟专用网-VPN"><a href="#虚拟专用网-VPN" class="headerlink" title="虚拟专用网 VPN"></a>虚拟专用网 VPN</h2><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p><p>有三个专用地址块：</p><ul><li>10.0.0.0 ~ 10.255.255.255</li><li>172.16.0.0 ~ 172.31.255.255</li><li>192.168.0.0 ~ 192.168.255.255</li></ul><p>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。</p><p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1 ，目的地址是 10.2.0.3 。数据报先发送到与互联网相连的路由器 R1 ，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3 ，目的地址是路由器 R2 的全球地址 194.4.5.6 。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3 ，就交付给 Y 。</p><p><img src="https://s1.ax1x.com/2020/05/06/YAMr6g.jpg" alt="用隧道技术实现虚拟专用网"></p><h2 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h2><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP 。</p><p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT 。</p><p><img src="https://s1.ax1x.com/2020/05/06/YAM7nJ.png" alt="NAPT 地址转换表举例"></p><h2 id="路由器的结构"><a href="#路由器的结构" class="headerlink" title="路由器的结构"></a>路由器的结构</h2><p>路由器从功能上可以划分为：<strong>路由选择</strong>和<strong>分组转发</strong>。</p><p>分组转发结构由三个部分组成：<strong>交换结构</strong>、<strong>一组输入端口</strong>和<strong>一组输出端口</strong>。</p><p><img src="https://s1.ax1x.com/2020/05/06/YAQYgU.jpg" alt="典型的路由器的结构"></p><h2 id="路由器分组转发流程"><a href="#路由器分组转发流程" class="headerlink" title="路由器分组转发流程"></a>路由器分组转发流程</h2><ul><li>从数据报的首部提取目的主机的 IP 地址 D ，得到目的网络地址 N 。</li><li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li><li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li><li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li><li>报告转发分组出错。</li></ul><p><img src="https://s1.ax1x.com/2020/05/06/YAl92T.jpg" alt="路由分组转发流程"></p><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p><p>互联网可以划分为许多较小的<strong>自治系统</strong> AS ，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p><p>可以把路由选择协议划分为两大类：</p><ul><li>自治系统内部的路由选择：RIP 和 OSPF</li><li>自治系统间的路由选择：BGP</li></ul><h3 id="1-内部网关协议-RIP"><a href="#1-内部网关协议-RIP" class="headerlink" title="1. 内部网关协议 RIP"></a>1. 内部网关协议 RIP</h3><p>RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1 。跳数最多为 15，超过 15 表示不可达。</p><p>RIP 按固定的时间间隔仅和<strong>相邻</strong>路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p><p>距离向量算法：</p><ul><li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X ，并把所有的距离字段加 1 ；</li><li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：<ul><li>若原来的路由表中没有目的网络 N ，则把该项目添加到路由表中；</li><li>否则：若下一跳路由器地址是 X ，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li></ul></li><li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16 。</li></ul><p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15 ，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p><h3 id="2-内部网关协议-OSPF"><a href="#2-内部网关协议-OSPF" class="headerlink" title="2. 内部网关协议 OSPF"></a>2. 内部网关协议 OSPF</h3><p>开放最短路径优先 OSPF ，是为了克服 RIP 的缺点而开发出来的。</p><p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF 。</p><p>OSPF 具有以下特点：</p><ul><li>向本自治系统中的<strong>所有</strong>路由器发送信息，这种方法是洪泛法。</li><li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li><li>只有当链路状态发生变化时，路由器才会发送信息。</li></ul><p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP ，OSPF 的更新过程<strong>收敛的很快</strong>。</p><h3 id="3-外部网关协议-BGP"><a href="#3-外部网关协议-BGP" class="headerlink" title="3. 外部网关协议 BGP"></a>3. 外部网关协议 BGP</h3><p>BGP（Border Gateway Protocol，边界网关协议）</p><p>AS 之间的路由选择很困难，主要是由于：</p><ul><li>互联网规模很大；</li><li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li><li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li></ul><p>BGP 只能寻找一条比较好的路由，而不是最佳路由。</p><p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p><p><img src="https://s1.ax1x.com/2020/05/06/YA1r6O.png" alt="BGP 发言人和自治系统 AS 的关系"></p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 网络层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP</title>
      <link href="/2020/05/05/408/ji-suan-ji-wang-luo/tcp/"/>
      <url>/2020/05/05/408/ji-suan-ji-wang-luo/tcp/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。</p><p>TCP 旨在适应支持多网络应用的分层协议层次结构。 连接到不同但互连的计算机通信网络的主计算机中的成对进程之间依靠 TCP 提供可靠的通信服务。TCP 假设它可以从较低级别的协议获得简单的，可能不可靠的数据报服务。 原则上，TCP 应该能够在从硬线连接到分组交换或电路交换网络的各种通信系统之上操作。</p><h3 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h3><p><img src="https://s1.ax1x.com/2020/05/05/YFAolt.png" alt="TCP 首部"></p><ul><li>源端口和目的端口，各占 2 个字节，分别写入源端口和目的端口；</li><li>序号，占 4 个字节，TCP 连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有 100 字段，显然下一个报文段（如果还有的话）的数据序号应该从 401 开始；</li><li>确认号，占 4 个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B 收到了 A 发送过来的报文，其序列号字段是 501 ，而数据长度是 200 字节，这表明 B 正确的收到了 A 发送的到序号 700 为止的数据。因此，B 期望收到 A 的下一个数据序号是 701 ，于是 B 在发送给 A 的确认报文段中把确认号置为 701 ；</li><li>数据偏移，占 4 位，它指出 TCP 报文的数据距离 TCP 报文段的起始处有多远；</li><li>保留，占 6 位，保留今后使用，但目前应都为 0 ；</li><li>紧急 <strong>URG</strong> ，当 URG = 1 ，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；</li><li>确认 <strong>ACK</strong> ，仅当 ACK = 1 时，确认号字段才有效。TCP 规定，在连接建立后所有报文的传输都必须把 ACK 置 1 ；</li><li>推送 <strong>PSH</strong> ，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将 PSH = 1 ；</li><li>复位 <strong>RST</strong> ，当 RST = 1 ，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立连接；</li><li>同步 <strong>SYN</strong> ，在连接建立时用来同步序号。当 SYN = 1 ，ACK = 0 ，表明是连接请求报文，若同意连接，则响应报文中应该使 SYN = 1 ，ACK = 1 ；</li><li>终止 <strong>FIN</strong> ，用来释放连接。当 FIN = 1 ，表明此报文的发送方的数据已经发送完毕，并且要求释放；</li><li>窗口，占 2 字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；</li><li>检验和，占 2 字节，校验首部和数据这两部分；</li><li>紧急指针，占 2 字节，指出本报文段中的紧急数据的字节数；</li><li>选项，长度可变，定义一些其他的可选的参数。</li></ul><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><blockquote><p>最开始的时候客户端和服务器都是处于 CLOSED 状态。主动打开连接的为客户端，被动打开连接的是服务器。</p></blockquote><p><img src="https://s1.ax1x.com/2020/05/05/YFkvM6.png" alt="TCP 三次握手"></p><ul><li>TCP 服务器进程先创建传输控制块 TCB ，时刻准备接受客户进程的连接请求，此时服务器就进入了 <strong>LISTEN</strong>（监听）状态。</li><li>TCP 客户进程也是先创建传输控制块 TCB ，然后向服务器发出连接请求报文，这时报文首部中的同步位 SYN = 1 ，同时选择一个初始序列号 seq = x ，此时，TCP 客户端进程进入了 <strong>SYN-SENT</strong>（同步已发送状态）状态。<strong>TCP 规定，SYN 报文段（ SYN = 1 的报文段）不能携带数据，但需要消耗掉一个序号。</strong></li><li>TCP 服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK = 1 ，SYN = 1 ，确认号是 ack = x+1 ，同时也要为自己初始化一个序列号 seq = y ，此时，TCP 服务器进程进入了 <strong>SYN-RCVD</strong>（同步收到）状态。<strong>这个报文也不能携带数据，但是同样要消耗一个序号。</strong></li><li>TCP 客户进程收到确认后，还要向服务器给出确认。确认报文的 ACK = 1 ，ack = y+1 ，自己的序列号 seq = x+1 ，此时，TCP 连接建立，客户端进入 <strong>ESTABLISHED</strong>（已建立连接）状态。<strong>TCP 规定，ACK 报文段可以携带数据，但是如果不携带数据则不消耗序号。</strong></li><li>当服务器收到客户端的确认后也进入 <strong>ESTABLISHED</strong> 状态，此后双方就可以开始通信了。</li></ul><h3 id="为什么-TCP-客户端最后还要发送一次确认呢？"><a href="#为什么-TCP-客户端最后还要发送一次确认呢？" class="headerlink" title="为什么 TCP 客户端最后还要发送一次确认呢？"></a>为什么 TCP 客户端最后还要发送一次确认呢？</h3><p>一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</p><blockquote><p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于 TCP 的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p><p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p></blockquote><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><blockquote><p>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于 ESTABLISHED 状态，然后客户端主动关闭，服务器被动关闭。</p></blockquote><p><img src="https://s1.ax1x.com/2020/05/05/YFVDr6.png" alt="TCP 四次挥手"></p><ul><li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN = 1 ，其序列号为 seq = u（等于前面已经传送过来的数据的最后一个字节的序号加 1 ），此时，客户端进入 <strong>FIN-WAIT-1</strong>（终止等待 1 ）状态。 <strong>TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号。</strong></li><li>服务器收到连接释放报文，发出确认报文，ACK = 1 ，ack = u+1 ，并且带上自己的序列号 seq = v ，此时，服务端就进入了 <strong>CLOSE-WAIT</strong>（关闭等待）状态。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于<strong>半关闭状态</strong>，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 <strong>CLOSE-WAIT</strong> 状态持续的时间。</li><li>客户端收到服务器的确认请求后，此时，客户端就进入 <strong>FIN-WAIT-2</strong>（终止等待 2 ）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li><li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN = 1 ，ack = u+1 ，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq = w ，此时，服务器就进入了 <strong>LAST-ACK</strong>（最后确认）状态，等待客户端的确认。</li><li>客户端收到服务器的连接释放报文后，必须发出确认，ACK = 1 ，ack = w+1 ，而自己的序列号是 seq = u+1 ，此时，客户端就进入了 <strong>TIME-WAIT</strong>（时间等待）状态。注意此时 TCP 连接还没有释放，必须经过 2MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 <strong>CLOSED</strong> 状态。</li><li>服务器只要收到了客户端发出的确认，立即进入 <strong>CLOSED</strong> 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。可以看到，服务器结束 TCP 连接的时间要比客户端早一些。</li></ul><h3 id="为什么要四次挥手？"><a href="#为什么要四次挥手？" class="headerlink" title="为什么要四次挥手？"></a>为什么要四次挥手？</h3><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p><blockquote><p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p></blockquote><p>上面讲的比较概括，推荐一篇讲的比较细致的文章：<a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">两张动图-彻底明白TCP的三次握手与四次挥手</a></p><h3 id="为什么客户端最后还要等待-2MSL-？"><a href="#为什么客户端最后还要等待-2MSL-？" class="headerlink" title="为什么客户端最后还要等待 2MSL ？"></a>为什么客户端最后还要等待 2MSL ？</h3><p>MSL（Maximum Segment Lifetime），TCP 允许不同的实现可以设置不同的 MSL 值。</p><ul><li>第一，保证客户端发送的最后一个 ACK 报文能够到达服务器，因为这个 ACK 报文可能丢失，站在服务器的角度看来，我已经发送了 FIN+ACK 报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个 2MSL 时间段内收到这个重传的报文，接着给出回应报文，并且会重启 2MSL 计时器。</li><li>第二，防止类似于“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个 2MSL 时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</li></ul><h3 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h3><p>建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。</p><p>而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。</p><h3 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><p><strong>TCP 设有一个保活计时器。</strong>显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为 2 小时，若 2 小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔 75 秒发送一次。若一连发送 10 个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h3 id="TCP-可靠传输"><a href="#TCP-可靠传输" class="headerlink" title="TCP 可靠传输"></a>TCP 可靠传输</h3><p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p><p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT ，加权平均往返时间 RTTs 计算如下：</p><p><img src="https://s1.ax1x.com/2020/05/05/YFniFS.gif" alt=""></p><p>其中，0 ≤ a &lt; 1 ，RTTs 随着 a 的增加更容易受到 RTT 的影响。</p><p>超时时间 RTO 应该略大于 RTTs ，TCP 使用的超时时间计算如下：</p><p><img src="https://s1.ax1x.com/2020/05/05/YFnNex.gif" alt=""></p><p>其中 RTT<sub>d</sub> 为偏差的加权平均值。</p><h3 id="TCP-滑动窗口"><a href="#TCP-滑动窗口" class="headerlink" title="TCP 滑动窗口"></a>TCP 滑动窗口</h3><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35} ，其中 {31} 按序到达，而  {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p><p><img src="https://s1.ax1x.com/2020/05/05/YFM201.jpg" alt="TCP 滑动窗口"></p><h3 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h3><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p><p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h3 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h3><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p><p><img src="https://s1.ax1x.com/2020/05/05/YF3iBd.jpg" alt="TCP 拥塞控制"></p><p>TCP 主要通过四个算法来进行拥塞控制：<strong>慢开始</strong>、<strong>拥塞避免</strong>、<strong>快重传</strong>、<strong>快恢复</strong>。</p><p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p><p>为了便于讨论，做如下假设：</p><ul><li>接收方有足够大的接收缓存，因此不会发生流量控制；</li><li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li></ul><p><img src="https://s1.ax1x.com/2020/05/05/YF36C6.png" alt="TCP 拥塞控制"></p><h4 id="1-慢开始与拥塞避免"><a href="#1-慢开始与拥塞避免" class="headerlink" title="1. 慢开始与拥塞避免"></a>1. 慢开始与拥塞避免</h4><p>发送的最初执行慢开始，令 cwnd = 1 ，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p><p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd  增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh ，当 cwnd &gt;=  ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1 。</p><p>如果出现了超时，则令 ssthresh = cwnd / 2 ，然后重新执行慢开始。</p><h4 id="2-快重传与快恢复"><a href="#2-快重传与快恢复" class="headerlink" title="2. 快重传与快恢复"></a>2. 快重传与快恢复</h4><p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2 ，此时收到 M4，应当发送对 M2 的确认。</p><p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3 。</p><p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh ，注意到此时直接进入拥塞避免。</p><p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh 。</p><p><img src="https://s1.ax1x.com/2020/05/05/YF3xVs.png" alt="快重传"></p><h3 id="TCP-粘包-拆包"><a href="#TCP-粘包-拆包" class="headerlink" title="TCP 粘包/拆包"></a>TCP 粘包/拆包</h3><h4 id="什么是-TCP-粘包-拆包？"><a href="#什么是-TCP-粘包-拆包？" class="headerlink" title="什么是 TCP 粘包/拆包？"></a>什么是 TCP 粘包/拆包？</h4><p>TCP 是个“<strong>流</strong>”协议，所谓流，就是没有界限的一串数据。大家可以想想河里的流水，它们是连成一片的，其间并没有分界线。TCP底层并不了解上层业务数据的具体含义，它会根据 TCP 缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被 TCP 拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的 TCP 粘包和拆包问题。</p><h4 id="TCP-粘包-拆包问题说明"><a href="#TCP-粘包-拆包问题说明" class="headerlink" title="TCP 粘包/拆包问题说明"></a>TCP 粘包/拆包问题说明</h4><p>我们可以通过图解对 TCP 粘包和拆包问题进行说明，粘包问题示例如图所示（来源《Netty权威指南》）：</p><p><img src="https://s1.ax1x.com/2020/05/05/YkuBo6.png" alt="TCP 粘包/拆包问题"></p><p>假设客户端分别发送了两个数据包 D1 和 D2 给服务端，由于服务端一次读取到的字节数是不确定的，故可能存在以下 4 种情况。</p><ul><li>服务端分两次读取到了两个独立的数据包，分别是 D1 和 D2 ，没有粘包和拆包；</li><li>服务端一次接收到了两个数据包，D1 和 D2 粘合在一起，被称为 TCP 粘包；</li><li>服务端分两次读取到了两个数据包，第一次读取到了完整的 D1 包和 D2 包的部分内容，第二次读取到了 D2 包的剩余内容，这被称为 TCP 拆包；</li><li>服务端分两次读取到了两个数据包，第一次读取到了 Dl 包的部分内容 D1_1 ，第二次读取到了 D1 包的剩余内容 D1_2 和 D2 包的整包。</li><li>如果此时服务端 TCP 接收滑窗非常小，而数据包 D1 和 D2 比较大，很有可能会发生第 5 种可能，即服务端分多次才能将 D1 和 D2 包接收完全，期间发生多次拆包。</li></ul><h4 id="TCP-粘包-拆包发生的原因"><a href="#TCP-粘包-拆包发生的原因" class="headerlink" title="TCP 粘包/拆包发生的原因"></a>TCP 粘包/拆包发生的原因</h4><p>问题产生的原因有三个，分别如下。</p><ul><li>应用程序 write 写入的字节大小大于套接口发送缓冲区大小；</li><li>进行 MSS（最大报文段长度）大小的 TCP 分段；</li><li>以太网帧的 payload 大于 MTU（最大传输单元） 进行 IP 分片。</li></ul><p><img src="https://s1.ax1x.com/2020/05/05/YkYN4A.png" alt="TCP 粘包/拆包发生的原因"></p><h4 id="粘包问题的解决策略"><a href="#粘包问题的解决策略" class="headerlink" title="粘包问题的解决策略"></a>粘包问题的解决策略</h4><p>由于底层的 TCP 无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，可以归纳如下。</p><ul><li>消息定长，例如每个报文的大小为固定长度 200 字节，如果不够，空位补空格；</li><li>在包尾增加回车换行符进行分割，例如 FTP 协议。</li><li>将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段，通常设计思路为消息头的第一个字段使用 int32 来表示消息的总长度；</li><li>更复杂的应用层协议。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">两张动图-彻底明白TCP的三次握手与四次挥手</a></li><li>《Netty权威指南》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络常见面试题</title>
      <link href="/2020/05/04/408/ji-suan-ji-wang-luo/ji-suan-ji-wang-luo-chang-jian-mian-shi-ti/"/>
      <url>/2020/05/04/408/ji-suan-ji-wang-luo/ji-suan-ji-wang-luo-chang-jian-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络常见面试题"><a href="#计算机网络常见面试题" class="headerlink" title="计算机网络常见面试题"></a>计算机网络常见面试题</h1><h2 id="一-OSI-与-TCP-IP-各层的结构与功能，都有哪些协议？"><a href="#一-OSI-与-TCP-IP-各层的结构与功能，都有哪些协议？" class="headerlink" title="一 OSI 与 TCP/IP 各层的结构与功能，都有哪些协议？"></a>一 OSI 与 TCP/IP 各层的结构与功能，都有哪些协议？</h2><p>学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。</p><p><img src="https://s1.ax1x.com/2020/05/04/YCeSPA.png" alt="计算机网络体系结构"></p><p>结合互联网的情况，自上而下地，非常简要的介绍一下各层的作用。</p><h3 id="1-1-应用层"><a href="#1-1-应用层" class="headerlink" title="1.1 应用层"></a>1.1 应用层</h3><p><strong>应用层（Application Layer）的任务是通过应用进程间的交互来完成特定网络应用。</strong>应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如<strong>域名系统 DNS</strong> ，支持万维网应用的 <strong>HTTP 协议</strong>，支持电子邮件的 <strong>SMTP 协议</strong>等等。我们把应用层交互的数据单元称为报文。</p><p><strong>域名系统</strong></p><blockquote><p>域名系统（Domain Name System）缩写 DNS ，Domain Name 被译为域名，是因特网的一项核心服务，它作为可以将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。</p></blockquote><p><strong>HTTP 协议</strong></p><blockquote><p>超文本传输协议（HTTP，HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网）文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。</p></blockquote><h3 id="1-2-传输层"><a href="#1-2-传输层" class="headerlink" title="1.2 传输层"></a>1.2 传输层</h3><p><strong>传输层（Transport Layer）的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个传输层服务。由于一台主机可同时运行多个线程，因此传输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面传输层的服务，分用和复用相反，是传输层把收到的信息分别交付上面应用层中的相应进程。</p><p><strong>运输层主要使用以下两种协议:</strong></p><ol><li><strong>传输控制协议 TCP</strong>（Transmission Control Protocol）–提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li><li><strong>用户数据报协议 UDP</strong>（User Datagram Protocol）–提供<strong>无连接</strong>的，<strong>尽最大努力</strong>的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li></ol><p><strong>TCP 与 UDP 的对比见问题三。</strong></p><h3 id="1-3-网络层"><a href="#1-3-网络层" class="headerlink" title="1.3 网络层"></a>1.3 网络层</h3><p><strong>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层（Network Layer）的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。</strong>在发送数据时，网络层把传输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong>，简称<strong>数据报</strong>。</p><p>这里要注意：<strong>不要把传输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混</strong>。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p><p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称。</p><p>互联网是由大量的异构（heterogeneous）网络通过<strong>路由器</strong>（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Internet Protocol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP层</strong>。</p><h3 id="1-4-数据链路层"><a href="#1-4-数据链路层" class="headerlink" title="1.4 数据链路层"></a>1.4 数据链路层</h3><p><strong>数据链路层（Data Link Layer）通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong>在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装成帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p><p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。控制信息还使接收端能够检测到所收到的帧中有无差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p><h3 id="1-5-物理层"><a href="#1-5-物理层" class="headerlink" title="1.5 物理层"></a>1.5 物理层</h3><p>在物理层上所传送的数据单位是比特。<br><strong>物理层（Physical Layer）的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</strong> 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p><p>在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的 TCP/IP 并不一定单指 TCP 和 IP 这两个具体的协议，而往往表示互联网所使用的整个 TCP/IP 协议蔟。</p><h3 id="1-6-总结一下"><a href="#1-6-总结一下" class="headerlink" title="1.6 总结一下"></a>1.6 总结一下</h3><p>上面我们对计算机网络的五层体系结构有了初步的了解，下面附送一张七层体系结构图总结一下。</p><p><img src="https://s1.ax1x.com/2020/05/04/YCnlEF.gif" alt="七层体系结构图"></p><h2 id="二-TCP-三次握手和四次挥手（面试常客）"><a href="#二-TCP-三次握手和四次挥手（面试常客）" class="headerlink" title="二 TCP 三次握手和四次挥手（面试常客）"></a>二 TCP 三次握手和四次挥手（面试常客）</h2><p>为了准确无误地把数据送达目标处，TCP 协议采用了三次握手策略。</p><h3 id="2-1-TCP-三次握手漫画图解"><a href="#2-1-TCP-三次握手漫画图解" class="headerlink" title="2.1 TCP 三次握手漫画图解"></a>2.1 TCP 三次握手漫画图解</h3><p>如下图所示，下面的两个机器人通过三次握手确定了对方能正确接收和发送消息（图片来源：《图解HTTP》）。<br><img src="https://s1.ax1x.com/2020/05/04/YCn6gI.png" alt="TCP 三次握手"></p><p><strong>简单示意图：</strong><br><img src="https://s1.ax1x.com/2020/05/04/YCuSPJ.jpg" alt="TCP 三次握手"></p><ul><li><strong>一次握手：</strong>客户端–发送带有 SYN 标志的数据包–服务端</li><li><strong>二次握手：</strong>服务端–发送带有 SYN/ACK 标志的数据包–客户端</li><li><strong>三次握手：</strong>客户端–发送带有带有 ACK 标志的数据包–服务端</li></ul><h3 id="2-2-为什么要三次握手？"><a href="#2-2-为什么要三次握手？" class="headerlink" title="2.2 为什么要三次握手？"></a>2.2 为什么要三次握手？</h3><p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p><p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常。</p><p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p><p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常。</p><p>所以<strong>三次握手</strong>就能确认双发收发功能都正常，缺一不可。</p><h3 id="2-3-为什么要传回-SYN-？"><a href="#2-3-为什么要传回-SYN-？" class="headerlink" title="2.3 为什么要传回 SYN ？"></a>2.3 为什么要传回 SYN ？</h3><p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p><blockquote><p>SYN（同步） 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK（确认）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p></blockquote><h3 id="2-4-传了-SYN-，为啥还要传-ACK-？"><a href="#2-4-传了-SYN-，为啥还要传-ACK-？" class="headerlink" title="2.4 传了 SYN ，为啥还要传 ACK ？"></a>2.4 传了 SYN ，为啥还要传 ACK ？</h3><p>双方通信无误必须是两者互相发送信息都无误。传了 SYN ，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p><h3 id="2-5-TCP-四次挥手"><a href="#2-5-TCP-四次挥手" class="headerlink" title="2.5 TCP 四次挥手"></a>2.5 TCP 四次挥手</h3><p><img src="https://s1.ax1x.com/2020/05/04/YCKnTU.jpg" alt="TCP 四次挥手"></p><p>断开一个 TCP 连接则需要“四次挥手”：</p><ul><li><strong>一次挥手：</strong>客户端-发送一个 FIN ，用来关闭客户端到服务器的数据传送。</li><li><strong>二次挥手：</strong>服务器-收到这个 FIN ，它发回一 个 ACK ，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号。</li><li><strong>三次挥手：</strong>服务器-关闭与客户端的连接，发送一个 FIN/ACK 给客户端。</li><li><strong>四次挥手：</strong>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加 1 。</li></ul><h3 id="2-6-为什么要四次挥手？"><a href="#2-6-为什么要四次挥手？" class="headerlink" title="2.6 为什么要四次挥手？"></a>2.6 为什么要四次挥手？</h3><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p><blockquote><p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p></blockquote><p>上面讲的比较概括，推荐一篇讲的比较细致的文章：<a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">两张动图-彻底明白TCP的三次握手与四次挥手</a></p><h3 id="2-7-为什么客户端最后还要等待-2MSL-？"><a href="#2-7-为什么客户端最后还要等待-2MSL-？" class="headerlink" title="2.7 为什么客户端最后还要等待 2MSL ？"></a>2.7 为什么客户端最后还要等待 2MSL ？</h3><p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的 MSL 值。</p><ul><li>第一，保证客户端发送的最后一个 ACK 报文能够到达服务器，因为这个 ACK 报文可能丢失，站在服务器的角度看来，我已经发送了 FIN+ACK 报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个 2MSL 时间段内收到这个重传的报文，接着给出回应报文，并且会重启 2MSL 计时器。</li><li>第二，防止类似于“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个 2MSL 时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</li></ul><h3 id="2-8-为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#2-8-为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="2.8 为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a>2.8 为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h3><p>建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。</p><p>而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。</p><h3 id="2-9-如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#2-9-如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="2.9 如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>2.9 如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><p><strong>TCP 设有一个保活计时器。</strong>显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为 2 小时，若 2 小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔 75 秒发送一次。若一连发送 10 个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h2 id="三-TCP-、UDP-协议的区别"><a href="#三-TCP-、UDP-协议的区别" class="headerlink" title="三 TCP 、UDP 协议的区别"></a>三 TCP 、UDP 协议的区别</h2><p><img src="https://s1.ax1x.com/2020/05/04/YCMKDP.jpg" alt="TCP、UDP 协议的区别"></p><p><strong>UDP</strong> 在传送数据之前不需要先建立连接，远程主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等。</p><blockquote><p>UDP 首部：源端口号、目标端口号、包长度（首部长度+数据长度）、校验和。</p></blockquote><p><strong>TCP</strong> 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（ TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这难免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p><h2 id="四-TCP-协议如何保证可靠传输？"><a href="#四-TCP-协议如何保证可靠传输？" class="headerlink" title="四 TCP 协议如何保证可靠传输？"></a>四 TCP 协议如何保证可靠传输？</h2><ul><li><p>应用数据被分割成 TCP 认为最适合发送的数据块。 </p></li><li><p>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 </p></li><li><p><strong>校验和：</strong>TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到端的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 </p></li><li><p>TCP 的接收端会丢弃重复的数据。 </p></li><li><p><strong>流量控制：</strong>TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。（ TCP 利用滑动窗口实现流量控制）</p></li><li><p><strong>拥塞控制：</strong>当网络拥塞时，减少数据的发送。</p></li><li><p><strong>ARQ 协议：</strong>也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p></li><li><p><strong>超时重传：</strong>当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 </p></li></ul><h3 id="4-1-ARQ-协议"><a href="#4-1-ARQ-协议" class="headerlink" title="4.1 ARQ 协议"></a>4.1 ARQ 协议</h3><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用<strong>确认和超时</strong>这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ 包括<strong>停止等待 ARQ 协议</strong>和<strong>连续 ARQ 协议</strong>。</p><h4 id="4-1-1-停止等待-ARQ-协议"><a href="#4-1-1-停止等待-ARQ-协议" class="headerlink" title="4.1.1 停止等待 ARQ 协议"></a>4.1.1 停止等待 ARQ 协议</h4><ul><li>停止等待 ARQ 协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK ）。如果过了一段时间（超时时间）后，还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。</li><li>在停止等待 ARQ 协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</li></ul><p><strong>优点：</strong> 简单。</p><p><strong>缺点：</strong> 信道利用率低，等待时间长。</p><p><strong>1) 无差错情况：</strong></p><p>发送方发送分组，接收方在规定时间内收到，并且回复确认，发送方再次发送。</p><p><strong>2) 出现差错情况（超时重传）：</strong></p><p>停止等待 ARQ 协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待 ARQ 协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。<strong>连续 ARQ 协议</strong> 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p><p><strong>3) 确认丢失和确认迟到：</strong></p><ul><li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：<ul><li>丢弃这个重复的 M1 消息，不向上层交付。 </li><li>向 A 发送确认消息。（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。</li></ul></li><li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（ B 收到了 2 份 M1 ）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（ A 也收到了 2 份确认消息）。处理如下：<ul><li>A 收到重复的确认后，直接丢弃。</li><li>B 收到重复的 M1 后，也直接丢弃重复的 M1 。</li></ul></li></ul><h4 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a>连续 ARQ 协议</h4><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p><p><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</p><p><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条消息，中间第三条丢失（ 3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 <code>Go-Back-N</code>（回退 N ），表示需要退回来重传已经发送过的 N 个消息。</p><h3 id="4-2-滑动窗口和流量控制"><a href="#4-2-滑动窗口和流量控制" class="headerlink" title="4.2 滑动窗口和流量控制"></a>4.2 滑动窗口和流量控制</h3><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0 ，则发送方不能发送数据。</p><h3 id="4-3-拥塞控制"><a href="#4-3-拥塞控制" class="headerlink" title="4.3 拥塞控制"></a>4.3 拥塞控制</h3><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个<strong>全局性</strong>的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口（cwnd）</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p><p>TCP 的拥塞控制采用了四种算法，即 <strong>慢开始</strong>、<strong>拥塞避免</strong>、<strong>快重传</strong>和<strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM ），以减少网络拥塞的发生。</p><p><img src="https://s1.ax1x.com/2020/05/05/YF36C6.png" alt="TCP 拥塞控制"></p><ul><li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 <strong>1</strong> ，每经过一个传播轮次，cwnd 加倍。</li><li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1 。</li><li><strong>快重传与快恢复：</strong>在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR ，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR ，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到<strong>三个</strong>重复确认，它会假定下一个数据段丢失了，并立即重传这些丢失的数据段。有了 FRR ，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li></ul><h2 id="五-在浏览器中输入-URL-地址到显示主页的过程（面试常客）"><a href="#五-在浏览器中输入-URL-地址到显示主页的过程（面试常客）" class="headerlink" title="五  在浏览器中输入 URL 地址到显示主页的过程（面试常客）"></a>五  在浏览器中输入 URL 地址到显示主页的过程（面试常客）</h2><blockquote><p>打开一个网页，整个过程会使用哪些协议？</p></blockquote><p>图解（图片来源：《图解HTTP》）：</p><p><img src="https://s1.ax1x.com/2020/05/04/YCG0V1.jpg" alt=""></p><p>总体来说分为以下几个过程：</p><ol><li>DNS 解析</li><li>TCP 连接：三次握手</li><li>发送 HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>连接结束：四次挥手</li></ol><p>具体可以参考下面这篇文章：</p><ul><li><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">前端经典面试题: 从输入URL到页面加载发生了什么？</a></li></ul><p><strong>参考回答：</strong></p><p><img src="https://s1.ax1x.com/2020/05/04/YCtegO.png" alt="简单版"></p><p><img src="https://s1.ax1x.com/2020/05/04/YCtKDH.png" alt="详细版"></p><p><img src="https://s1.ax1x.com/2020/05/04/YCrKr6.png" alt="详细版"></p><p><img src="https://s1.ax1x.com/2020/05/04/YCrlVO.png" alt="DNS 查找过程"></p><h2 id="六-状态码"><a href="#六-状态码" class="headerlink" title="六 状态码"></a>六 状态码</h2><p><img src="https://s1.ax1x.com/2020/05/04/YCr3Ie.png" alt="状态码"></p><h2 id="七-各种协议与-HTTP-协议之间的关系"><a href="#七-各种协议与-HTTP-协议之间的关系" class="headerlink" title="七 各种协议与 HTTP 协议之间的关系"></a>七 各种协议与 HTTP 协议之间的关系</h2><p>一般面试官会通过这样的问题来考察你对计算机网络知识体系的理解。</p><p>图片来源：《图解HTTP》</p><p><img src="https://s1.ax1x.com/2020/05/04/YCrasP.png" alt="各种协议与 HTTP 协议之间的关系"></p><h2 id="八-HTTP-长连接、短连接"><a href="#八-HTTP-长连接、短连接" class="headerlink" title="八  HTTP 长连接、短连接"></a>八  HTTP 长连接、短连接</h2><p>在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。</p><p>而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码：</p><pre class=" language-html"><code class="language-html">Connection: keep-alive</code></pre><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache ）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><p><strong>HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。</strong> </p><p>参考： <a href="https://www.cnblogs.com/gotodsp/p/6366163.html" target="_blank" rel="noopener">《HTTP长连接、短连接究竟是什么？》</a></p><h2 id="九-HTTP-是不保存状态的协议，如何保存用户状态？"><a href="#九-HTTP-是不保存状态的协议，如何保存用户状态？" class="headerlink" title="九 HTTP 是不保存状态的协议，如何保存用户状态？"></a>九 HTTP 是不保存状态的协议，如何保存用户状态？</h2><p>HTTP 是一种不保存状态，即无状态（Stateless）协议。也就是说 HTTP  协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？<strong>Session</strong> 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session ，过了时间限制，就会销毁这个 Session ）。</p><p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库（比如使用内存数据库 Redis 保存）。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p><p><strong>Cookie 被禁用怎么办?</strong></p><p>最常用的就是利用 <strong>URL 重写</strong>把 Session ID 直接附加在 URL 路径的后面。</p><p><img src="https://s1.ax1x.com/2020/05/04/YCroi4.png" alt="HTTP 是无状态协议"></p><h2 id="十-Cookie-的作用是什么？和-Session-有什么区别？"><a href="#十-Cookie-的作用是什么？和-Session-有什么区别？" class="headerlink" title="十 Cookie 的作用是什么？和 Session 有什么区别？"></a>十 Cookie 的作用是什么？和 Session 有什么区别？</h2><p>Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p><p> <strong>Cookie 一般用来保存用户信息。</strong>比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可（为了安全考虑，重新登录一般要将 Token 重写）；③登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p><p>Cookie 数据保存在客户端（浏览器端），Session 数据保存在服务器端。</p><p>Cookie 存储在客户端中，而 Session 存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p><h2 id="十一-HTTP-1-0-和-HTTP-1-1-的主要区别是什么？"><a href="#十一-HTTP-1-0-和-HTTP-1-1-的主要区别是什么？" class="headerlink" title="十一 HTTP 1.0 和 HTTP 1.1 的主要区别是什么？"></a>十一 HTTP 1.0 和 HTTP 1.1 的主要区别是什么？</h2><blockquote><p>这部分回答引用这篇文章 <a href="https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?" target="_blank" rel="noopener">HTTP 1.0、HTTP 1.1 和 HTTP 2.0 的区别</a> 的一些内容。</p></blockquote><p>HTTP 1.0 最早在网页中使用是在 1996 年，那个时候只是使用一些较为简单的网页上和网络请求上，而 HTTP 1.1 则在 1999 年才开始广泛应用于现在的各大浏览器网络请求中，同时 HTTP 1.1 也是当前使用最为广泛的 HTTP 协议。 主要区别主要体现在：</p><ol><li><strong>长连接：在 HTTP/1.0 中，默认使用的是短连接</strong>，也就是说每次请求都要重新建立一次连接。HTTP 是基于 TCP/IP 协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。<strong>HTTP 1.1 起，默认使用长连接</strong>，默认开启 <code>Connection: keep-alive</code> 。<strong>HTTP/1.1 的持续连接有非流水线方式和流水线方式</strong> 。流水线方式是客户在收到 HTTP 的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li><li><strong>错误状态响应码：</strong>在HTTP 1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>缓存处理：</strong>在 HTTP 1.0 中主要使用 header 里的 If-Modified-Since ，Expires 来做为缓存判断的标准，HTTP 1.1 则引入了更多的缓存控制策略例如 <code>Entity tag</code> ，<code>If-Unmodified-Since</code> , <code>If-Match</code> , <code>If-None-Match</code> 等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用：</strong>HTTP 1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP 1.1 则在请求头引入了 <code>range</code> 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li></ol><blockquote><p>推荐另一篇关于此问题回答的好文：<a href="https://www.jianshu.com/p/7bfec28236c3" target="_blank" rel="noopener">HTTP 1.0、HTTP 1.1 和 HTTP 2.0 的区别</a></p></blockquote><h2 id="十二-URI-和-URL-的区别是什么"><a href="#十二-URI-和-URL-的区别是什么" class="headerlink" title="十二 URI 和 URL 的区别是什么?"></a>十二 URI 和 URL 的区别是什么?</h2><ul><li>URI（Uniform Resource Identifier）是统一资源标志符，可以唯一标识一个资源。</li><li>URL（Uniform Resource Location）是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI ，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li></ul><p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI ，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p><h2 id="十三-HTTP-和-HTTPS-的区别？"><a href="#十三-HTTP-和-HTTPS-的区别？" class="headerlink" title="十三 HTTP 和 HTTPS 的区别？"></a>十三 HTTP 和 HTTPS 的区别？</h2><ol><li><p><strong>端口：</strong>HTTP 的 URL 由 “http://” 起始且默认使用端口 80 ，而 HTTPS 的 URL 由 “https://” 起始且默认使用端口 443 。</p></li><li><p><strong>安全性和资源消耗：</strong>HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</p><ul><li><p><strong>对称加密：</strong>密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有 DES 、AES 等。</p></li><li><p><strong>非对称加密：</strong>密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有 RSA、DSA 等。</p></li></ul></li></ol><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>非常推荐大家看一下 《图解HTTP》 这本书，这本书页数不多，但是内容很是充实，不管是用来系统的掌握网络方面的一些知识还是说纯粹为了应付面试都有很大帮助。下面的一些文章只是参考。大二学习这门课程的时候，我们使用的教材是 《计算机网络自顶向下方法》（谢希仁编著），不推荐大家看这本教材，书非常厚而且知识偏理论，不确定大家能不能心平气和的读完。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">两张动图-彻底明白TCP的三次握手与四次挥手</a></p></li><li><p><a href="https://blog.csdn.net/qq_16209077/article/details/52718250" target="_blank" rel="noopener">TCP协议如何保证可靠传输</a></p></li><li><p><a href="https://blog.csdn.net/zixiaomuwu/article/details/60965466" target="_blank" rel="noopener">简明理解三次握手和四次挥手</a></p></li><li><p><a href="https://blog.csdn.net/turn__back/article/details/73743641" target="_blank" rel="noopener">TCP可靠传输的工作原理-停止等待&amp;连续的ARQ</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?" target="_blank" rel="noopener">HTTP 1.0、HTTP 1.1 和 HTTP 2.0 的区别</a></p></li><li><p><a href="https://www.jianshu.com/p/7bfec28236c3" target="_blank" rel="noopener">HTTP 1.0、HTTP 1.1 和 HTTP 2.0 的区别</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线上CPU打到100%解决方案</title>
      <link href="/2020/05/04/shi-jian/xian-shang-cpu-da-dao-100-jie-jue-fang-an/"/>
      <url>/2020/05/04/shi-jian/xian-shang-cpu-da-dao-100-jie-jue-fang-an/</url>
      
        <content type="html"><![CDATA[<h2 id="线上-CPU-打到-100-解决方案"><a href="#线上-CPU-打到-100-解决方案" class="headerlink" title="线上 CPU 打到 100% 解决方案"></a>线上 CPU 打到 100% 解决方案</h2><p>事情是这样的……</p><p>我和小组伙伴最近负责的系统今天上线了，因为涉及到的业务特别多所以选择白天发布，怕出问题找不到对应的负责人。</p><p><img src="https://s1.ax1x.com/2020/05/04/Y9ssbT.png" alt=""></p><p>看到 15:25 那个 Full GC 没，我发布上去一分钟不到就疯狂 GC ，我当时就吓尿了，马上点了回滚按钮。</p><p>而且我发现 CPU 几乎在我发布的瞬间，直接打到了峰值。</p><p><img src="https://s1.ax1x.com/2020/05/04/Y9scaF.png" alt=""></p><p>所幸只发布了一台，我紧张的望向了周围，发现周围的同事没注意到我，我顿时没那么紧张了，拿起桌上用剩下的纸巾搽掉了我鬓角马上留下的汗水。</p><p>我其实已经知道大概是什么问题了，无非就是死循环，或者大对象什么的。</p><p>但是我还是想找个人承担这个锅。</p><p><img src="https://s1.ax1x.com/2020/05/04/Y9sHaD.png" alt=""></p><p>我马上找到 ** ，我问他：你刚才是不是点过我的系统？</p><p>他说：对啊，我刚才点了，我本来就经常使用你的系统，咋了？（刚好正中下怀嘻嘻）</p><p>我说过多少次啊，叫你不要乱点，这已经不是第一次了，现在把我的系统点坏了，怎么办？都怪你。</p><p>他：委屈巴巴一副要哭的样子。</p><p><img src="https://s1.ax1x.com/2020/05/04/Y9ymLV.gif" alt=""></p><p>我：诶，算了算了，下次注意哈，我去排查下什么情况，看看你点坏了哪里。</p><p>他：* 哥真好，* 哥真棒，* 哥我爱你。</p><p>总算是找到背锅侠了，我就开始排查问题吧。</p><p>注：以下代码都是伪代码，为了还原排查过程。</p><p>一般 CPU 100% 疯狂 GC ，都是死循环的锅，那怎么排查呢？</p><p>先进服务器，用 <strong>top -c</strong> 命令找出当前进程的运行列表。</p><p>按一下 <strong>P</strong> 可以按照 CPU 使用率进行排序。</p><p>显示 Java 进程 PID 为 2609 的 Java 进程消耗最高。</p><p><img src="https://s1.ax1x.com/2020/05/04/Y96F0K.png" alt=""></p><p>然后我们需要根据 PID 查出 CPU 里面消耗最高的进程。</p><p>使用命令 <strong>top -Hp 2609</strong> 找出这个进程下面的线程，继续按 <strong>P</strong> 排序。</p><p>可以看到 2854 CPU 消耗最高。</p><p><img src="https://s1.ax1x.com/2020/05/04/Y96EkD.png" alt=""></p><p>2854 是十进制的，我们需要转换为十六进制，转换结果：b26</p><p>接下来就需要导出我们的进程快照了，看看这个线程做了啥：</p><pre class=" language-bash"><code class="language-bash">jstack -l 2609 <span class="token operator">></span> ./2609.stack</code></pre><p>再用 <strong>grep</strong> 查看一下线程在文件里做了啥：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> 2609.stack <span class="token operator">|</span><span class="token function">grep</span> <span class="token string">'b26'</span> -C 8</code></pre><p>我这里就随便定位一个，基本上这样查都可以定位到你死循环的那个类，那一行，这里你还可以在 <strong>jstack</strong> 出来的文件中看到很多熟悉的名词，至于是啥，就当是个课后作业了。</p><p><img src="https://s1.ax1x.com/2020/05/04/Y968AS.png" alt=""></p><p>我写了个伪代码，看看当时我为啥会写出这个死循环，对了当时我上线的是预发，也是后台系统非线上的，虽然都是自己在玩，但是大家还是要引以为戒。</p><p><img src="https://s1.ax1x.com/2020/05/04/Y96JhQ.png" alt=""></p><p>我当时写了个代码准备去查出数据库的数据，订正下日期，仔细看没问题，但是我忘了数据库的偏移值自己去计算了，因为以前都是框架，自己临时写的就没管。</p><p>导致每次都能查出 10 个数据，在最后判断的时候就一直 True 不退出了，其实最后会退出，但是得循环很多次。</p><p>我这里退出的逻辑比较取巧，就是想着最后一次查询肯定跟我的页数不一样，那就是最后一页了，那我就处理完退出。</p><p>结果没想到也是个坑了。</p><p>大家写的时候也要注意很多小坑，还有代码一定要本地测了再发，我这次其实是本地发现了，然后想着干脆就写个排查经过的吧，机制吧。</p><p>这个 Demo 顺便带大家温习一下线上 100% CPU 故障的排查，下次我可能搞点内存泄露，集群宕机什么的故障，这样就有素材了呀。</p><p>如果真出问题，第一时间找个 ** 这样的背锅侠，排查过程自己去电脑上操作一下。</p>]]></content>
      
      
      <categories>
          
          <category> 实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPU </tag>
            
            <tag> 故障排查 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis分布式锁</title>
      <link href="/2020/05/03/fen-bu-shi/redis-fen-bu-shi-suo/"/>
      <url>/2020/05/03/fen-bu-shi/redis-fen-bu-shi-suo/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-分布式锁"><a href="#Redis-分布式锁" class="headerlink" title="Redis 分布式锁"></a>Redis 分布式锁</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一章节我提到了基于 ZK 分布式锁的实现，这章节就来说一下基于 Redis 的分布式锁实现吧。</p><ul><li>ZK 实现分布式锁的传送门：<a href="https://www.niewenjun.com/2020/05/02/fen-bu-shi/zookeeper-fen-bu-shi-suo/">ZooKeeper分布式锁</a></li></ul><p>在开始提到 Redis 分布式锁之前，我想跟大家聊点 Redis 的基础知识。</p><p>说一下 Redis 的两个命令：</p><pre class=" language-bash"><code class="language-bash">SETNX key value</code></pre><p><code>setnx</code> 是 <strong>SET if Not eXists</strong>（如果不存在，则 SET ）的简写。</p><p><img src="https://s1.ax1x.com/2020/05/02/Jx6nYR.png" alt=""></p><p>用法如图，如果不存在，<code>set</code> 成功返回 int 型的 1 ，否则失败返回 0 。</p><pre class=" language-bash"><code class="language-bash">SETEX key seconds value</code></pre><p>将值 <code>value</code> 关联到 <code>key</code> ，并将 <code>key</code> 的生存时间设为 <code>seconds</code> (以秒为单位)。</p><p>如果 <code>key</code> 已经存在，<code>setex</code> 命令将覆写旧值。</p><p>有小伙伴肯定会疑惑万一 <code>set value</code> 成功 <code>set time</code> 失败，那不就傻了么，这啊 Redis 官网想到了。</p><p><code>setex</code> 是一个原子性（Atomic）操作，关联值和设置生存时间两个动作会在同一时间内完成。</p><p><img src="https://s1.ax1x.com/2020/05/02/Jx61OO.png" alt=""></p><p>我设置了 10 秒的失效时间，<code>ttl</code> 命令可以查看倒计时，负的说明已经到期了。</p><p>跟大家讲这两个命名也是有原因的，因为它们是 Redis 实现分布式锁的关键。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>开始前还是看看场景：</p><p><img src="https://s1.ax1x.com/2020/05/02/Jx6JTH.png" alt=""></p><p>我依然是创建了很多个线程去扣减库存 <code>inventory</code> ，不出意外的库存扣减顺序变了，最终的结果也是不对的。</p><p>单机加 <code>synchronized</code> 或者 <code>Lock</code> 这些常规操作我就不说了好吧，结果肯定是对的。</p><p><img src="https://s1.ax1x.com/2020/05/03/Jx6NtA.png" alt="ReentrantLock"></p><p>我先实现一个简单的 Redis 锁，然后我们再实现分布式锁，可能更方便大家的理解。</p><p>还记得上面我说过的命令么，实现一个单机的其实比较简单，你们先思考一下，别往下看。</p><h3 id="setnx"><a href="#setnx" class="headerlink" title="setnx"></a>setnx</h3><p><img src="https://s1.ax1x.com/2020/05/03/Jx6BX8.png" alt="setnx"></p><p>可以看到，第一个成功了，没释放锁，后面的都失败了，至少顺序问题问题是解决了，只要加锁，释放，后面的拿到，释放，如此循环，就能保证按照顺序执行。</p><p>但是你们也发现问题了，还是一样的，第一个仔 <code>set</code> 成功了，但是突然挂了，那锁就一直在那无法得到释放，后面的线程也永远得不到锁，又死锁了。</p><p>所以…</p><h3 id="setex"><a href="#setex" class="headerlink" title="setex"></a>setex</h3><p>知道我之前说这个命令的原因了吧，设置一个过期时间，就算线程 1 挂了，也会在失效时间到了，自动释放。</p><p>我这里就用到了 <code>nx</code> 和 <code>px</code> 的结合参数，就是 <code>set</code> 值并且加了过期时间，这里我还设置了一个过期时间，就是这时间内如果第二个没拿到第一个的锁，就退出阻塞了，因为可能是客户端断连了。</p><p><img src="https://s1.ax1x.com/2020/05/03/Jx6qhR.png" alt="setex"></p><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>整体加锁的逻辑比较简单，大家基本上都能看懂，不过我拿到当前时间去减开始时间的操作感觉有点笨， <code>System.currentTimeMillis()</code> 消耗很大的。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 加锁 * @param id * @return */</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">lock</span><span class="token punctuation">(</span>String id<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Long start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//SET命令返回OK ，则证明获取锁成功</span>            String lock <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>LOCK_KEY<span class="token punctuation">,</span> id<span class="token punctuation">,</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"OK"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//否则循环等待，在timeout时间内仍未获取到锁，则获取失败</span>            <span class="token keyword">long</span> l <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">>=</span> timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        jedis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>System.currentTimeMillis()</code> 消耗大，每个线程进来都这样，我之前写代码，就会在服务器启动的时候，开一个线程不断去拿，调用方直接获取值就好了，不过也不是最优解，日期类还是有很多好方法的。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TimeServcie</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">long</span> time<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">long</span> cur <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">setTime</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> time<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setTime</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TimeServcie<span class="token punctuation">.</span>time <span class="token operator">=</span> time<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>解锁的逻辑更加简单，就是一段 <strong>Lua</strong> 的拼装，把 Key 做了删除。</p><p>你们发现没，我上面加锁解锁都用了 <strong>UUID</strong> ，这就是为了保证，谁加锁了谁解锁，要是你删掉了我的锁，那不乱套了嘛。</p><p><strong>Lua</strong> 是原子性的，也比较简单，就是判断一下 Key 和我们参数是否相等，是的话就删除，返回成功 1 ，0 就是失败。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 解锁 * @param id * @return */</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">unlock</span><span class="token punctuation">(</span>String id<span class="token punctuation">)</span> <span class="token punctuation">{</span>    String script <span class="token operator">=</span>            <span class="token string">"if redis.call('get',KEYS[1]) == ARGV[1] then"</span> <span class="token operator">+</span>                    <span class="token string">"   return redis.call('del',KEYS[1]) "</span> <span class="token operator">+</span>                    <span class="token string">"else"</span> <span class="token operator">+</span>                    <span class="token string">"   return 0 "</span> <span class="token operator">+</span>                    <span class="token string">"end"</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        String result <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span>script<span class="token punctuation">,</span> Collections<span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span>LOCK_KEY<span class="token punctuation">)</span><span class="token punctuation">,</span> Collections<span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"1"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        jedis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>我们可以用我们写的 Redis 锁试试效果，可以看到都按照顺序去执行了</p><p><img src="https://s1.ax1x.com/2020/05/03/Jx2nYj.png" alt="验证"></p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>大家是不是觉得完美了，但是上面的锁，有不少瑕疵的，我没思考很多点，你或许可以思考一下。</p><p>而且，锁一般都是需要可重入的，上面的线程都是执行完了就释放了，无法再次进入了，进去也是重新加锁了，对于一个锁的设计来说肯定不是很合理的。</p><p>我不打算手写，因为都有现成的，别人帮我们写好了。</p><h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><p><code>Redisson</code> 的锁，就实现了可重入了，但是他的源码比较晦涩难懂。</p><p>使用起来很简单，因为他们底层都封装好了，你连接上你的 Redis 客户端，他帮你做了我上面写的一切，然后更完美。</p><p>简单看看他的使用吧，跟正常使用 Lock 没啥区别。</p><pre class=" language-java"><code class="language-java">ThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span>        <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>inventory<span class="token punctuation">,</span> inventory<span class="token punctuation">,</span> 10L<span class="token punctuation">,</span> SECONDS<span class="token punctuation">,</span> linkedBlockingQueue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Config config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>config<span class="token punctuation">.</span><span class="token function">useSingleServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token string">"redis://127.0.0.1:6379"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">final</span> RedissonClient client <span class="token operator">=</span> Redisson<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">final</span> RLock lock <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"lock1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> NUM<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    threadPoolExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            inventory<span class="token operator">--</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>inventory<span class="token punctuation">)</span><span class="token punctuation">;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">long</span> end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行线程数:"</span> <span class="token operator">+</span> NUM <span class="token operator">+</span> <span class="token string">"   总耗时:"</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"  库存数为:"</span> <span class="token operator">+</span> inventory<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面可以看到我用到了 <code>getLock()</code> ，其实就是获取一个锁的实例。</p><p><code>RedissionLock</code> 也没做啥，就是熟悉的初始化。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> RLock <span class="token function">getLock</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RedissonLock</span><span class="token punctuation">(</span>connectionManager<span class="token punctuation">.</span><span class="token function">getCommandExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">RedissonLock</span><span class="token punctuation">(</span>CommandAsyncExecutor commandExecutor<span class="token punctuation">,</span> String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>commandExecutor<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//命令执行器</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>commandExecutor <span class="token operator">=</span> commandExecutor<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//UUID字符串</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> commandExecutor<span class="token punctuation">.</span><span class="token function">getConnectionManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//内部锁过期时间</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>internalLockLeaseTime <span class="token operator">=</span> commandExecutor<span class="token punctuation">.</span>                <span class="token function">getConnectionManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCfg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLockWatchdogTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>entryName <span class="token operator">=</span> id <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="加锁-1"><a href="#加锁-1" class="headerlink" title="加锁"></a>加锁</h3><p>有没有发现很多跟 Lock 很多相似的地方呢？</p><p>尝试加锁，拿到当前线程，然后我开头说的 <code>ttl</code> 也看到了，是不是一切都是那么熟悉？</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token keyword">long</span> leaseTime<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//当前线程ID</span>    <span class="token keyword">long</span> threadId <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//尝试获取锁</span>    Long ttl <span class="token operator">=</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>leaseTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果ttl为空，则证明获取锁成功</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ttl <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//如果获取锁失败，则订阅到对应这个锁的channel</span>    RFuture<span class="token operator">&lt;</span>RedissonLockEntry<span class="token operator">></span> future <span class="token operator">=</span> <span class="token function">subscribe</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>    commandExecutor<span class="token punctuation">.</span><span class="token function">syncSubscription</span><span class="token punctuation">(</span>future<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//再次尝试获取锁</span>            ttl <span class="token operator">=</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>leaseTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//ttl为空，说明成功获取锁，返回</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ttl <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//ttl大于0 则等待ttl时间后继续尝试获取</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ttl <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">getEntry</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>ttl<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token function">getEntry</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//取消对channel的订阅</span>        <span class="token function">unsubscribe</span><span class="token punctuation">(</span>future<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//get(lockAsync(leaseTime, unit));</span><span class="token punctuation">}</span></code></pre><h3 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h3><p>获取锁的时候，也比较简单，你可以看到，他也是不断刷新过期时间，跟我上面不断去拿当前时间，校验过期是一个道理，只是我比较粗糙。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> RFuture<span class="token operator">&lt;</span>Long<span class="token operator">></span> <span class="token function">tryAcquireAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> leaseTime<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//如果带有过期时间，则按照普通方式获取锁</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>leaseTime <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">tryLockInnerAsync</span><span class="token punctuation">(</span>leaseTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">,</span> RedisCommands<span class="token punctuation">.</span>EVAL_LONG<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//先按照30秒的过期时间来执行获取锁的方法</span>    RFuture<span class="token operator">&lt;</span>Long<span class="token operator">></span> ttlRemainingFuture <span class="token operator">=</span> <span class="token function">tryLockInnerAsync</span><span class="token punctuation">(</span>        commandExecutor<span class="token punctuation">.</span><span class="token function">getConnectionManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCfg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLockWatchdogTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span> threadId<span class="token punctuation">,</span> RedisCommands<span class="token punctuation">.</span>EVAL_LONG<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果还持有这个锁，则开启定时任务不断刷新该锁的过期时间</span>    ttlRemainingFuture<span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FutureListener</span><span class="token operator">&lt;</span>Long<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operationComplete</span><span class="token punctuation">(</span>Future<span class="token operator">&lt;</span>Long<span class="token operator">></span> future<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>future<span class="token punctuation">.</span><span class="token function">isSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            Long ttlRemaining <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">getNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// lock acquired</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ttlRemaining <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">scheduleExpirationRenewal</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ttlRemainingFuture<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="底层加锁逻辑"><a href="#底层加锁逻辑" class="headerlink" title="底层加锁逻辑"></a>底层加锁逻辑</h3><p>你可能会想这么多操作，在一起不是原子性不还是有问题么？</p><p>大佬们肯定想得到呀，所以还是 <strong>LUA</strong> ，它使用了 <strong>Hash</strong> 的数据结构。</p><p>主要是判断锁是否存在，不存在就设置过期时间，如果锁已经存在了，那对比一下线程，线程是一个那就证明可以重入，锁在了，但是不是当前线程，证明别人还没释放，那就把剩余时间返回，加锁失败。</p><p>是不是有点绕，多理解一遍。</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span>T<span class="token operator">></span> RFuture<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">tryLockInnerAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> leaseTime<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">,</span>                                 <span class="token keyword">long</span> threadId<span class="token punctuation">,</span> RedisStrictCommand<span class="token operator">&lt;</span>T<span class="token operator">></span> command<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//过期时间</span>        internalLockLeaseTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toMillis</span><span class="token punctuation">(</span>leaseTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> commandExecutor<span class="token punctuation">.</span><span class="token function">evalWriteAsync</span><span class="token punctuation">(</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> LongCodec<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">,</span> command<span class="token punctuation">,</span>                  <span class="token comment" spellcheck="true">//如果锁不存在，则通过hset设置它的值，并设置过期时间</span>                  <span class="token string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> <span class="token operator">+</span>                      <span class="token string">"redis.call('hset', KEYS[1], ARGV[2], 1); "</span> <span class="token operator">+</span>                      <span class="token string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> <span class="token operator">+</span>                      <span class="token string">"return nil; "</span> <span class="token operator">+</span>                  <span class="token string">"end; "</span> <span class="token operator">+</span>                  <span class="token comment" spellcheck="true">//如果锁已存在，并且锁的是当前线程，则通过hincrby给数值递增1</span>                  <span class="token string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> <span class="token operator">+</span>                      <span class="token string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> <span class="token operator">+</span>                      <span class="token string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> <span class="token operator">+</span>                      <span class="token string">"return nil; "</span> <span class="token operator">+</span>                  <span class="token string">"end; "</span> <span class="token operator">+</span>                  <span class="token comment" spellcheck="true">//如果锁已存在，但并非本线程，则返回过期时间ttl</span>                  <span class="token string">"return redis.call('pttl', KEYS[1]);"</span><span class="token punctuation">,</span>        Collections<span class="token punctuation">.</span>&lt;Object<span class="token operator">></span><span class="token function">singletonList</span><span class="token punctuation">(</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                 internalLockLeaseTime<span class="token punctuation">,</span> <span class="token function">getLockName</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="解锁-1"><a href="#解锁-1" class="headerlink" title="解锁"></a>解锁</h3><p>锁的释放主要是 <code>publish</code> 释放锁的信息，然后做校验，一样会判断是否当前线程，成功就释放锁，还有个 <code>hincrby</code> 递增的操作，锁的值<strong>大于 0</strong> 说明是可重入锁，那就刷新过期时间。</p><p>如果值<strong>小于 0</strong> 了，那删掉 Key 释放锁。</p><p>是不是又和 <strong>AQS</strong> 很像了？</p><p><strong>AQS</strong> 就是通过一个 <code>volatile</code> 修饰 <code>status</code> 去看锁的状态，也会看数值判断是否是可重入的。</p><p>所以我说代码的设计，最后就万剑归一，都是一样的。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> RFuture<span class="token operator">&lt;</span>Void<span class="token operator">></span> <span class="token function">unlockAsync</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> RPromise<span class="token operator">&lt;</span>Void<span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedissonPromise</span><span class="token operator">&lt;</span>Void<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//解锁方法</span>    RFuture<span class="token operator">&lt;</span>Boolean<span class="token operator">></span> future <span class="token operator">=</span> <span class="token function">unlockInnerAsync</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>    future<span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FutureListener</span><span class="token operator">&lt;</span>Boolean<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operationComplete</span><span class="token punctuation">(</span>Future<span class="token operator">&lt;</span>Boolean<span class="token operator">></span> future<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>future<span class="token punctuation">.</span><span class="token function">isSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">cancelExpirationRenewal</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>                result<span class="token punctuation">.</span><span class="token function">tryFailure</span><span class="token punctuation">(</span>future<span class="token punctuation">.</span><span class="token function">cause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//获取返回值</span>            Boolean opStatus <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">getNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//如果返回空，则证明解锁的线程和当前锁不是同一个线程，抛出异常</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>opStatus <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                IllegalMonitorStateException cause <span class="token operator">=</span>                     <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span>"                        attempt to unlock lock<span class="token punctuation">,</span> not locked by current thread by node id<span class="token operator">:</span> "                        <span class="token operator">+</span> id <span class="token operator">+</span> <span class="token string">" thread-id: "</span> <span class="token operator">+</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>                result<span class="token punctuation">.</span><span class="token function">tryFailure</span><span class="token punctuation">(</span>cause<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//解锁成功，取消刷新过期时间的那个定时任务</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>opStatus<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">cancelExpirationRenewal</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            result<span class="token punctuation">.</span><span class="token function">trySuccess</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span> RFuture<span class="token operator">&lt;</span>Boolean<span class="token operator">></span> <span class="token function">unlockInnerAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> commandExecutor<span class="token punctuation">.</span><span class="token function">evalWriteAsync</span><span class="token punctuation">(</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> LongCodec<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">,</span> EVAL<span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">//如果锁已经不存在， 发布锁释放的消息</span>            <span class="token string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> <span class="token operator">+</span>                <span class="token string">"redis.call('publish', KEYS[2], ARGV[1]); "</span> <span class="token operator">+</span>                <span class="token string">"return 1; "</span> <span class="token operator">+</span>            <span class="token string">"end;"</span> <span class="token operator">+</span>            <span class="token comment" spellcheck="true">//如果释放锁的线程和已存在锁的线程不是同一个线程，返回null</span>            <span class="token string">"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then "</span> <span class="token operator">+</span>                <span class="token string">"return nil;"</span> <span class="token operator">+</span>            <span class="token string">"end; "</span> <span class="token operator">+</span>            <span class="token comment" spellcheck="true">//通过hincrby递减1的方式，释放一次锁</span>            <span class="token comment" spellcheck="true">//若剩余次数大于0 ，则刷新过期时间</span>            <span class="token string">"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); "</span> <span class="token operator">+</span>            <span class="token string">"if (counter > 0) then "</span> <span class="token operator">+</span>                <span class="token string">"redis.call('pexpire', KEYS[1], ARGV[2]); "</span> <span class="token operator">+</span>                <span class="token string">"return 0; "</span> <span class="token operator">+</span>            <span class="token comment" spellcheck="true">//否则证明锁已经释放，删除key并发布锁释放的消息</span>            <span class="token string">"else "</span> <span class="token operator">+</span>                <span class="token string">"redis.call('del', KEYS[1]); "</span> <span class="token operator">+</span>                <span class="token string">"redis.call('publish', KEYS[2], ARGV[1]); "</span> <span class="token operator">+</span>                <span class="token string">"return 1; "</span><span class="token operator">+</span>            <span class="token string">"end; "</span> <span class="token operator">+</span>            <span class="token string">"return nil;"</span><span class="token punctuation">,</span>                                              Arrays<span class="token punctuation">.</span>&lt;Object<span class="token operator">></span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getChannelName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>         LockPubSub<span class="token punctuation">.</span>unlockMessage<span class="token punctuation">,</span> internalLockLeaseTime<span class="token punctuation">,</span> <span class="token function">getLockName</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大家会发现，你学懂一个技术栈之后，学新的会很快，而且也能发现他们的设计思想和技巧真的很巧妙，也总能找到相似点，和让你惊叹的点。</p><p>就拿 <code>Doug Lea</code> 写的 <strong>AbstractQueuedSynchronizer（AQS）</strong>来说，他写了一行代码，你可能看几天才能看懂，大佬们的思想是真的牛。</p><p>我看源码有时候也头疼，但是去谷歌一下，自己理解一下，突然恍然大悟的时候觉得一切又很值。</p><p>学习就是一条时而郁郁寡欢，时而开环大笑的路，大家加油，我们成长路上一起共勉。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZooKeeper分布式锁</title>
      <link href="/2020/05/02/fen-bu-shi/zookeeper-fen-bu-shi-suo/"/>
      <url>/2020/05/02/fen-bu-shi/zookeeper-fen-bu-shi-suo/</url>
      
        <content type="html"><![CDATA[<h2 id="ZooKeeper-分布式锁"><a href="#ZooKeeper-分布式锁" class="headerlink" title="ZooKeeper 分布式锁"></a>ZooKeeper 分布式锁</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>锁我想不需要我过多的去说，大家都知道是怎么一回事了吧？</p><p>在多线程环境下，由于上下文的切换，数据可能出现不一致的情况或者数据被污染，我们需要保证数据安全，所以想到了加锁。</p><p>所谓的加锁机制呢，就是当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问，直到该线程读取完，其他线程才可使用。</p><p>还记得我之前说过 Redis 在分布式的情况下，需要对存在并发竞争的数据进行加锁，老公们十分费解，Redis 是单线程的嘛？为啥还要加锁呢？</p><p>看来老公们还是年轻啊，你说的不需要加锁的情况是这样的：</p><p><img src="https://s1.ax1x.com/2020/05/02/JvIL0x.png" alt=""></p><p>单个服务去访问 Redis 的时候，确实因为 Redis 本身单线程的原因是不用考虑线程安全的，但是，现在有哪个公司还是单机的呀？肯定都是分布式集群了嘛。</p><p>老公们你看下这样的场景是不是就有问题了：</p><p>你们经常不是说秒杀嘛，拿到库存判断，那老婆告诉你分布式情况就是会出问题的。</p><p><img src="https://s1.ax1x.com/2020/05/02/JvowuR.png" alt=""></p><p>我们为了减少 DB 的压力，把库存预热到了 KV ，现在 KV 的库存是 1 。</p><ol><li>服务 A 去 Redis 查询到库存发现是 1 ，那说明我能抢到这个商品对不对，那我就准备减一了，但是还没减。</li><li>同时服务 B 也去拿发现也是 1 ，那我也抢到了呀，那我也减。</li><li>C 同理。</li><li>等所有的服务都判断完了，你发现诶，怎么变成 -2 了，超卖了呀，这下完了。</li></ol><p>老公们是不是发现问题了，这就需要分布式锁的介入了，我会分三个章节去分别介绍分布式锁的三种实现方式<strong>（Zookeeper ，Redis ，MySQL）</strong>，说出他们的优缺点，以及一般大厂的实践场景。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><blockquote><p>一个骚里骚气的面试官啥也没拿的就走了进来，你一看，这不是你老婆嘛，你正准备叫他的时候，发现他一脸严肃，死鬼还装严肃，肯定会给我放水的吧。</p><p>咳咳，我们啥也不说了，开始今天的面试吧。</p><p>正常线程进程同步的机制有哪些？</p></blockquote><ul><li>互斥：互斥的机制，保证同一时间只有一个线程可以操作共享资源 <strong>synchronized</strong> ，<strong>Lock</strong> 等。</li><li>临界值：让多线程串行化去访问资源。</li><li>事件通知：通过事件的通知去保证大家都有序访问共享资源。</li><li>信号量：多个任务同时访问，同时限制数量，比如发令枪 <strong>CDL</strong> ，<strong>Semaphore</strong> 等。</li></ul><blockquote><p>那分布式锁你了解过有哪些么？</p></blockquote><p>分布式锁实现主要以 <strong>Zookeeper</strong>（以下简称 ZK ）、<strong>Redis</strong> 、<strong>MySQL</strong> 这三种为主。</p><blockquote><p>那先跟我聊一下 ZK 吧，你能说一下他常见的使用场景么？</p></blockquote><p>他主要的应用场景有以下几个：</p><ul><li>服务注册与订阅（共用节点）</li><li>分布式通知（监听 znode ）</li><li>服务命名（ znode 特性）</li><li>数据订阅、发布（ watcher ）</li><li>分布式锁（临时节点）</li></ul><blockquote><p>ZK 是啥？</p></blockquote><p>它是个数据库，文件存储系统，并且有监听通知机制（观察者模式）。</p><blockquote><p>存文件系统，他存了什么？</p></blockquote><p>节点。</p><p>ZK 的节点类型有 <strong>4</strong> 大类：</p><ul><li><strong>持久化节点</strong>（ ZK 断开后节点还在）</li><li><strong>持久化顺序编号目录节点</strong></li><li><strong>临时目录节点</strong>（客户端断开后节点就删除了）</li><li><strong>临时目录编号目录节点</strong></li></ul><p>节点名称都是<strong>唯一</strong>的。</p><blockquote><p>节点怎么创建？</p></blockquote><p>我特么，这样问的么？可是我面试只看了分布式锁，我得好好想想！！！</p><p>还好我之前在自己的服务器搭建了一个 ZK 的集群，我刚好跟大家回忆一波。</p><pre class=" language-bash"><code class="language-bash">create /test laogong // 创建永久节点 </code></pre><p><img src="https://s1.ax1x.com/2020/05/02/Jvoq2Q.png" alt="创建永久节点"></p><blockquote><p>那临时节点呢？</p></blockquote><pre class=" language-bash"><code class="language-bash">create -e /test laogong // 创建临时节点</code></pre><p><img src="https://s1.ax1x.com/2020/05/02/JvTKPO.png" alt="创建临时节点"></p><p>临时节点就创建成功了，如果我断开这次链接，这个节点自然就消失了，这是我的一个 ZK 管理工具，目录可能清晰点。</p><p><img src="https://s1.ax1x.com/2020/05/02/JvT8sA.png" alt=""></p><blockquote><p>如何创建顺序节点呢？</p></blockquote><pre class=" language-bash"><code class="language-bash">create -s /test // 创建顺序节点</code></pre><p><img src="https://s1.ax1x.com/2020/05/02/JvTGqI.png" alt="创建顺序节点"></p><blockquote><p>临时顺序节点呢？</p></blockquote><p>我想聪明的老公都会抢答了</p><pre class=" language-bash"><code class="language-bash">create -e -s /test  // 创建临时顺序节点</code></pre><p><img src="https://s1.ax1x.com/2020/05/02/JvTai8.png" alt="创建临时顺序节点"></p><p>我退出后，重新连接，发现刚才创建的所有临时节点都没了。</p><p><img src="https://s1.ax1x.com/2020/05/02/Jv7Kwq.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/02/Jv7lkV.png" alt=""></p><p>开篇演示这么多呢，我就是想给大家看到的 ZK 大概的一个操作流程和数据结构，中间涉及的搭建以及其他的技能我就不说了，我们重点聊一下他在分布式锁中的实现。</p><p>ZK 就是基于节点去实现各种分布式锁的。</p><blockquote><p>就拿开头的场景来说，ZK 应该怎么去保证分布式情况下的线程安全呢？并发竞争他是怎么控制的呢？</p></blockquote><p>为了模拟并发竞争这样一个情况，我写了点伪代码，大家可以先看看。</p><p><img src="https://s1.ax1x.com/2020/05/02/Jv7y1e.png" alt=""></p><p>我定义了一个库存 <code>inventory</code> 值为 1 ，还用到了一个 <strong>CountDownLatch</strong> 发令枪，等 10 个线程都就绪了一起去扣减库存。</p><p>是不是就像 10 台机器一起去拿到库存，然后扣减库存了？</p><p>所有机器一起去拿，发现都是 1 ，那大家都认为是自己抢到了，都做了减一的操作，但是等所有人都执行完，再去 set 值的时候，发现其实已经超卖了，我打印出来给大家看看。</p><p><img src="https://s1.ax1x.com/2020/05/02/Jv7T1g.png" alt=""></p><p>是吧，这还不是超卖一个两个的问题，超卖 7 个都有，代码里面明明判断了库存大于 0 才去减的，怎么回事开头我说明了。</p><blockquote><p>那怎么解决这个问题？</p></blockquote><p>synchronized ，Lock 也只能保证你当前机器线程安全，这样分布式访问还是有问题。</p><p><img src="https://s1.ax1x.com/2020/05/02/JvHFBR.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/02/JvHkH1.png" alt=""></p><p>上面跟大家提到的 ZK 的节点就可以解决这个问题。</p><p>ZK 节点有个<strong>唯一</strong>的特性，就是我们创建过这个节点了，你再创建 ZK 是会报错的，那我们就利用一下他的唯一性去实现一下。</p><p><img src="https://s1.ax1x.com/2020/05/02/JvHm9O.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/02/JvHlDA.png" alt=""></p><blockquote><p>怎么实现呢？</p></blockquote><p>上面不是 10 个线程嘛？</p><p>我们全部去创建，创建成功的第一个返回 True 他就可以继续下面的扣减库存操作，后续的节点访问就会全部报错，扣减失败，我们把它们丢一个队列去排队。</p><blockquote><p>那怎么释放锁呢？</p></blockquote><p>删除节点咯，删了再通知其他的人过来加锁，依次类推。</p><p>我们实现一下，ZK 加锁的场景。</p><p><img src="https://s1.ax1x.com/2020/05/02/JvHfKJ.png" alt=""></p><p>是不是，只有第一个线程能扣减成功，其他的都失败了。</p><blockquote><p>但是你发现问题没有，你加了锁了，你得释放啊，你不释放后面的报错了就不重试了。</p></blockquote><p>那简单，删除锁就释放掉了，Lock 在 <code>finally</code> 里面 <code>unLock()</code> ，现在我们在 <code>finally</code> 删除节点。</p><blockquote><p>加锁我们知道创建节点就够了，但是你得实现一个阻塞的效果呀，那咋搞？</p></blockquote><p>死循环，递归不断去尝试，直到成功，一个伪装的阻塞效果。</p><blockquote><p>怎么知道前面的老哥删除节点了嗯？</p></blockquote><p>监听节点的删除事件。</p><p><img src="https://s1.ax1x.com/2020/05/02/JvHT56.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/02/JvHq2D.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/02/JvHvqA.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/02/JvbCPf.png" alt=""></p><blockquote><p>但是你发现你这样做的问题没？</p></blockquote><p>是的，会出现死锁。</p><p>第一个仔加锁成功了，在执行代码的时候，机器宕机了，那节点是不是就不能删除了？</p><p>你要故作沉思，自问自答，时而看看远方，时而看看面试官，假装自己什么都不知道。</p><p>哦我想起来了，创建临时节点就好了，客户端连接一断开，别的就可以监听到节点的变化了。</p><blockquote><p>嗯还不错，那你发现还有别的问题没？</p></blockquote><p>好像这种监听机制也不好。</p><blockquote><p>怎么个不好呢？</p></blockquote><p>你们可以看到，监听，是所有服务都去监听一个节点的，节点的释放也会通知所有的服务器，如果是 900 个服务器呢？</p><p>这对服务器是很大的一个挑战，一个释放的消息，就好像一个牧羊犬进入了羊群，大家都四散而开，随时可能干掉机器，会占用服务资源，网络带宽等等。</p><p>这就是羊群效应。</p><p><img src="https://s1.ax1x.com/2020/05/02/JvbAMQ.gif" alt="羊群效应"></p><blockquote><p>那怎么解决这个问题？</p></blockquote><p>继续故作沉思，啊啊啊，好难，我的脑袋。。。。</p><blockquote><p>你 TM 别装了好不好？</p></blockquote><p>好的，临时顺序节点，可以顺利解决这个问题。</p><p>怎么实现老公你先别往下看，先自己想想。</p><p>之前说了全部监听一个节点问题很大，那我们就监听我们的前一个节点，因为是顺序的，很容易找到自己的前后。</p><p><img src="https://s1.ax1x.com/2020/05/02/Jx3Icq.png" alt=""></p><p>和之前监听一个永久节点的区别就在于，这里每个节点只监听了自己的前一个节点，释放当然也是一个个释放下去，就不会出现羊群效应了。</p><p><img src="https://s1.ax1x.com/2020/05/02/Jx8GCj.png" alt=""></p><blockquote><p>你说了这么多，挺不错的，你能说说 ZK 在分布式锁中实践的一些缺点么？</p></blockquote><p>ZK <strong>性能</strong>上可能并没有缓存服务那么高。</p><p>因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。</p><p>ZK 中创建和删除节点只能通过 Leader 服务器来执行，然后将数据同步到所有的 Follower 机器上。（这里涉及 ZK 集群的知识，我就不展开了，以后 ZK 章节跟老公们细聊）</p><blockquote><p>还有么？</p></blockquote><p>使用 ZooKeeper 也有可能带来<strong>并发问题</strong>，只是并不常见而已。</p><p>由于网络抖动，客户端和 ZK 集群的 <strong>Session</strong> 连接断了，那么 ZK 以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了。</p><p>就可能产生并发问题了，这个问题不常见是因为 ZK 有<strong>重试</strong>机制，一旦 ZK 集群检测不到客户端的心跳，就会重试，Curator 客户端支持多种重试策略。</p><p>多次重试之后还不行的话才会删除临时节点。</p><p>Tip：所以，选择一个合适的重试策略也比较重要，要在锁的粒度和并发之间找一个平衡。</p><blockquote><p>有更好的实现么？</p></blockquote><p>基于 Redis 的分布式锁</p><blockquote><p>能跟我聊聊么？</p></blockquote><p>我看看了手上的表，老公，今天天色不早了，你全问完了，我怎么多水几篇文章呢？</p><blockquote><p>行，确实很晚了，那你回家去把家务干了吧？</p></blockquote><p>我？？？？</p><p><img src="https://s1.ax1x.com/2020/05/02/JxGZoF.png" alt="么么哒"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ZK 通过临时节点，解决掉了<strong>死锁</strong>的问题，一旦客户端获取到锁之后突然挂掉（ Session 连接断开），那么这个临时节点就会自动删除掉，其他客户端自动获取锁。</p><p>ZK 通过节点排队监听的机制，也实现了<strong>阻塞</strong>的原理，其实就是个递归在那无限等待最小节点释放的过程。</p><p>我上面没实现锁的<strong>可重入</strong>，但是也很好实现，可以带上线程信息就可以了，或者机器信息这样的唯一标识，获取的时候判断一下。</p><p>ZK 的集群也是<strong>高可用</strong>的，只要半数以上的或者，就可以对外提供服务了。</p><p>这周会写完 Redis 和数据库的分布式锁的，老公们等好。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式锁 </tag>
            
            <tag> ZooKeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Raft协议</title>
      <link href="/2020/04/30/fen-bu-shi/raft-xie-yi/"/>
      <url>/2020/04/30/fen-bu-shi/raft-xie-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="Raft-协议"><a href="#Raft-协议" class="headerlink" title="Raft 协议"></a>Raft 协议</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>Raft</strong> 协议是用来解决分布式系统一致性问题的协议，在很长一段时间，<strong>Paxos</strong> 被认为是解决分布式系统一致性的代名词。但是 Paxos 难于理解，更难以实现，诸如 Google 大牛们开发的分布式锁系统 <code>Chubby</code> 都遭遇了很多坑。<strong>Raft</strong> 协议设计的初衷就是容易实现，保证对于普遍的人群都可以十分舒适容易的去理解。另外，它必须能够让人形成直观的认识，这样系统的构建者才能够在现实中进行必然的扩展。</p><p>当 Sentinel 集群有 Sentinel 发现 Master <strong>客观下线</strong>了，就会开始故障转移流程，故障转移流程的第一步就是在 Sentinel 集群选择一个 Leader ，让 <strong>Leader</strong> 完成故障转移流程。</p><h3 id="Raft-协议选举流程"><a href="#Raft-协议选举流程" class="headerlink" title="Raft 协议选举流程"></a>Raft 协议选举流程</h3><p>描述 <strong>Raft</strong> 选举流程之前需要了解一些概念。</p><h4 id="节点的状态"><a href="#节点的状态" class="headerlink" title="节点的状态"></a>节点的状态</h4><p><strong>Raft</strong> 协议描述的节点共有三种状态：<strong>Leader</strong> ，<strong>Follower</strong> ，<strong>Candidate</strong> 。在系统运行正常的时候只有 Leader 和 Follower 两种状态的节点。一个 Leader 节点，其他的节点都是 Follower 。Candidate 是系统运行不稳定时期的<strong>中间状态</strong>，当一个 Follower 对 Leader 的心跳出现异常，就会转变成 Candidate ，Candidate 会去竞选新的 Leader ，它会向其他节点发送竞选投票，如果大多数节点都投票给它，它就会替代原来的 Leader ，变成新的 Leader ，原来的 Leader 会降级成 Follower 。</p><p><img src="https://s1.ax1x.com/2020/04/30/JLdTJJ.png" alt="节点的状态"></p><h4 id="term"><a href="#term" class="headerlink" title="term"></a>term</h4><p>在分布式系统中，各个节点的时间同步是一个很大的难题，但是为了识别过期时间，时间信息又必不可少。<strong>Raft</strong> 协议为了解决这个问题，引入了 <strong>term</strong>（任期）的概念。<strong>Raft</strong> 协议将时间切分为一个个的 <strong>term</strong> ，可以认为是一种“逻辑时间”。</p><p><img src="https://s1.ax1x.com/2020/04/30/JLwiQI.png" alt="term"></p><h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><p><strong>Raft</strong> 协议在选举阶段交互的 RPC 有两类：<strong>RequestVote</strong> 和 <strong>AppendEntries</strong> 。</p><ul><li><strong>RequestVote</strong> 是用来向其他节点发送竞选投票。</li><li><strong>AppendEntries</strong> 是当该节点得到更多的选票后，成为 Leader ，向其他节点确认消息。</li></ul><h4 id="选举流程"><a href="#选举流程" class="headerlink" title="选举流程"></a>选举流程</h4><p><strong>Raft</strong> 采用<strong>心跳机制</strong>触发 Leader 选举。系统启动后，全部节点初始化为 <strong>Follower</strong> ，term 为 0 。节点如果收到了 RequestVote 或者 AppendEntries ，就会保持自己的 Follower 身份。如果一段时间内没收到 AppendEntries 消息直到选举超时，说明在该节点的超时时间内还没发现 Leader ，Follower 就会转换成 <strong>Candidate</strong> ，自己开始竞选 Leader 。一旦转化为 Candidate ，该节点立即开始下面几件事情：</p><ul><li>增加自己的 term 。</li><li>启动一个新的定时器。</li><li>给自己投一票。</li><li>向所有其他节点发送 RequestVote ，并等待其他节点的回复。</li></ul><p>如果在这过程中收到了其他节点发送的 AppendEntries ，就说明已经有 Leader 产生，自己就转换成 Follower ，选举结束。</p><p>如果在计时器超时前，节点收到多数节点的同意投票，就转换成 Leader 。同时向所有其他节点发送 AppendEntries ，告知自己成为了 Leader 。</p><p>每个节点在一个 term 内只能投一票，采取先到先得的策略，Candidate 前面说到已经投给了自己，Follower 会投给第一个收到 RequestVote 的节点。每个 Follower 有一个计时器，在计时器超时时仍然没有接受到来自 Leader 的心跳 RPC ，则自己转换为 Candidate ，开始请求投票，就是上面的的竞选 Leader 步骤。</p><p>如果多个 Candidate 发起投票，每个 Candidate 都没拿到多数的投票（Split Vote），那么就会等到计时器超时后重新成为 Candidate ，重复前面竞选 Leader 步骤。</p><p><strong>Raft</strong> 协议的定时器采取<strong>随机超时</strong>时间，这是选举 Leader 的关键。每个节点定时器的超时时间随机设置，随机选取配置时间的 1 倍到 2 倍之间。由于随机配置，所以各个 Follower 同时转成 Candidate 的时间一般不一样，在同一个 term 内，先转为 Candidate 的节点会先发起投票，从而获得多数票。多个节点同时转换为 Candidate 的可能性很小。即使几个 Candidate 同时发起投票，在该 term 内有几个节点获得一样高的票数，只是这个 term 无法选出 Leader 。由于各个节点定时器的超时时间随机生成，那么最先进入下一个 term 的节点，将更有机会成为 Leader 。连续多次发生在一个 term 内节点获得一样高票数在理论上几率很小，实际上可以认为完全不可能发生。一般 1-2 个 term 内，Leader 就会被选出来。</p><h3 id="Sentinel-的选举流程"><a href="#Sentinel-的选举流程" class="headerlink" title="Sentinel 的选举流程"></a>Sentinel 的选举流程</h3><p>Sentinel 集群正常运行的时候每个节点 <strong>epoch</strong> 相同，当需要故障转移的时候会在集群中选出 Leader 执行故障转移操作。Sentinel 采用了 <strong>Raft</strong> 协议实现了 Sentinel 间选举 Leader 的算法，不过也不完全跟论文描述的步骤一致。Sentinel 集群运行过程中故障转移完成，所有 Sentinel 又会恢复平等。Leader 仅仅是故障转移操作出现的角色。</p><h4 id="选举流程-1"><a href="#选举流程-1" class="headerlink" title="选举流程"></a>选举流程</h4><ul><li>某个 Sentinel 认定 Master 客观下线的节点后，该 Sentinel 会先看看自己有没有投过票，如果自己已经投过票给其他 Sentinel 了，在 2 倍故障转移的超时时间内自己就不会成为 Leader ，相当于它是一个 Follower 。</li><li>如果该 Sentinel 还没投过票，那么它就成为 Candidate 。</li><li>和 <strong>Raft</strong> 协议描述的一样，成为 Candidate ，Sentinel 需要完成几件事情。<ul><li>更新故障转移状态为 <code>start</code> 。</li><li>当前 <code>epoch</code> 加 <strong>1</strong> ，相当于进入一个新 term ，<strong>在 Sentinel 中 epoch 就是 Raft 协议中的 term</strong> 。</li><li>更新自己的超时时间为当前时间随机加上一段时间，随机时间为 1 s内的随机毫秒数。</li><li>向其他节点发送 <code>is-master-down-by-addr</code> 命令请求投票。命令会带上自己的 <code>epoch</code> 。</li><li>给自己投一票，在 Sentinel 中，投票的方式是把自己 Master 结构体里的 <code>leader</code> 和 <code>leader_epoch</code> 改成投给的 Sentinel 和它的 epoch 。</li></ul></li><li>其他 Sentinel 会收到 Candidate 的 <code>is-master-down-by-addr</code> 命令。如果 Sentinel 当前 epoch 和 Candidate 传给他的 epoch 一样，说明他已经把自己 Master 结构体里的 <code>leader</code> 和 <code>leader_epoch</code> 改成其他 Candidate ，相当于把票投给了其他 Candidate 。投过票给别的 Sentinel 后，在当前 epoch 内自己就只能成为 Follower 。</li><li>Candidate 会不断的统计自己的票数，直到他发现认同他成为 Leader 的票数超过一半而且超过它配置的quorum 。Sentinel 比 <strong>Raft</strong> 协议增加了 quorum ，这样一个 Sentinel 能否当选 Leader 还取决于它配置的 quorum 。</li><li>如果在一个选举时间内，Candidate 没有获得超过一半且超过它配置的 quorum 的票数，自己的这次选举就失败了。</li><li>如果在一个 epoch 内，没有一个 Candidate 获得更多的票数。那么等待超过 <strong>2</strong> 倍故障转移的超时时间后， Candidate 增加 epoch 重新投票。</li><li>如果某个 Candidate 获得<strong>超过一半且超过它配置的 <code>quorum</code> 的票数</strong>，那么它就成为了 Leader 。</li><li>与 <strong>Raft</strong> 协议不同，<strong>Leader 并不会把自己成为 Leader 的消息发给其他 Sentinel</strong> 。其他 Sentinel 等待 Leader 从 Slave 选出 Master 后，检测到新的 Master 正常工作后，就会去掉客观下线的标识，从而不需要进入故障转移流程。</li></ul><h4 id="关于-Sentinel-超时时间的说明"><a href="#关于-Sentinel-超时时间的说明" class="headerlink" title="关于 Sentinel 超时时间的说明"></a>关于 Sentinel 超时时间的说明</h4><p>Sentinel 超时机制有几个超时概念。</p><ul><li><strong>failover_start_time：</strong>下一选举启动的时间。默认是当前时间加上 1s 内的随机毫秒数。</li><li><strong>failover_state_change_time：</strong>故障转移中状态变更的时间。</li><li><strong>failover_timeout：</strong>故障转移超时时间。默认是 3 分钟。</li><li><strong>election_timeout：</strong>选举超时时间，是默认选举超时时间和 <code>failover_timeout</code> 的最小值。默认是 10s 。</li></ul><p>Follower 成为 Candidate 后，会更新 <code>failover_start_time</code> 为当前时间加上 1s 内的随机毫秒数。更新 <code>failover_state_change_time</code> 为当前时间。</p><p>Candidate 的当前时间减去 <code>failover_start_time</code> 大于 <code>election_timeout</code> ，说明 Candidate 还没获得足够的选票，此次 epoch 的选举已经超时，那么转变成 Follower 。需要等到 <code>mstime() - failover_start_time &lt; failover_timeout*2</code> 的时候才开始下一次获得成为 Candidate 的机会。</p><p>如果一个 Follower 把某个 Candidate 设为自己认为的 Leader ，那么它的 <code>failover_start_time</code> 会设置为当前时间加上 1s 内的随机毫秒数。这样它就进入了上面说的需要等到 <code>mstime() - failover_start_time &lt; failover_timeout*2</code> 的时候才开始下一次获得成为 Candidate 的机会。</p><p>因为每个 Sentinel 判断节点客观下线的时间不是同时开始的，一般都有先后，这样先开始的 Sentinel 就更有机会赢得更多选票，另外 <code>failover_state_change_time</code> 为 1s 内的随机毫秒数，这样也把各个节点的超时时间分散开来。本人尝试过很多次，Sentinel 间的 Leader 选举过程基本上一个 <code>epoch</code> 内就完成了。</p><h3 id="Sentinel-选举流程源码解析"><a href="#Sentinel-选举流程源码解析" class="headerlink" title="Sentinel 选举流程源码解析"></a>Sentinel 选举流程源码解析</h3><p>Sentinel 的选举流程的代码基本都在 <code>sentinel.c</code> 文件中，下面结合源码对 Sentinel 的选举流程进行说明。</p><h4 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h4><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* ======================== SENTINEL timer handler ========================== * This is the "main" our Sentinel, being sentinel completely non blocking * in design. The function is called every second. * -------------------------------------------------------------------------- */</span><span class="token comment" spellcheck="true">/* Perform scheduled operations for the specified Redis instance. */</span><span class="token comment" spellcheck="true">// 对给定的实例执行定期操作</span><span class="token keyword">void</span> <span class="token function">sentinelHandleRedisInstance</span><span class="token punctuation">(</span>sentinelRedisInstance <span class="token operator">*</span>ri<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* ========== MONITORING HALF ============ */</span>    <span class="token comment" spellcheck="true">/* ==========     监控操作    =========*/</span>    <span class="token comment" spellcheck="true">/* Every kind of instance */</span>    <span class="token comment" spellcheck="true">/* 对所有类型实例进行处理 */</span>    <span class="token comment" spellcheck="true">// 如果有需要的话，创建连向实例的网络连接</span>    <span class="token function">sentinelReconnectInstance</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 根据情况，向实例发送 PING、 INFO 或者 PUBLISH 命令</span>    <span class="token function">sentinelSendPeriodicCommands</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* ============== ACTING HALF ============= */</span>    <span class="token comment" spellcheck="true">/* ==============  故障检测   ============= */</span>    <span class="token comment" spellcheck="true">/* We don't proceed with the acting half if we are in TILT mode.     * TILT happens when we find something odd with the time, like a     * sudden change in the clock. */</span>    <span class="token comment" spellcheck="true">// 如果 Sentinel 处于 TILT 模式，那么不执行故障检测。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sentinel<span class="token punctuation">.</span>tilt<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果 TILI 模式未解除，那么不执行动作</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>sentinel<span class="token punctuation">.</span>tilt_start_time <span class="token operator">&lt;</span> SENTINEL_TILT_PERIOD<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 时间已过，退出 TILT 模式</span>        sentinel<span class="token punctuation">.</span>tilt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">sentinelEvent</span><span class="token punctuation">(</span>REDIS_WARNING<span class="token punctuation">,</span><span class="token string">"-tilt"</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token string">"#tilt mode exited"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* Every kind of instance */</span>    <span class="token comment" spellcheck="true">// 判断 master 是否进入 SDOWN 状态</span>    <span class="token function">sentinelCheckSubjectivelyDown</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Masters and slaves */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ri<span class="token operator">-></span>flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>SRI_MASTER<span class="token operator">|</span>SRI_SLAVE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* Nothing so far. */</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* Only masters */</span>    <span class="token comment" spellcheck="true">/* 对主服务器进行处理 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ri<span class="token operator">-></span>flags <span class="token operator">&amp;</span> SRI_MASTER<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 判断 master 是否进入 ODOWN 状态</span>        <span class="token function">sentinelCheckObjectivelyDown</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果主服务器进入了 ODOWN 状态，那么开始一次故障转移操作</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sentinelStartFailoverIfNeeded</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 强制向其他 Sentinel 发送 SENTINEL is-master-down-by-addr 命令</span>            <span class="token comment" spellcheck="true">// 刷新其他 Sentinel 关于主服务器的状态</span>            <span class="token function">sentinelAskMasterStateToOtherSentinels</span><span class="token punctuation">(</span>ri<span class="token punctuation">,</span>SENTINEL_ASK_FORCED<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 执行故障转移</span>        <span class="token function">sentinelFailoverStateMachine</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 此处调用 sentinelAskMasterStateToOtherSentinels ，</span>        <span class="token comment" spellcheck="true">// 只是为了获取其他 Sentinel 对于 master 是否存活的判断，</span>        <span class="token comment" spellcheck="true">// 用来下一次判断 master 是否进入 ODOWN 状态</span>        <span class="token function">sentinelAskMasterStateToOtherSentinels</span><span class="token punctuation">(</span>ri<span class="token punctuation">,</span>SENTINEL_NO_FLAGS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Sentinel 会每隔 <strong>100ms</strong> 执行一次 <code>sentinelHandleRedisInstance</code> 函数。流程会检查 Master 是否进入 <strong>SDOWN</strong> 状态，接着会检查 Master 是否进入 <strong>ODOWN</strong> 状态，接着会查看是否需要开始故障转移，如果开始故障转移就会向其他节点拉去投票，接下来有个故障转移的状态机，根据不同的 <code>failover_state</code> ，决定完成不同的操作，正常的时候 <code>failover_state</code> 为 <strong>SENTINEL_FAILOVER_STATE_NONE</strong> 。</p><h4 id="向其他-Sentinel-获取投票或者获取对-Master-存活状态的判断结果"><a href="#向其他-Sentinel-获取投票或者获取对-Master-存活状态的判断结果" class="headerlink" title="向其他 Sentinel 获取投票或者获取对 Master 存活状态的判断结果"></a>向其他 Sentinel 获取投票或者获取对 Master 存活状态的判断结果</h4><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> SENTINEL_ASK_FORCED (1&lt;&lt;0)</span><span class="token keyword">void</span> <span class="token function">sentinelAskMasterStateToOtherSentinels</span><span class="token punctuation">(</span>sentinelRedisInstance <span class="token operator">*</span>master<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span> <span class="token punctuation">{</span>    dictIterator <span class="token operator">*</span>di<span class="token punctuation">;</span>    dictEntry <span class="token operator">*</span>de<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历正在监视相同 master 的所有 sentinel</span>    <span class="token comment" spellcheck="true">// 向它们发送 SENTINEL is-master-down-by-addr 命令</span>    di <span class="token operator">=</span> <span class="token function">dictGetIterator</span><span class="token punctuation">(</span>master<span class="token operator">-></span>sentinels<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>de <span class="token operator">=</span> <span class="token function">dictNext</span><span class="token punctuation">(</span>di<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sentinelRedisInstance <span class="token operator">*</span>ri <span class="token operator">=</span> <span class="token function">dictGetVal</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 距离该 sentinel 最后一次回复 SENTINEL master-down-by-addr 命令已经过了多久</span>        mstime_t elapsed <span class="token operator">=</span> <span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> ri<span class="token operator">-></span>last_master_down_reply_time<span class="token punctuation">;</span>        <span class="token keyword">char</span> port<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> retval<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* If the master state from other sentinel is too old, we clear it. */</span>        <span class="token comment" spellcheck="true">// 如果目标 Sentinel 关于主服务器的信息已经太久没更新，那么我们清除它</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>elapsed <span class="token operator">></span> SENTINEL_ASK_PERIOD<span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ri<span class="token operator">-></span>flags <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span>SRI_MASTER_DOWN<span class="token punctuation">;</span>            <span class="token function">sdsfree</span><span class="token punctuation">(</span>ri<span class="token operator">-></span>leader<span class="token punctuation">)</span><span class="token punctuation">;</span>            ri<span class="token operator">-></span>leader <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/* Only ask if master is down to other sentinels if:         *         * 只在以下情况满足时，才向其他 sentinel 询问主服务器是否已下线         *         * 1) We believe it is down, or there is a failover in progress.         *    本 sentinel 相信服务器已经下线，或者针对该主服务器的故障转移操作正在执行         * 2) Sentinel is connected.         *    目标 Sentinel 与本 Sentinel 已连接         * 3) We did not received the info within SENTINEL_ASK_PERIOD ms.          *    当前 Sentinel 在 SENTINEL_ASK_PERIOD 毫秒内没有获得过目标 Sentinel 发来的信息         * 4) 条件 1 和条件 2 满足而条件 3 不满足，但是 flags 参数给定了 SENTINEL_ASK_FORCED 标识         */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>master<span class="token operator">-></span>flags <span class="token operator">&amp;</span> SRI_S_DOWN<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ri<span class="token operator">-></span>flags <span class="token operator">&amp;</span> SRI_DISCONNECTED<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> SENTINEL_ASK_FORCED<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> ri<span class="token operator">-></span>last_master_down_reply_time <span class="token operator">&lt;</span> SENTINEL_ASK_PERIOD<span class="token punctuation">)</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* Ask */</span>        <span class="token comment" spellcheck="true">// 发送 SENTINEL is-master-down-by-addr 命令</span>        <span class="token function">ll2string</span><span class="token punctuation">(</span>port<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">,</span>master<span class="token operator">-></span>addr<span class="token operator">-></span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>        retval <span class="token operator">=</span> <span class="token function">redisAsyncCommand</span><span class="token punctuation">(</span>ri<span class="token operator">-></span>cc<span class="token punctuation">,</span>                    sentinelReceiveIsMasterDownReply<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span>                    <span class="token string">"SENTINEL is-master-down-by-addr %s %s %llu %s"</span><span class="token punctuation">,</span>                    master<span class="token operator">-></span>addr<span class="token operator">-></span>ip<span class="token punctuation">,</span> port<span class="token punctuation">,</span>                    sentinel<span class="token punctuation">.</span>current_epoch<span class="token punctuation">,</span>                    <span class="token comment" spellcheck="true">// 如果本 Sentinel 已经检测到 master 进入 ODOWN </span>                    <span class="token comment" spellcheck="true">// 并且要开始一次故障转移，那么向其他 Sentinel 发送自己的运行 ID</span>                    <span class="token comment" spellcheck="true">// 让对方将给自己投一票（如果对方在这个纪元内还没有投票的话）</span>                    <span class="token punctuation">(</span>master<span class="token operator">-></span>failover_state <span class="token operator">></span> SENTINEL_FAILOVER_STATE_NONE<span class="token punctuation">)</span> <span class="token operator">?</span>                    server<span class="token punctuation">.</span>runid <span class="token punctuation">:</span> <span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>retval <span class="token operator">==</span> REDIS_OK<span class="token punctuation">)</span> ri<span class="token operator">-></span>pending_commands<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">dictReleaseIterator</span><span class="token punctuation">(</span>di<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>对于每个节点，Sentinel 都会确认节点是否 <strong>SDOWN</strong> ，对于 Master ，还需要确认 <strong>ODOWN</strong> 。<code>sentinelAskMasterStateToOtherSentinels</code> 方法会在 Master 进入 <strong>SDOWN</strong> 或者 <strong>ODOWN</strong> 调用 <code>sentinel is-master-down-by-addr</code> 命令。<strong>SDOWN</strong> 时，该命令用来获取其他 Sentinel 对于 Master 的存活状态判断结果， <strong>ODOWN</strong> 是用来像其他节点投票的。<strong>SDOWN</strong> 时，flags 是 <strong>SENTINEL_NO_FLAGS</strong> ，<strong>ODOWN</strong> 时，flags 是 <strong>SENTINEL_ASK_FORCED</strong> 。</p><h4 id="检查是否开始故障转移"><a href="#检查是否开始故障转移" class="headerlink" title="检查是否开始故障转移"></a>检查是否开始故障转移</h4><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* This function checks if there are the conditions to start the failover, * that is: * * 这个函数检查是否需要开始一次故障转移操作： * * 1) Master must be in ODOWN condition. *    主服务器已经计入 ODOWN 状态。 * 2) No failover already in progress. *    当前没有针对同一主服务器的故障转移操作在执行。 * 3) No failover already attempted recently. *    最近时间内，这个主服务器没有尝试过执行故障转移 *    （应该是为了防止频繁执行）。 *  * We still don't know if we'll win the election so it is possible that we * start the failover but that we'll not be able to act. * * 虽然 Sentinel 可以发起一次故障转移，但因为故障转移操作是由领头 Sentinel 执行的， * 所以发起故障转移的 Sentinel 不一定就是执行故障转移的 Sentinel 。 * * Return non-zero if a failover was started.  * * 如果故障转移操作成功开始，那么函数返回非 0 值。 */</span><span class="token keyword">int</span> <span class="token function">sentinelStartFailoverIfNeeded</span><span class="token punctuation">(</span>sentinelRedisInstance <span class="token operator">*</span>master<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* We can't failover if the master is not in O_DOWN state. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>master<span class="token operator">-></span>flags <span class="token operator">&amp;</span> SRI_O_DOWN<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Failover already in progress? */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>master<span class="token operator">-></span>flags <span class="token operator">&amp;</span> SRI_FAILOVER_IN_PROGRESS<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Last failover attempt started too little time ago? */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> master<span class="token operator">-></span>failover_start_time <span class="token operator">&lt;</span>        master<span class="token operator">-></span>failover_timeout<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>master<span class="token operator">-></span>failover_delay_logged <span class="token operator">!=</span> master<span class="token operator">-></span>failover_start_time<span class="token punctuation">)</span> <span class="token punctuation">{</span>            time_t clock <span class="token operator">=</span> <span class="token punctuation">(</span>master<span class="token operator">-></span>failover_start_time <span class="token operator">+</span>                            master<span class="token operator">-></span>failover_timeout<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1000</span><span class="token punctuation">;</span>            <span class="token keyword">char</span> ctimebuf<span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">ctime_r</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>clock<span class="token punctuation">,</span>ctimebuf<span class="token punctuation">)</span><span class="token punctuation">;</span>            ctimebuf<span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* Remove newline. */</span>            master<span class="token operator">-></span>failover_delay_logged <span class="token operator">=</span> master<span class="token operator">-></span>failover_start_time<span class="token punctuation">;</span>            <span class="token function">redisLog</span><span class="token punctuation">(</span>REDIS_WARNING<span class="token punctuation">,</span>                <span class="token string">"Next failover delay: I will not start a failover before %s"</span><span class="token punctuation">,</span>                ctimebuf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">sentinelStartFailover</span><span class="token punctuation">(</span>master<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>     </code></pre><p><code>sentinelStartFailoverIfNeeded</code> 方法会检查 Master 是否为 <strong>ODOWN</strong> 状态。因为定时任务每次就会执行到该函数，所以还要确认故障转移状态 <code>SRI_FAILOVER_IN_PROGRESS</code> 是否已经开始。然后会看定时任务是否超时，只有以上条件都满足才能开始故障转移。关于定时任务是否超时，<code>failover_start_time</code> 默认为 0 ，它有 2 个地方会被修改，一个是开始故障转移后，一个是收到其他 Sentinel 的投票请求。<code>failover_start_time</code> 被修改的值为 <strong>mstime() + rand() % SENTINEL_MAX_DESYNC</strong> ，这就是 <strong>Raft</strong> 协议说的<strong>随机因子</strong>。</p><p><strong>SENTINEL_MAX_DESYNC</strong> 是 1000 ，相当于 <code>failover_start_time</code> 是当前时间加上 1s 内的随机值，这个保证了不同 Sentinel 在超时后，下次申请 Leader 时间的随机。所以故障转移开始，像 <strong>Raft</strong> 协议描述的“ <code>启动一个新的定时器</code> ”，设置了 <code>failover_start_time</code> 。在投票的时候设置 <code>failover_start_time</code> ，那么先投票，再通过 <strong>ODOWN</strong> 和 <strong>SRI_FAILOVER_IN_PROGRESS</strong> 的节点，在检查定时任务是否超时的时候就无法通过，相当于是 <strong>Raft</strong> 协议中的 <strong>Follower</strong> ，它不会参与竞争 Leader 。</p><h4 id="成为-Candidate-，开始竞选-Leader"><a href="#成为-Candidate-，开始竞选-Leader" class="headerlink" title="成为 Candidate ，开始竞选 Leader"></a>成为 Candidate ，开始竞选 Leader</h4><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Setup the master state to start a failover. */</span><span class="token comment" spellcheck="true">// 设置主服务器的状态，开始一次故障转移</span><span class="token keyword">void</span> <span class="token function">sentinelStartFailover</span><span class="token punctuation">(</span>sentinelRedisInstance <span class="token operator">*</span>master<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">redisAssert</span><span class="token punctuation">(</span>master<span class="token operator">-></span>flags <span class="token operator">&amp;</span> SRI_MASTER<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 更新故障转移状态</span>    master<span class="token operator">-></span>failover_state <span class="token operator">=</span> SENTINEL_FAILOVER_STATE_WAIT_START<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 更新主服务器状态</span>    master<span class="token operator">-></span>flags <span class="token operator">|</span><span class="token operator">=</span> SRI_FAILOVER_IN_PROGRESS<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 更新纪元</span>    master<span class="token operator">-></span>failover_epoch <span class="token operator">=</span> <span class="token operator">++</span>sentinel<span class="token punctuation">.</span>current_epoch<span class="token punctuation">;</span>    <span class="token function">sentinelEvent</span><span class="token punctuation">(</span>REDIS_WARNING<span class="token punctuation">,</span><span class="token string">"+new-epoch"</span><span class="token punctuation">,</span>master<span class="token punctuation">,</span><span class="token string">"%llu"</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span> sentinel<span class="token punctuation">.</span>current_epoch<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sentinelEvent</span><span class="token punctuation">(</span>REDIS_WARNING<span class="token punctuation">,</span><span class="token string">"+try-failover"</span><span class="token punctuation">,</span>master<span class="token punctuation">,</span><span class="token string">"%@"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 记录故障转移状态的变更时间</span>    master<span class="token operator">-></span>failover_start_time <span class="token operator">=</span> <span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span>SENTINEL_MAX_DESYNC<span class="token punctuation">;</span>    master<span class="token operator">-></span>failover_state_change_time <span class="token operator">=</span> <span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>如果 Sentinel 通过三重检查，进入了 <code>sentinelStartFailover</code> ，相当于成为了 <strong>Candidate</strong> ，它会做以下几件事情：</p><ul><li>把 <code>failover_state</code> 改成 <strong>SENTINEL_FAILOVER_STATE_WAIT_START</strong> 。</li><li>把 Master 的状态改成故障转移中 <strong>SRI_FAILOVER_IN_PROGRESS</strong> 。</li><li>增加 Master 的 <code>current_epoch</code> ，并赋值给 <code>failover_epoch</code> 。</li><li>把 <code>failover_start_time</code> 改成 <strong>mstime() + rand() % SENTINEL_MAX_DESYNC</strong> 。</li><li>把 <code>failover_state_change_time</code> 改成 <code>mstime()</code> 。</li></ul><p><code>sentinelStartFailover</code> 完成了成为 <strong>Candidate</strong> 的前面两步，接着要回到前面的定时任务<code>sentinelHandleRedisInstance</code> 。因为 <code>sentinelStartFailoverIfNeeded</code> 返回了 <strong>1</strong> ，所以进入 <strong>if</strong> 流程，执行 <code>sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_ASK_FORCED);</code> ，开始向其他 Sentinel 拉票。然后就进入 <code>sentinelFailoverStateMachine</code> 。</p><h4 id="Follower-投票"><a href="#Follower-投票" class="headerlink" title="Follower 投票"></a>Follower 投票</h4><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Vote for the sentinel with 'req_runid' or return the old vote if already * voted for the specifed 'req_epoch' or one greater. * * 为运行 ID 为 req_runid 的 Sentinel 投上一票，有两种额外情况可能出现： * 1) 如果 Sentinel 在 req_epoch 纪元已经投过票了，那么返回之前投的票。 * 2) 如果 Sentinel 已经为大于 req_epoch 的纪元投过票了，那么返回更大纪元的投票。 * * If a vote is not available returns NULL, otherwise return the Sentinel * runid and populate the leader_epoch with the epoch of the vote.  * * 如果投票暂时不可用，那么返回 NULL 。 * 否则返回 Sentinel 的运行 ID ，并将被投票的纪元保存到 leader_epoch 指针的值里面。 */</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">sentinelVoteLeader</span><span class="token punctuation">(</span>sentinelRedisInstance <span class="token operator">*</span>master<span class="token punctuation">,</span> uint64_t req_epoch<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>req_runid<span class="token punctuation">,</span> uint64_t <span class="token operator">*</span>leader_epoch<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>req_epoch <span class="token operator">></span> sentinel<span class="token punctuation">.</span>current_epoch<span class="token punctuation">)</span> <span class="token punctuation">{</span>        sentinel<span class="token punctuation">.</span>current_epoch <span class="token operator">=</span> req_epoch<span class="token punctuation">;</span>        <span class="token function">sentinelFlushConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sentinelEvent</span><span class="token punctuation">(</span>REDIS_WARNING<span class="token punctuation">,</span><span class="token string">"+new-epoch"</span><span class="token punctuation">,</span>master<span class="token punctuation">,</span><span class="token string">"%llu"</span><span class="token punctuation">,</span>            <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span> sentinel<span class="token punctuation">.</span>current_epoch<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>master<span class="token operator">-></span>leader_epoch <span class="token operator">&lt;</span> req_epoch <span class="token operator">&amp;&amp;</span> sentinel<span class="token punctuation">.</span>current_epoch <span class="token operator">&lt;=</span> req_epoch<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">sdsfree</span><span class="token punctuation">(</span>master<span class="token operator">-></span>leader<span class="token punctuation">)</span><span class="token punctuation">;</span>        master<span class="token operator">-></span>leader <span class="token operator">=</span> <span class="token function">sdsnew</span><span class="token punctuation">(</span>req_runid<span class="token punctuation">)</span><span class="token punctuation">;</span>        master<span class="token operator">-></span>leader_epoch <span class="token operator">=</span> sentinel<span class="token punctuation">.</span>current_epoch<span class="token punctuation">;</span>        <span class="token function">sentinelFlushConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sentinelEvent</span><span class="token punctuation">(</span>REDIS_WARNING<span class="token punctuation">,</span><span class="token string">"+vote-for-leader"</span><span class="token punctuation">,</span>master<span class="token punctuation">,</span><span class="token string">"%s %llu"</span><span class="token punctuation">,</span>            master<span class="token operator">-></span>leader<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span> master<span class="token operator">-></span>leader_epoch<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* If we did not voted for ourselves, set the master failover start         * time to now, in order to force a delay before we can start a         * failover for the same master. */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>master<span class="token operator">-></span>leader<span class="token punctuation">,</span>server<span class="token punctuation">.</span>runid<span class="token punctuation">)</span><span class="token punctuation">)</span>            master<span class="token operator">-></span>failover_start_time <span class="token operator">=</span> <span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span>SENTINEL_MAX_DESYNC<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">*</span>leader_epoch <span class="token operator">=</span> master<span class="token operator">-></span>leader_epoch<span class="token punctuation">;</span>    <span class="token keyword">return</span> master<span class="token operator">-></span>leader <span class="token operator">?</span> <span class="token function">sdsnew</span><span class="token punctuation">(</span>master<span class="token operator">-></span>leader<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>前面说到 <strong>Candidate</strong> 开始竞选后，会把当前 <code>epoch</code> 加1，这样就比 <strong>Follower</strong> 大 <strong>1</strong> ，Follower 收到<strong>第一个</strong> Candidate 的投票后，因为自己当前的 epoch 比 Candidate <strong>小</strong>，所以<strong>把当前的 epoch 改成第一个 Candidate 的<code>epoch</code> ，然后把自己认为的 Leader 设置成该 Candidate</strong> 。然后其他 Candidate 再发起对该 Follower 的投票时，由于这些 Candidate 的 epoch 与自己选出 Leader 的 epoch 一样，所以<strong>不会再改变</strong>自己认为的 Leader 。这样，在一个 epoch 内，Follower 就只能投出一票，给它第一个收到投票请求的 Candidate 。最后有个 <code>if (strcasecmp(master-&gt;leader,server.runid))</code> ，这个是为了设置 <code>failover_start_time</code> ，这样 Follower 在当前 epoch 内，就无法成为 Candidate 了。</p><h4 id="Sentinel-执行任务的状态机"><a href="#Sentinel-执行任务的状态机" class="headerlink" title="Sentinel 执行任务的状态机"></a>Sentinel 执行任务的状态机</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sentinelFailoverStateMachine</span><span class="token punctuation">(</span>sentinelRedisInstance <span class="token operator">*</span>ri<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">redisAssert</span><span class="token punctuation">(</span>ri<span class="token operator">-></span>flags <span class="token operator">&amp;</span> SRI_MASTER<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>ri<span class="token operator">-></span>flags <span class="token operator">&amp;</span> SRI_FAILOVER_IN_PROGRESS<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span>ri<span class="token operator">-></span>failover_state<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> SENTINEL_FAILOVER_STATE_WAIT_START<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">// 统计选票，查看是否成为leader</span>            <span class="token function">sentinelFailoverWaitStart</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> SENTINEL_FAILOVER_STATE_SELECT_SLAVE<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">// 从slave列表中选出最佳slave</span>            <span class="token function">sentinelFailoverSelectSlave</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">// 把选出的slave设置为master</span>            <span class="token function">sentinelFailoverSendSlaveOfNoOne</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> SENTINEL_FAILOVER_STATE_WAIT_PROMOTION<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">// 等待升级生效，如果升级超时，那么重新选择新主服务器</span>            <span class="token function">sentinelFailoverWaitPromotion</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> SENTINEL_FAILOVER_STATE_RECONF_SLAVES<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">// 向从服务器发送 SLAVEOF 命令，让它们同步新主服务器</span>            <span class="token function">sentinelFailoverReconfNextSlave</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Sentinel 处理故障转移流程是采用<strong>状态处理</strong>的模式，不同状态处理不同任务，任务完成后更新状态到下一个状态。<code>sentinelFailoverStateMachine</code> 函数根据 <code>failover_state</code> 决定进入什么流程。在 <code>sentinelFailoverWaitStart</code> 函数里面，Leader 就被选出了，其他几个状态是 Leader 进行故障转移的流程。</p><h4 id="确认自己是否成为-Leader"><a href="#确认自己是否成为-Leader" class="headerlink" title="确认自己是否成为 Leader"></a>确认自己是否成为 Leader</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sentinelFailoverWaitStart</span><span class="token punctuation">(</span>sentinelRedisInstance <span class="token operator">*</span>ri<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>leader<span class="token punctuation">;</span>    <span class="token keyword">int</span> isleader<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* Check if we are the leader for the failover epoch. */</span>    <span class="token comment" spellcheck="true">// 获取给定纪元的领头 Sentinel</span>    leader <span class="token operator">=</span> <span class="token function">sentinelGetLeader</span><span class="token punctuation">(</span>ri<span class="token punctuation">,</span> ri<span class="token operator">-></span>failover_epoch<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 本 Sentinel 是否为领头 Sentinel ？</span>    isleader <span class="token operator">=</span> leader <span class="token operator">&amp;&amp;</span> <span class="token function">strcasecmp</span><span class="token punctuation">(</span>leader<span class="token punctuation">,</span>server<span class="token punctuation">.</span>runid<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">sdsfree</span><span class="token punctuation">(</span>leader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* If I'm not the leader, and it is not a forced failover via     * SENTINEL FAILOVER, then I can't continue with the failover. */</span>    <span class="token comment" spellcheck="true">// 如果本 Sentinel 不是领头，并且这次故障迁移不是一次强制故障迁移操作</span>    <span class="token comment" spellcheck="true">// 那么本 Sentinel 不做动作</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isleader <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>ri<span class="token operator">-></span>flags <span class="token operator">&amp;</span> SRI_FORCE_FAILOVER<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> election_timeout <span class="token operator">=</span> SENTINEL_ELECTION_TIMEOUT<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* The election timeout is the MIN between SENTINEL_ELECTION_TIMEOUT         * and the configured failover timeout. */</span>        <span class="token comment" spellcheck="true">// 当选的时长（类似于任期）是 SENTINEL_ELECTION_TIMEOUT</span>        <span class="token comment" spellcheck="true">// 和 Sentinel 设置的故障迁移时长之间的较小那个值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>election_timeout <span class="token operator">></span> ri<span class="token operator">-></span>failover_timeout<span class="token punctuation">)</span>            election_timeout <span class="token operator">=</span> ri<span class="token operator">-></span>failover_timeout<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* Abort the failover if I'm not the leader after some time. */</span>        <span class="token comment" spellcheck="true">// Sentinel 的当选时间已过，取消故障转移计划</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> ri<span class="token operator">-></span>failover_start_time <span class="token operator">></span> election_timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">sentinelEvent</span><span class="token punctuation">(</span>REDIS_WARNING<span class="token punctuation">,</span><span class="token string">"-failover-abort-not-elected"</span><span class="token punctuation">,</span>ri<span class="token punctuation">,</span><span class="token string">"%@"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 取消故障转移</span>            <span class="token function">sentinelAbortFailover</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 本 Sentinel 作为领头，开始执行故障迁移操作...</span>    <span class="token function">sentinelEvent</span><span class="token punctuation">(</span>REDIS_WARNING<span class="token punctuation">,</span><span class="token string">"+elected-leader"</span><span class="token punctuation">,</span>ri<span class="token punctuation">,</span><span class="token string">"%@"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 进入选择从服务器状态</span>    ri<span class="token operator">-></span>failover_state <span class="token operator">=</span> SENTINEL_FAILOVER_STATE_SELECT_SLAVE<span class="token punctuation">;</span>    ri<span class="token operator">-></span>failover_state_change_time <span class="token operator">=</span> <span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sentinelEvent</span><span class="token punctuation">(</span>REDIS_WARNING<span class="token punctuation">,</span><span class="token string">"+failover-state-select-slave"</span><span class="token punctuation">,</span>ri<span class="token punctuation">,</span><span class="token string">"%@"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>前面说到的 <code>sentinelStartFailover</code> 把 <code>failover_state</code> 设置成 <strong>SENTINEL_FAILOVER_STATE_WAIT_START</strong> ，于是进入 <code>sentinelFailoverWaitStart</code> 。</p><p><code>sentinelFailoverWaitStart</code> 会先查看 Leader 是否已经选出。如果 Leader 是自己或者这是一次强制故障转移，<code>failover_state</code> 就设置为 <strong>SENTINEL_FAILOVER_STATE_SELECT_SLAVE</strong> 。强制故障转移是通过 Sentinel 的 <strong>SENTINEL FAILOVER</strong> 命令设置的，这里不做讨论。</p><p>如果自己当选 Leader ，就会进入下一个任务处理状态，开始故障转移流程。如果在 <code>election_timeout</code> 内还没当选为 Leader ，那么本次 <code>epoch</code> 内，<strong>Candidate</strong> 就没有当选，需要等待 <code>failover_timeout</code> 超时，进入下一次竞选，或者本次 <code>epoch</code> 内，有 Leader 被选出，自己变会 <strong>Follower</strong> 。</p><h4 id="统计投票"><a href="#统计投票" class="headerlink" title="统计投票"></a>统计投票</h4><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Scan all the Sentinels attached to this master to check if there * is a leader for the specified epoch. * * 扫描所有监视 master 的 Sentinels ，查看是否有 Sentinels 是这个纪元的领头。 * * To be a leader for a given epoch, we should have the majorify of * the Sentinels we know that reported the same instance as * leader for the same epoch.  * * 要让一个 Sentinel 成为本纪元的领头， * 这个 Sentinel 必须让大多数其他 Sentinel 承认它是该纪元的领头才行。 */</span><span class="token comment" spellcheck="true">// 选举出 master 在指定 epoch 上的领头</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">sentinelGetLeader</span><span class="token punctuation">(</span>sentinelRedisInstance <span class="token operator">*</span>master<span class="token punctuation">,</span> uint64_t epoch<span class="token punctuation">)</span> <span class="token punctuation">{</span>    dict <span class="token operator">*</span>counters<span class="token punctuation">;</span>    dictIterator <span class="token operator">*</span>di<span class="token punctuation">;</span>    dictEntry <span class="token operator">*</span>de<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> voters <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> voters_quorum<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>myvote<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>winner <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    uint64_t leader_epoch<span class="token punctuation">;</span>    uint64_t max_votes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">redisAssert</span><span class="token punctuation">(</span>master<span class="token operator">-></span>flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>SRI_O_DOWN<span class="token operator">|</span>SRI_FAILOVER_IN_PROGRESS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 统计器</span>    counters <span class="token operator">=</span> <span class="token function">dictCreate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>leaderVotesDictType<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Count other sentinels votes */</span>    <span class="token comment" spellcheck="true">// 统计其他 sentinel 的主观 leader 投票</span>    di <span class="token operator">=</span> <span class="token function">dictGetIterator</span><span class="token punctuation">(</span>master<span class="token operator">-></span>sentinels<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>de <span class="token operator">=</span> <span class="token function">dictNext</span><span class="token punctuation">(</span>di<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sentinelRedisInstance <span class="token operator">*</span>ri <span class="token operator">=</span> <span class="token function">dictGetVal</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 为目标 Sentinel 选出的领头 Sentinel 增加一票</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ri<span class="token operator">-></span>leader <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> ri<span class="token operator">-></span>leader_epoch <span class="token operator">==</span> sentinel<span class="token punctuation">.</span>current_epoch<span class="token punctuation">)</span>            <span class="token function">sentinelLeaderIncr</span><span class="token punctuation">(</span>counters<span class="token punctuation">,</span>ri<span class="token operator">-></span>leader<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 统计投票数量</span>        voters<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">dictReleaseIterator</span><span class="token punctuation">(</span>di<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Check what's the winner. For the winner to win, it needs two conditions:     *     * 选出领头 leader ，它必须满足以下两个条件：     *     * 1) Absolute majority between voters (50% + 1).     *    有多于一般的 Sentinel 支持     * 2) And anyway at least master->quorum votes.      *    投票数至少要有 master->quorum 那么多     */</span>    di <span class="token operator">=</span> <span class="token function">dictGetIterator</span><span class="token punctuation">(</span>counters<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>de <span class="token operator">=</span> <span class="token function">dictNext</span><span class="token punctuation">(</span>di<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 取出票数</span>        uint64_t votes <span class="token operator">=</span> <span class="token function">dictGetUnsignedIntegerVal</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 选出票数最大的人</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>votes <span class="token operator">></span> max_votes<span class="token punctuation">)</span> <span class="token punctuation">{</span>            max_votes <span class="token operator">=</span> votes<span class="token punctuation">;</span>            winner <span class="token operator">=</span> <span class="token function">dictGetKey</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">dictReleaseIterator</span><span class="token punctuation">(</span>di<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Count this Sentinel vote:     * if this Sentinel did not voted yet, either vote for the most     * common voted sentinel, or for itself if no vote exists at all. */</span>    <span class="token comment" spellcheck="true">// 本 Sentinel 进行投票</span>    <span class="token comment" spellcheck="true">// 如果 Sentinel 之前还没有进行投票，那么有两种选择：</span>    <span class="token comment" spellcheck="true">// 1）如果选出了 winner （最多票数支持的 Sentinel ），那么这个 Sentinel 也投 winner 一票</span>    <span class="token comment" spellcheck="true">// 2）如果没有选出 winner ，那么 Sentinel 投自己一票</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>winner<span class="token punctuation">)</span>        myvote <span class="token operator">=</span> <span class="token function">sentinelVoteLeader</span><span class="token punctuation">(</span>master<span class="token punctuation">,</span>epoch<span class="token punctuation">,</span>winner<span class="token punctuation">,</span><span class="token operator">&amp;</span>leader_epoch<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        myvote <span class="token operator">=</span> <span class="token function">sentinelVoteLeader</span><span class="token punctuation">(</span>master<span class="token punctuation">,</span>epoch<span class="token punctuation">,</span>server<span class="token punctuation">.</span>runid<span class="token punctuation">,</span><span class="token operator">&amp;</span>leader_epoch<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 领头 Sentinel 已选出，并且领头的纪元和给定的纪元一样</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>myvote <span class="token operator">&amp;&amp;</span> leader_epoch <span class="token operator">==</span> epoch<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 为领头 Sentinel 增加一票（这一票来自本 Sentinel ）</span>        uint64_t votes <span class="token operator">=</span> <span class="token function">sentinelLeaderIncr</span><span class="token punctuation">(</span>counters<span class="token punctuation">,</span>myvote<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果投票之后的票数比最大票数要大，那么更换领头 Sentinel</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>votes <span class="token operator">></span> max_votes<span class="token punctuation">)</span> <span class="token punctuation">{</span>            max_votes <span class="token operator">=</span> votes<span class="token punctuation">;</span>            winner <span class="token operator">=</span> myvote<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    voters<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* Anyway, count me as one of the voters. */</span>    <span class="token comment" spellcheck="true">// 如果支持领头的投票数量不超过半数</span>    <span class="token comment" spellcheck="true">// 并且支持票数不超过 master 配置指定的投票数量</span>    <span class="token comment" spellcheck="true">// 那么这次领头选举无效</span>    voters_quorum <span class="token operator">=</span> voters<span class="token operator">/</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>winner <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>max_votes <span class="token operator">&lt;</span> voters_quorum <span class="token operator">||</span> max_votes <span class="token operator">&lt;</span> master<span class="token operator">-></span>quorum<span class="token punctuation">)</span><span class="token punctuation">)</span>        winner <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 返回领头 Sentinel ，或者 NULL</span>    winner <span class="token operator">=</span> winner <span class="token operator">?</span> <span class="token function">sdsnew</span><span class="token punctuation">(</span>winner<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token function">sdsfree</span><span class="token punctuation">(</span>myvote<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dictRelease</span><span class="token punctuation">(</span>counters<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> winner<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>sentinelGetLeader</code> 会统计所有其他 Sentinel 的投票结果，如果投票结果中有个 Sentinel 获得了<strong>超过半数且超过 Master 的 quorum</strong> ，那么 Leader 就被选出了。</p><p><strong>Candidate</strong> 第一次进入 <code>sentinelGetLeader</code> 函数的时候是还没向其他 Sentinel 发起投票，winner 为 <strong>NULL</strong> ，于是就会给自己投上一票，这就是前面 <strong>Raft</strong> 协议说到的，在开始竞选前“ <code>给自己投一票</code> “，这样竞选前的 4 个步骤就全部完成了。以后再进入 <code>sentinelGetLeader</code> 就可以统计其他 Sentinel 的投票数目。当发现有个 Sentinel 的投票数据超过半数且超过 <code>quorum</code> ，就会返回该 Sentinel ，<code>sentinelFailoverWaitStart</code> 会判断该 Sentinel 是否是自己，如果是自己，那么自己就成为了 Leader ，开始进行故障转移，不是自己，那么等待竞选超时，成为 <strong>Follower</strong> 。</p><h4 id="关于-Leader-通知其他-Sentinel-自己成为-Leader-的说明"><a href="#关于-Leader-通知其他-Sentinel-自己成为-Leader-的说明" class="headerlink" title="关于 Leader 通知其他 Sentinel 自己成为 Leader 的说明"></a>关于 Leader 通知其他 Sentinel 自己成为 Leader 的说明</h4><p>在 Sentinel 的实现里面，关于 Leader 发送竞选成功的消息给其他 Sentinel ，并没有专门的逻辑。某个 Sentinel 成为 Leader 后，他就默默地干起活。故障转移中 Leader 通过获取选出的 Slave 的 <strong>INFO</strong> 信息，发现其确认了 Master 身份，Leader 就会修改 <code>config_epoch</code> 为最新的 <code>epoch</code> 。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Process the INFO output from masters and slaves. */</span><span class="token comment" spellcheck="true">// 从主服务器或者从服务器所返回的 INFO 命令的回复中分析相关信息</span><span class="token keyword">void</span> <span class="token function">sentinelRefreshInstanceInfo</span><span class="token punctuation">(</span>sentinelRedisInstance <span class="token operator">*</span>ri<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>info<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">/* Handle slave -> master role switch. */</span>    <span class="token comment" spellcheck="true">// 处理从服务器转变为主服务器的情况</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ri<span class="token operator">-></span>flags <span class="token operator">&amp;</span> SRI_SLAVE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> role <span class="token operator">==</span> SRI_MASTER<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* If this is a promoted slave we can change state to the         * failover state machine. */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ri<span class="token operator">-></span>master<span class="token operator">-></span>flags <span class="token operator">&amp;</span> SRI_FAILOVER_IN_PROGRESS<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span>ri<span class="token operator">-></span>master<span class="token operator">-></span>failover_state <span class="token operator">==</span>                SENTINEL_FAILOVER_STATE_WAIT_PROMOTION<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* Now that we are sure the slave was reconfigured as a master             * set the master configuration epoch to the epoch we won the             * election to perform this failover. This will force the other             * Sentinels to update their config (assuming there is not             * a newer one already available). */</span>            <span class="token comment" spellcheck="true">// 更新从服务器的主服务器（已下线）的配置纪元</span>            ri<span class="token operator">-></span>master<span class="token operator">-></span>config_epoch <span class="token operator">=</span> ri<span class="token operator">-></span>master<span class="token operator">-></span>failover_epoch<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 设置从服务器的主服务器（已下线）的故障转移状态，这个状态会让从服务器开始同步新的主服务器</span>            ri<span class="token operator">-></span>master<span class="token operator">-></span>failover_state <span class="token operator">=</span> SENTINEL_FAILOVER_STATE_RECONF_SLAVES<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 更新从服务器的主服务器（已下线）的故障转移状态变更时间</span>            ri<span class="token operator">-></span>master<span class="token operator">-></span>failover_state_change_time <span class="token operator">=</span> <span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 将当前 Sentinel 状态保存到配置文件里面</span>            <span class="token function">sentinelFlushConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 发送事件</span>            <span class="token function">sentinelEvent</span><span class="token punctuation">(</span>REDIS_WARNING<span class="token punctuation">,</span><span class="token string">"+promoted-slave"</span><span class="token punctuation">,</span>ri<span class="token punctuation">,</span><span class="token string">"%@"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sentinelEvent</span><span class="token punctuation">(</span>REDIS_WARNING<span class="token punctuation">,</span><span class="token string">"+failover-state-reconf-slaves"</span><span class="token punctuation">,</span>                ri<span class="token operator">-></span>master<span class="token punctuation">,</span><span class="token string">"%@"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 执行脚本</span>            <span class="token function">sentinelCallClientReconfScript</span><span class="token punctuation">(</span>ri<span class="token operator">-></span>master<span class="token punctuation">,</span>SENTINEL_LEADER<span class="token punctuation">,</span>                <span class="token string">"start"</span><span class="token punctuation">,</span>ri<span class="token operator">-></span>master<span class="token operator">-></span>addr<span class="token punctuation">,</span>ri<span class="token operator">-></span>addr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sentinelForceHelloUpdateForMaster</span><span class="token punctuation">(</span>ri<span class="token operator">-></span>master<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p><code>config_epoch</code> 会通过 <strong>hello</strong> 频道发送给其他 Sentinel 。其他 Sentinel 发现 <code>config_epoch</code> 更新了，就会更新最新的 <code>Master</code> 地址和 <code>config_epoch</code> 。<strong>这相当于 Leader 把当选消息告知了其他 Sentinel 。</strong></p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Process an hello message received via Pub/Sub in master or slave instance, * or sent directly to this sentinel via the (fake) PUBLISH command of Sentinel. * * If the master name specified in the message is not known, the message is * discarded. */</span><span class="token keyword">void</span> <span class="token function">sentinelProcessHelloMessage</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>hello<span class="token punctuation">,</span> <span class="token keyword">int</span> hello_len<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">/* Update master info if received configuration is newer. */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>master<span class="token operator">-></span>config_epoch <span class="token operator">&lt;</span> master_config_epoch<span class="token punctuation">)</span> <span class="token punctuation">{</span>            master<span class="token operator">-></span>config_epoch <span class="token operator">=</span> master_config_epoch<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>master_port <span class="token operator">!=</span> master<span class="token operator">-></span>addr<span class="token operator">-></span>port <span class="token operator">||</span>                <span class="token function">strcmp</span><span class="token punctuation">(</span>master<span class="token operator">-></span>addr<span class="token operator">-></span>ip<span class="token punctuation">,</span> token<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                sentinelAddr <span class="token operator">*</span>old_addr<span class="token punctuation">;</span>                <span class="token function">sentinelEvent</span><span class="token punctuation">(</span>REDIS_WARNING<span class="token punctuation">,</span><span class="token string">"+config-update-from"</span><span class="token punctuation">,</span>si<span class="token punctuation">,</span><span class="token string">"%@"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">sentinelEvent</span><span class="token punctuation">(</span>REDIS_WARNING<span class="token punctuation">,</span><span class="token string">"+switch-master"</span><span class="token punctuation">,</span>                    master<span class="token punctuation">,</span><span class="token string">"%s %s %d %s %d"</span><span class="token punctuation">,</span>                    master<span class="token operator">-></span>name<span class="token punctuation">,</span>                    master<span class="token operator">-></span>addr<span class="token operator">-></span>ip<span class="token punctuation">,</span> master<span class="token operator">-></span>addr<span class="token operator">-></span>port<span class="token punctuation">,</span>                    token<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> master_port<span class="token punctuation">)</span><span class="token punctuation">;</span>                old_addr <span class="token operator">=</span> <span class="token function">dupSentinelAddr</span><span class="token punctuation">(</span>master<span class="token operator">-></span>addr<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">sentinelResetMasterAndChangeAddress</span><span class="token punctuation">(</span>master<span class="token punctuation">,</span> token<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> master_port<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">sentinelCallClientReconfScript</span><span class="token punctuation">(</span>master<span class="token punctuation">,</span>                    SENTINEL_OBSERVER<span class="token punctuation">,</span><span class="token string">"start"</span><span class="token punctuation">,</span>                    old_addr<span class="token punctuation">,</span>master<span class="token operator">-></span>addr<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">releaseSentinelAddr</span><span class="token punctuation">(</span>old_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><a href="https://redis.io/topics/sentinel" target="_blank" rel="noopener">https://redis.io/topics/sentinel</a></p></li><li><p>《In Search of an Understandable Consensus Algorithm》 Diego Ongaro and John Ousterhout Stanford University</p></li><li><p>《Redis设计与实现》黄健宏 机械工业出版社</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Raft </tag>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Sentinel</title>
      <link href="/2020/04/29/shu-ju-ku/redis-sentinel/"/>
      <url>/2020/04/29/shu-ju-ku/redis-sentinel/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-Sentinel"><a href="#Redis-Sentinel" class="headerlink" title="Redis Sentinel"></a>Redis Sentinel</h1><h2 id="哨兵的介绍"><a href="#哨兵的介绍" class="headerlink" title="哨兵的介绍"></a>哨兵的介绍</h2><p><strong>Sentinel</strong> ，中文名是哨兵。哨兵是 Redis 集群架构中非常重要的一个组件，主要有以下功能：</p><ul><li><strong>集群监控：</strong>负责监控 Redis Master 和 Slave 进程是否正常工作。</li><li><strong>消息通知：</strong>如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li><li><strong>故障转移：</strong>如果 Master Node 挂掉了，会自动转移到 Slave Node 上。</li><li><strong>配置中心：</strong>如果故障转移发生了，通知 Client 客户端新的 Master 地址。</li></ul><p>哨兵用于实现 Redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p><ul><li>故障转移时，判断一个 Master Node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。</li><li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。</li></ul><h2 id="哨兵的核心知识"><a href="#哨兵的核心知识" class="headerlink" title="哨兵的核心知识"></a>哨兵的核心知识</h2><ul><li>哨兵至少需要 3 个实例，来保证自己的健壮性。</li><li>哨兵 + Redis 主从的部署架构，是<strong>不保证数据零丢失</strong>的，只能保证 Redis 集群的<strong>高可用</strong>性。</li><li>对于哨兵 + Redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</li></ul><p>哨兵集群必须部署 2 个以上节点，如果哨兵集群仅仅部署了 2 个哨兵实例，quorum = 1 。</p><p><img src="https://s1.ax1x.com/2020/04/24/JDry4I.jpg" alt="两个哨兵集群"></p><p>配置 <code>quorum = 1</code> ，如果 Master 宕机， S1 和 S2 中只要有 1 个哨兵认为 Master 宕机了，就可以进行切换，同时 S1 和 S2 会选举出一个哨兵来执行故障转移。但是同时这个时候，需要 Majority，也就是大多数哨兵都是运行的。</p><pre class=" language-java"><code class="language-java"><span class="token number">2</span> 个哨兵，majority<span class="token operator">=</span><span class="token number">2</span><span class="token number">3</span> 个哨兵，majority<span class="token operator">=</span><span class="token number">2</span><span class="token number">4</span> 个哨兵，majority<span class="token operator">=</span><span class="token number">2</span><span class="token number">5</span> 个哨兵，majority<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><p>如果此时仅仅是 M1 进程宕机了，哨兵 S1 正常运行，那么故障转移是 OK 的。但是如果是整个 M1 和 S1 运行的机器宕机了，那么哨兵只有 1 个，此时就没有 Majority 来允许执行故障转移，虽然另外一台机器上还有一个 R1 ，但是故障转移不会执行。</p><p>经典的 3 节点哨兵集群是这样的：</p><p><img src="https://s1.ax1x.com/2020/04/24/JDsCP1.jpg" alt="经典的三哨兵集群"></p><p>配置 <code>quorum = 2</code> ，如果 M1 所在机器宕机了，那么三个哨兵还剩下 2 个，S2 和 S3 可以一致认为 Master 宕机了，然后选举出一个来执行故障转移，同时 3 个哨兵的 Majority 是 2 ，所以还剩下的 2 个哨兵运行着，就可以允许执行故障转移。</p><h2 id="Redis-哨兵主备切换的数据丢失问题"><a href="#Redis-哨兵主备切换的数据丢失问题" class="headerlink" title="Redis 哨兵主备切换的数据丢失问题"></a>Redis 哨兵主备切换的数据丢失问题</h2><h3 id="导致数据丢失的两种情况"><a href="#导致数据丢失的两种情况" class="headerlink" title="导致数据丢失的两种情况"></a>导致数据丢失的两种情况</h3><p>主备切换的过程，可能会导致数据丢失：</p><ul><li><strong>异步复制导致的数据丢失</strong></li></ul><p>因为 Master -&gt; Slave 的复制是异步的，所以可能有部分数据还没复制到 Slave ，Master 就宕机了，此时这部分数据就丢失了。</p><p><img src="https://s1.ax1x.com/2020/04/29/JT6SxI.png" alt="async-replication-data-lose-case"></p><ul><li><strong>脑裂导致的数据丢失</strong></li></ul><p>脑裂，也就是说，某个 Master 所在机器突然<strong>脱离了正常的网络</strong>，跟其他 Slave 机器不能连接，但是实际上 Master 还运行着。此时哨兵可能就会<strong>认为</strong> Master 宕机了，然后开启选举，将其他 Slave 切换成了 Master 。这个时候，集群里就会有两个 Master ，也就是所谓的<strong>脑裂</strong>。</p><p>此时虽然某个 Slave 被切换成了 Master，但是可能 Client 还没来得及切换到新的 Master，还继续向旧 Master 写数据。因此旧 Master 再次恢复的时候，会被作为一个 Slave 挂到新的 Master 上去，自己的数据会清空，重新从新的 Master 复制数据。而新的 Master 并没有后来 Client 写入的数据，因此，这部分数据也就丢失了。</p><p><img src="https://s1.ax1x.com/2020/04/29/JT6BdO.png" alt="redis-cluster-split-brain"></p><h3 id="数据丢失问题的解决方案"><a href="#数据丢失问题的解决方案" class="headerlink" title="数据丢失问题的解决方案"></a>数据丢失问题的解决方案</h3><p>进行如下配置：</p><pre class=" language-bash"><code class="language-bash">min-slaves-to-write 1min-slaves-max-lag 10</code></pre><p>表示，要求至少有 1 个 Slave ，数据复制和同步的延迟不能超过 10 秒。</p><p>如果说一旦所有的 Slave ，数据复制和同步的延迟都超过了 10 秒钟，那么这个时候，Master 就不会再接收任何请求了。</p><ul><li><strong>减少异步复制数据的丢失</strong></li></ul><p>有了 <code>min-slaves-max-lag</code> 这个配置，就可以确保说，一旦 Slave 复制数据和 ACK 延时太长，就认为可能 Master 宕机后损失的数据太多了，那么就拒绝写请求，这样可以把 Master 宕机时由于部分数据未同步到 Slave 导致的数据丢失降低的可控范围内。</p><ul><li><strong>减少脑裂的数据丢失</strong></li></ul><p>如果一个 Master 出现了脑裂，跟其他 Slave 丢了连接，那么上面两个配置可以确保说，如果不能继续给指定数量的 Slave 发送数据，而且 Slave 超过 10 秒没有给自己 ACK 消息，那么就直接拒绝客户端的写请求。因此在脑裂场景下，最多就丢失 10 秒的数据。</p><h2 id="sdown-和-odown-转换机制"><a href="#sdown-和-odown-转换机制" class="headerlink" title="sdown 和 odown 转换机制"></a>sdown 和 odown 转换机制</h2><ul><li><code>sdown</code> 是主观宕机，就一个哨兵如果自己觉得一个 Master 宕机了，那么就是主观宕机。</li><li><code>odown</code> 是客观宕机，如果 <code>quorum</code> 数量的哨兵都觉得一个 Master 宕机了，那么就是客观宕机。</li></ul><p>sdown 达成的条件很简单，如果一个哨兵 <code>ping</code> 一个 Master，超过了 <code>is-master-down-after-milliseconds</code> 指定的毫秒数之后，就主观认为 Master 宕机了；如果一个哨兵在指定时间内，收到了 quorum 数量的其它哨兵也认为那个 Master 是 sdown 的，那么就认为是 odown 了。</p><h2 id="哨兵集群的自动发现机制"><a href="#哨兵集群的自动发现机制" class="headerlink" title="哨兵集群的自动发现机制"></a>哨兵集群的自动发现机制</h2><p>哨兵互相之间的发现，是通过 Redis 的 <code>Pub/Sub</code> 系统实现的，每个哨兵都会往 <code>__sentinel__:hello</code> 这个 Channel 里发送一个消息，这时候所有其他哨兵都可以消费到这个消息，并感知到其他的哨兵的存在。</p><p>每隔两秒钟，每个哨兵都会往自己监控的某个 Master + Slaves 对应的 <code>__sentinel__:hello</code> Channel 里<strong>发送一个消息</strong>，内容是自己的 Host 、IP 和 Run ID 还有对这个 Master 的监控配置。</p><p>每个哨兵也会去<strong>监听</strong>自己监控的每个 Master + Slaves 对应的 <code>__sentinel__:hello</code> Channel，然后去感知到同样在监听这个 Master + Slaves 的其他哨兵的存在。</p><p>每个哨兵还会跟其他哨兵交换对 <code>Master</code> 的监控配置，互相进行监控配置的同步。</p><h2 id="Slave-配置的自动纠正"><a href="#Slave-配置的自动纠正" class="headerlink" title="Slave 配置的自动纠正"></a>Slave 配置的自动纠正</h2><p>哨兵会负责自动纠正 Slave 的一些配置，比如 Slave 如果要成为潜在的 Master 候选人，哨兵会确保 Slave 复制现有 Master 的数据；如果 Slave 连接到了一个错误的 Master 上，比如故障转移之后，那么哨兵会确保它们连接到正确的 Master 上。</p><h2 id="Slave-gt-Master-选举算法"><a href="#Slave-gt-Master-选举算法" class="headerlink" title="Slave -&gt; Master 选举算法"></a>Slave -&gt; Master 选举算法</h2><p>如果一个 Master 被认为 <code>odown</code> 了，而且 Majority 数量的哨兵都允许主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个 Slave 来，会考虑 Slave 的一些信息：</p><ul><li>跟 Master 断开连接的时长</li><li>Slave 优先级</li><li>复制 offset</li><li>Run ID</li></ul><p>如果一个 Slave 跟 Master 断开连接的时间已经超过了 <code>down-after-milliseconds</code> 的 10 倍，外加 Master 宕机的时长，那么 Slave 就被认为不适合选举为 Master 。</p><blockquote><p><strong>(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state</strong></p></blockquote><p><strong>接下来会对 Slave 进行排序：</strong></p><ul><li>按照 Slave 优先级进行排序，Slave Priority 越低，优先级就越高。</li><li>如果 Slave Priority 相同，那么看 Replica offset，哪个 Slave 复制了越多的数据，offset 越靠后，优先级就越高。</li><li>如果上面两个条件都相同，那么选择一个 Run ID 比较小的那个 Slave 。</li></ul><h2 id="Quorum-和-Majority"><a href="#Quorum-和-Majority" class="headerlink" title="Quorum 和 Majority"></a>Quorum 和 Majority</h2><p>每次一个哨兵要做主备切换，首先需要 quorum 数量的哨兵认为 <code>odown</code> ，然后选举出一个哨兵来做切换，这个哨兵还需要得到 majority 哨兵的授权，才能正式执行切换。</p><p>如果 quorum &lt; majority ，比如 5 个哨兵，majority 就是 3 ，quorum 设置为 2 ，那么只需 3 个哨兵授权就可以执行切换。</p><p>但是如果 quorum &gt;= majority ，那么必须 quorum 数量的哨兵都授权，比如 5 个哨兵，quorum 是 5 ，那么必须 5 个哨兵都同意授权，才能执行切换。</p><h2 id="Configuration-Epoch"><a href="#Configuration-Epoch" class="headerlink" title="Configuration Epoch"></a>Configuration Epoch</h2><p>哨兵会对一套 <strong>Redis Master + Slaves</strong> 进行监控，有相应的监控的配置。</p><p>执行切换的那个哨兵，会从要切换到的新 Master（ Salve -&gt; Master ）那里得到一个 <strong>Configuration Epoch</strong> ，这就是一个 <strong>Version</strong> 号，每次切换的 Version 号都必须是<strong>唯一</strong>的。</p><p>如果第一个选举出的哨兵切换失败了，那么其他哨兵，会等待 <code>failover-timeout</code> 时间，然后接替继续执行切换，此时会重新获取一个新的 <strong>Configuration Epoch</strong> ，作为新的 Version 号。</p><h2 id="Configuration-传播"><a href="#Configuration-传播" class="headerlink" title="Configuration 传播"></a>Configuration 传播</h2><p>哨兵完成切换之后，会在自己本地更新生成最新的 Master 配置，然后同步给其他的哨兵，就是通过之前说的 <code>Pub/Sub</code> 消息机制。</p><p>这里之前的 Version 号就很重要了，因为各种消息都是通过一个 <strong>Channel</strong> 去发布和监听的，所以一个哨兵完成一次新的切换之后，新的 Master 配置是跟着新的 Version 号的。其他的哨兵都是根据版本号的大小来更新自己的 Master 配置的。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Cluster</title>
      <link href="/2020/04/29/shu-ju-ku/redis-cluster/"/>
      <url>/2020/04/29/shu-ju-ku/redis-cluster/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h1><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>Redis 集群模式的工作原理能说一下么？在集群模式下，Redis 的 Key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 Hash 算法吗？</p><h2 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>在前几年，Redis 如果要搞几个节点，每个节点存储一部分的数据，得<strong>借助一些中间件</strong>来实现，比如说有 <code>codis</code> ，或者 <code>twemproxy</code> ，都有。有一些 Redis 中间件，你读写 Redis 中间件，Redis 中间件负责将你的数据分布式存储在多台机器上的 Redis 实例中。</p><p>这两年，Redis 不断在发展，Redis 也不断有新的版本，现在的 Redis 集群模式，可以做到在多台机器上，部署多个 Redis 实例，每个实例存储一部分的数据，同时每个 Redis 主实例可以挂 Redis 从实例，自动确保说，如果 Redis 主实例挂了，会自动切换到 Redis 从实例上来。</p><p>现在 Redis 的新版本，大家都是用 Redis Cluster 的，也就是 Redis 原生支持的 Redis 集群模式，那么面试官肯定会就 Redis Cluster 对你来个几连炮。要是你没用过 Redis Cluster，正常，以前很多人用 <code>codis</code> 之类的客户端来支持集群，但是起码你得研究一下 Redis Cluster 吧。</p><p>如果你的数据量很少，主要是承载高并发高性能的场景，比如你的缓存一般就几个 G ，单机就足够了，可以使用 Replication ，一个 Master 多个 Slaves ，要几个 Slave 跟你要求的读吞吐量有关，然后自己搭建一个 Sentinel 集群去保证 Redis 主从架构的高可用性。</p><p>Redis Cluster，主要是针对<strong>海量数据+高并发+高可用</strong>的场景。Redis Cluster 支撑 N 个 Redis Master Node，每个 Master Node 都可以挂载多个 Slave Node。这样整个 Redis 就可以横向扩容了。如果你要支撑更大数据量的缓存，那就横向扩容更多的 Master 节点，每个 Master 节点就能存放更多的数据了。</p><h2 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><h3 id="Redis-Cluster-介绍"><a href="#Redis-Cluster-介绍" class="headerlink" title="Redis Cluster 介绍"></a>Redis Cluster 介绍</h3><ul><li>自动将数据进行分片，每个 Master 上放一部分数据。</li><li>提供内置的高可用支持，部分 Master 不可用时，还是可以继续工作的。</li></ul><p>在 Redis Cluster 架构下，每个 Redis 要放开两个端口号，比如一个是 6379，另外一个就是加 1w 的端口号，比如 16379 。</p><p>16379 端口号是用来进行节点间通信的，也就是 <strong>Cluster Bus</strong> 的东西，Cluster Bus 的通信，用来进行故障检测、配置更新、故障转移授权。Cluster Bus 用了另外一种二进制的协议，<code>Gossip</code> 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p><h3 id="节点间的内部通信机制"><a href="#节点间的内部通信机制" class="headerlink" title="节点间的内部通信机制"></a>节点间的内部通信机制</h3><h4 id="基本通信原理"><a href="#基本通信原理" class="headerlink" title="基本通信原理"></a>基本通信原理</h4><p>集群元数据的维护有两种方式：集中式、<strong>Gossip</strong> 协议。Redis Cluster 节点间采用 <strong>Gossip</strong> 协议进行通信。</p><p><strong>集中式</strong>是将集群元数据（节点信息、故障等等）几种存储在某个节点上。集中式元数据集中存储的一个典型代表，就是大数据领域的 <code>storm</code> 。它是分布式的大数据实时计算引擎，是集中式的元数据存储的结构，底层基于 <code>zookeeper</code>（分布式协调的中间件）对所有元数据进行存储维护。</p><p><img src="https://s1.ax1x.com/2020/04/29/JoxffJ.png" alt="zookeeper-centralized-storage"></p><p>Redis 维护集群元数据采用另一个方式， <code>Gossip</code> 协议，所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。</p><p><img src="https://s1.ax1x.com/2020/04/29/JoxI61.png" alt="redis-gossip"></p><p><strong>集中式</strong>的<strong>好处</strong>在于，元数据的读取和更新，时效性非常好，一旦元数据出现了变更，就立即更新到集中式的存储中，其它节点读取的时候就可以感知到；<strong>不好</strong>在于，所有的元数据的更新压力全部集中在一个地方，可能会导致元数据的存储有压力。</p><p><strong>Gossip</strong> 的<strong>好处</strong>在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，降低了压力；<strong>不好</strong>在于，元数据的更新有延时，可能导致集群中的一些操作会有一些滞后。</p><ul><li><p><strong>10000 端口：</strong>每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如 7001，那么用于节点间通信的就是 17001 端口。每个节点每隔一段时间都会往另外几个节点发送 <code>ping</code> 消息，同时其它几个节点接收到 <code>ping</code> 之后返回 <code>pong</code> 。</p></li><li><p><strong>交换的信息：</strong>信息包括故障信息，节点的增加和删除，Hash Slot 信息等等。</p></li></ul><h4 id="Gossip-协议"><a href="#Gossip-协议" class="headerlink" title="Gossip 协议"></a>Gossip 协议</h4><p>Gossip 协议包含多种消息，包含 <code>ping</code> ，<code>pong</code> ，<code>meet</code> ，<code>fail</code> 等。</p><ul><li><strong>meet：</strong>某个节点发送 meet 给新加入的节点，让新节点加入集群中，然后新节点就会开始与其它节点进行通信。</li></ul><pre class=" language-bash"><code class="language-bash">redis-trib.rb add-node</code></pre><p>其实内部就是发送了一个 Gossip meet 消息给新加入的节点，通知那个节点去加入我们的集群。</p><ul><li><strong>ping：</strong>每个节点都会频繁给其它节点发送 ping ，其中包含自己的状态还有自己维护的集群元数据，互相通过 ping 交换元数据。</li><li><strong>pong：</strong>返回 ping 和 meet ，包含自己的状态和其它信息，也用于信息广播和更新。</li><li><strong>fail：</strong>某个节点判断另一个节点 fail 之后，就发送 fail 给其它节点，通知其它节点说，某个节点宕机啦。</li></ul><h4 id="ping-消息深入"><a href="#ping-消息深入" class="headerlink" title="ping 消息深入"></a>ping 消息深入</h4><p>ping 时要携带一些元数据，如果很频繁，可能会加重网络负担。</p><p>每个节点每秒会执行 10 次 ping ，每次会选择 5 个最久没有通信的其它节点。当然如果发现某个节点通信延时达到了 <code>cluster_node_timeout / 2</code> ，那么立即发送 ping ，避免数据交换延时过长，落后的时间太长了。比如说，两个节点之间都 10 分钟没有交换数据了，那么整个集群处于严重的元数据不一致的情况，就会有问题。所以 <code>cluster_node_timeout</code> 可以调节，如果调得比较大，那么会降低 ping 的频率。</p><p>每次 ping ，会带上自己节点的信息，还有就是带上 1/10 其它节点的信息，发送出去，进行交换。至少包含 <code>3</code> 个其它节点的信息，最多包含 <code>总节点数 - 2</code> 个其它节点的信息。</p><h3 id="分布式寻址算法"><a href="#分布式寻址算法" class="headerlink" title="分布式寻址算法"></a>分布式寻址算法</h3><ul><li>Hash 算法（大量缓存重建）</li><li>一致性 Hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</li><li>Redis Cluster 的 Hash Slot 算法</li></ul><h4 id="Hash-算法"><a href="#Hash-算法" class="headerlink" title="Hash 算法"></a>Hash 算法</h4><p>来了一个 Key ，首先计算 Hash 值，然后对节点数取模。然后打在不同的 Master 节点上。一旦某一个 Master 节点宕机，所有请求过来，都会基于最新的剩余 Master 节点数去取模，尝试去取数据。这会导致<strong>大部分的请求过来，全部无法拿到有效的缓存</strong>，导致大量的流量涌入数据库。</p><p><img src="https://s1.ax1x.com/2020/04/29/JTZegK.png" alt="hash"></p><h4 id="一致性-Hash-算法"><a href="#一致性-Hash-算法" class="headerlink" title="一致性 Hash 算法"></a>一致性 Hash 算法</h4><p>一致性 Hash 算法将整个 Hash 值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，下一步将各个 Master 节点（使用服务器的 IP 或主机名）进行 Hash。这样就能确定每个节点在其哈希环上的位置。</p><p>来了一个 Key ，首先计算 Hash 值，并确定此数据在环上的位置，从此位置沿环<strong>顺时针“行走”</strong>，遇到的第一个 Master 节点就是 Key 所在位置。</p><p>在一致性哈希算法中，如果一个节点挂了，受影响的数据仅仅是此节点到环空间前一个节点（沿着逆时针方向行走遇到的第一个节点）之间的数据，其它不受影响。增加一个节点也同理。</p><p>然而，一致性哈希算法在节点太少时，容易因为节点分布不均匀而造成<strong>缓存热点</strong>的问题。为了解决这种热点问题，一致性 Hash 算法引入了虚拟节点机制，即对每一个节点计算多个 Hash，每个计算结果位置都放置一个虚拟节点。这样就实现了数据的均匀分布，负载均衡。</p><p><img src="https://s1.ax1x.com/2020/04/29/JTZ0Ej.png" alt="consistent-hashing-algorithm"></p><h4 id="Redis-Cluster-的-Hash-Slot-算法"><a href="#Redis-Cluster-的-Hash-Slot-算法" class="headerlink" title="Redis Cluster 的 Hash Slot 算法"></a>Redis Cluster 的 Hash Slot 算法</h4><p>Redis Cluster 有固定的 <code>16384</code> 个 Hash Slot ，对每个 <code>Key</code> 计算 <code>CRC16</code> 值，然后对 <code>16384</code> 取模，可以获取 Key 对应的 Hash Slot 。</p><p>Redis Cluster 中每个 Master 都会持有部分 Slot，比如有 3 个 Master ，那么可能每个 Master 持有 5000 多个 Hash Slot 。Hash Slot 让 Node 的增加和移除很简单，增加一个 Master，就将其他 Master 的 Hash Slot 移动部分过去，减少一个 Master ，就将它的 Hash Slot 移动到其他 Master 上去。移动 Hash Slot 的成本是非常低的。客户端的 API ，可以对指定的数据，让他们走同一个 Hash Slot ，通过 <code>Hash Tag</code> 来实现。</p><p>任何一台机器宕机，另外两个节点，不影响的。因为 Key 找的是 Hash Slot ，不是机器。</p><p><img src="https://s1.ax1x.com/2020/04/29/JTeGdJ.png" alt="hash-slot"></p><h4 id="为什么是-16384（2-14）个哈希槽？"><a href="#为什么是-16384（2-14）个哈希槽？" class="headerlink" title="为什么是 16384（2^14）个哈希槽？"></a>为什么是 16384（2^14）个哈希槽？</h4><blockquote><p>Redis 作者给出了解答（<a href="https://github.com/antirez/redis/issues/2576" target="_blank" rel="noopener">点击查看</a>）。</p></blockquote><p>在 Redis 节点发送心跳包时需要把所有的槽放到这个心跳包里，以便让节点知道当前集群信息，16384 = 16k ，在发送心跳包时使用 <code>char</code> 进行 Bitmap 压缩后是 2k（ <code>2 * 8 (8 bit) * 1024 (1k) = 2K</code> ），也就是说使用 2k 的空间创建了 16k 的槽数。</p><p>虽然使用 <code>CRC16</code> 算法最多可以分配 65535（2^16-1）个槽位，65535 = 65k ，压缩后就是 8k（ <code>8 * 8 (8 bit) * 1024 (1k) = 8K</code> ），也就是说需要需要 8k 的心跳包，作者认为这样做不太值得；并且一般情况下一个 Redis 集群不会有超过 1000 个 Master 节点，所以 16k 的槽位是个比较合适的选择。</p><h3 id="Redis-Cluster-的高可用与主备切换原理"><a href="#Redis-Cluster-的高可用与主备切换原理" class="headerlink" title="Redis Cluster 的高可用与主备切换原理"></a>Redis Cluster 的高可用与主备切换原理</h3><p>Redis Cluster 的高可用的原理，几乎跟哨兵是类似的。</p><h4 id="判断节点宕机"><a href="#判断节点宕机" class="headerlink" title="判断节点宕机"></a>判断节点宕机</h4><p>如果一个节点认为另外一个节点宕机，那么就是 <code>pfail</code> ，<strong>主观宕机</strong>。如果多个节点都认为另外一个节点宕机了，那么就是 <code>fail</code> ，<strong>客观宕机</strong>，跟哨兵的原理几乎一样，<code>sdown</code> ，<code>odown</code> 。</p><p>在 <code>cluster-node-timeout</code> 内，某个节点一直没有返回 <code>pong</code> ，那么就被认为 <code>pfail</code> 。</p><p>如果一个节点认为某个节点  <code>pfail</code> 了，那么会在 <code>gossip ping</code> 消息中，<code>ping</code> 给其他节点，如果<strong>超过半数</strong>的节点都认为 <code>pfail</code> 了，那么就会变成 <code>fail</code> 。</p><h4 id="从节点过滤"><a href="#从节点过滤" class="headerlink" title="从节点过滤"></a>从节点过滤</h4><p>对宕机的 Master Node，从其所有的 Slave Node 中，选择一个切换成 Master Node 。</p><p>检查每个 Slave node 与 Master node 断开连接的时间，如果超过了 <code>cluster-node-timeout * cluster-slave-validity-factor</code> ，那么就<strong>没有资格</strong>切换成 <code>Master</code> 。</p><h4 id="从节点选举"><a href="#从节点选举" class="headerlink" title="从节点选举"></a>从节点选举</h4><p>每个从节点，都根据自己对 Master 复制数据的 offset ，来设置一个选举时间，offset 越大（复制数据越多）的从节点，选举时间越靠前，优先进行选举。</p><p>所有的 Master Node 开始 Slave 选举投票，给要进行选举的 Slave 进行投票，如果大部分 Master Node <code>(N/2 + 1)</code> 都投票给了某个从节点，那么选举通过，那个从节点可以切换成 Master 。</p><p>从节点执行主备切换，从节点切换为主节点。</p><h4 id="与哨兵比较"><a href="#与哨兵比较" class="headerlink" title="与哨兵比较"></a>与哨兵比较</h4><p>整个流程跟哨兵相比，非常类似，所以说，Redis Cluster 功能强大，直接集成了 Replication 和 Sentinel 的功能。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的三种log</title>
      <link href="/2020/04/28/shu-ju-ku/mysql-de-san-chong-log/"/>
      <url>/2020/04/28/shu-ju-ku/mysql-de-san-chong-log/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL-的三种-log"><a href="#MySQL-的三种-log" class="headerlink" title="MySQL 的三种 log"></a>MySQL 的三种 log</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在前一阵子，大哥问过我：”你知道 MySQL 的原子性是怎么保证的吗。“我懵逼了，MySQL 怎么保证原子性？我不会啊。</p><p>谁都知道在事务里边原子性的意思：”<strong>一个事务包含多个操作，这些操作要么全部执行，要么全都不执行。</strong>“</p><p>于是大哥就给我讲：”用的就是 <code>undo log</code> 啊。“</p><p>我：”卧槽，又是知识盲区“</p><p>后来在网上翻了一下，MySQL 里边还有几种常见的 <code>log</code> ，分别为：</p><ul><li><code>bin log</code></li><li><code>redo log</code></li><li><code>undo log</code></li></ul><p>如果你也未曾关注过这些 <code>log</code> ，麻烦给我留个言，<strong>让我觉得不是只有我一个人这么菜，行不行</strong>？</p><p><img src="https://s1.ax1x.com/2020/04/28/J50WcD.jpg" alt=""></p><p>后来我又去搜了一下，其实这几种 log 在<strong>面试</strong>的时候也经常会问到，这篇文章以最简单的方式来讲讲，希望对大家有帮助。</p><h3 id="一、什么是-binlog-？"><a href="#一、什么是-binlog-？" class="headerlink" title="一、什么是 binlog ？"></a>一、什么是 binlog ？</h3><p><code>binlog</code> 其实在日常的开发中是听得很多的，因为很多时候数据的更新就依赖着 <code>binlog</code> 。</p><p>举个很简单的例子：我们的数据是保存在数据库里边的嘛，现在我们对某个商品的某个字段的内容改了（数据库变更），而<strong>用户检索的出来数据是走搜索引擎的</strong>。为了让用户能搜到最新的数据，我们需要把引擎的数据也改掉。</p><p>一句话：<strong>数据库的变更，搜索引擎的数据也需要变更</strong>。</p><p>于是，我们就会监听 <code>binlog</code> 的变更，如果 <code>binlog</code> 有变更了，那我们就需要将变更写到对应的数据源。</p><blockquote><p>什么是 <code>binlog</code> ？</p></blockquote><p><code>binlog</code> 记录了数据库表结构和表数据变更，比如 <code>update/delete/insert/truncate/create</code> 。它不会记录 <code>select</code>（因为这没有对表没有进行变更）。</p><blockquote><p><code>binlog</code> 长什么样？</p></blockquote><p><code>binlog</code> 我们可以简单理解为：存储着每条变更的 <code>SQL</code> 语句（当然从下面的图看来看，不止SQL，还有XID「事务Id」等等）。</p><p><img src="https://s1.ax1x.com/2020/04/28/J5DPZd.jpg" alt=""></p><blockquote><p><code>binlog</code> 一般用来做什么？</p></blockquote><p>主要有两个作用：<strong>复制和恢复数据</strong>。</p><ul><li>MySQL 在公司使用的时候往往都是<strong>一主多从</strong>结构的，从服务器需要与主服务器的数据保持一致，这就是通过 <code>binlog</code> 来实现的。</li><li>数据库的数据被干掉了，我们可以通过 <code>binlog</code> 来对数据进行恢复。</li></ul><p>因为 <code>binlog</code> 记录了数据库表的变更，所以我们可以用 <code>binlog</code> 进行复制（主从复制）和恢复数据。</p><p><img src="https://s1.ax1x.com/2020/04/28/J5DDF1.jpg" alt=""></p><h3 id="二、binlog-的三种模式"><a href="#二、binlog-的三种模式" class="headerlink" title="二、binlog 的三种模式"></a>二、binlog 的三种模式</h3><h4 id="Row："><a href="#Row：" class="headerlink" title="Row："></a>Row：</h4><p><strong>描述：</strong>日志中会记录成每一行数据被修改的形式，然后在 Slave 端再对相同的数据进行修改，只记录要修改的数据，只有 Value ，不会有 SQL 多表关联的情况。</p><p><strong>优点：</strong>记录详细，解决了 <strong>Statement</strong> 模式的复制问题。</p><blockquote><p>在 <strong>Row</strong> 模式下，binlog 中可以不记录执行的 SQL 语句的上下文相关的信息，仅仅只需要记录哪一条记录被修改了，修改成什么样了，所以 Row 的日志内容会非常清楚的记录下每一行数据修改的细节，非常容易理解。而且不会出现某些特定情况下的存储过程和函数，以及触发器的调用和触发无法被正确复制问题。</p></blockquote><p><strong>缺点：</strong>在 <strong>Row</strong> 模式下，所有的执行语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容。</p><blockquote><p>比如有这样一条 update 语句：update product set name = ‘apple’; 这条语句不是记录的一条，而是修改的每一条都会记录下来。</p></blockquote><h4 id="Statement：-不支持-RU（未提交读）、RC（已提交读）隔离级别"><a href="#Statement：-不支持-RU（未提交读）、RC（已提交读）隔离级别" class="headerlink" title="Statement：(不支持 RU（未提交读）、RC（已提交读）隔离级别)"></a><strong>Statement：</strong>(不支持 RU（未提交读）、RC（已提交读）隔离级别)</h4><p><strong>描述：</strong>每一条修改数据的 SQL 都会记录到 Master 的 binlog 中，Slave 在复制的时候 SQL 进程会解析成 Master 端执行过的相同的 SQL 在 Slave 库上再次执行。</p><p><strong>优点：</strong>解决了 <strong>Row</strong> 模式下的缺点，不需要记录每一行的变化，较少 binlog 日志量，节约 IO ，提高性能。因为它只需要记录在 Master 上所执行的语句的细节，以及执行语句时候的上下文信息。</p><p><strong>缺点：</strong>导致主从不一致。</p><blockquote><p>由于它是记录执行语句，所以，为了让这些语句在 Slave 端也能正确执行，那么它还必须记录每条语句在执行的时候的一些相关信息，也就是<strong>上下文信息</strong>，来保证所有语句在 Slave 端能够得到和在 Master 端<strong>相同的执行结果</strong>。由于 MySQL 更新较快，使 MySQL 的赋值遇到了不小的挑战，自然赋值的时候就会涉及到越复杂的内容，Bug 也就容易出现。在 <strong>Statement</strong> 模式下，目前就已经发现了不少情况会造成 MySQL 的复制出现问题，主要是修改数据的时候使用了某些特定的函数或者功能的时候会出现。比如：<code>sleep()</code> 函数在有些版本中就不能正确赋值，在存储过程中使用了 <code>last_insert_id()</code> 函数，可能会使 Slave 和 Master 上得到不一致的 Id 等。由于 Row 模式是基于每一行记录的变化，所以不会出现类似的问题。</p></blockquote><h4 id="Mixed："><a href="#Mixed：" class="headerlink" title="Mixed："></a>Mixed：</h4><p>描述：实际上就是前两种模式的结合。在 <strong>Mixed</strong> 模式下，MySQL 会根据执行的每一条具体的 SQL 语句来区分对待记录的日志形式，也就是在 <strong>Statement</strong> 和 <strong>Row</strong> 之间选择一种。</p><blockquote><p>新版本中的 <strong>Statement</strong> 还是和以前一样，仅仅记录执行的语句。而新版本的 MySQL 中对 <strong>Row</strong> 模式也做了优化，并不是所有的修改都会以 <strong>Row</strong> 模式来记录，比如遇到表结构变更的时候就会以 <strong>Statement</strong> 模式来记录，如果 SQL 语句确实就是 Update 或者 Delete 等修改数据的语句，那么还是会记录所有行的变更。</p></blockquote><p>查看 <code>binlog</code> 日志模式：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'%binlog_format%'</span><span class="token punctuation">;</span></code></pre><p>修改 <code>binlog</code> 日志模式：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">set</span> <span class="token keyword">global</span> binlog_format <span class="token operator">=</span> <span class="token string">'MIXED'</span><span class="token punctuation">;</span></code></pre><h3 id="三、什么是-redo-log-？"><a href="#三、什么是-redo-log-？" class="headerlink" title="三、什么是 redo log ？"></a>三、什么是 redo log ？</h3><p>假设我们有一条 SQL 语句：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">update</span> user_table <span class="token keyword">set</span> name<span class="token operator">=</span><span class="token string">'java3y'</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token string">'3'</span><span class="token punctuation">;</span></code></pre><p>MySQL 执行这条 SQL 语句，肯定是先把 <code>id=3</code> 的这条记录查出来，然后将 <code>name</code> 字段给改掉。这没问题吧？</p><p><img src="https://s1.ax1x.com/2020/04/28/J5rM6O.jpg" alt=""></p><p>实际上 MySQL 的基本存储结构是<strong>页</strong>（记录都存在页里边），所以 MySQL 是先把这条记录所在的<strong>页</strong>找到，然后把该页加载到内存中，将对应记录进行修改。</p><p>现在就可能存在一个问题：<strong>如果在内存中把数据改了，还没来得及落磁盘，而此时的数据库挂了怎么办</strong>？显然这次更改就丢了。</p><p><img src="https://s1.ax1x.com/2020/04/28/J5rzHH.jpg" alt=""></p><p>如果每个请求都需要将数据<strong>立马</strong>落磁盘之后，那速度会很慢，MySQL 可能也顶不住。所以MySQL 是怎么做的呢？</p><p>MySQL 引入了 <code>redo log</code> ，内存写完了，然后会写一份 <code>redo log</code> ，这份 <code>redo log</code> 记载着这次<strong>在某个页上做了什么修改</strong>。</p><p><img src="https://s1.ax1x.com/2020/04/28/J5swP1.jpg" alt=""></p><p>其实写 <code>redo log</code> 的时候，也会有 <code>buffer</code> ，是先写 <code>buffer</code> ，再真正落到磁盘中的。至于 <code>buffer</code> 什么时候落磁盘，会有配置供我们配置。</p><p><img src="https://s1.ax1x.com/2020/04/28/J5sXin.jpg" alt=""></p><p>写 <code>redo log</code> 也是需要写磁盘的，但它的好处就是 <code>顺序IO</code>（我们都知道顺序 IO 比随机 IO 快非常多）。</p><p>所以，<code>redo log</code> 的存在为了：<strong>当我们修改的时候，写完内存了，但数据还没真正写到磁盘的时候</strong>。此时我们的数据库挂了，我们可以根据 <code>redo log</code> 来对数据进行恢复。因为 <code>redo log</code> 是顺序 IO ，所以<strong>写入的速度很快</strong>，并且 <code>redo log</code> 记载的是物理变化（ xxxx 页做了 xxx 修改），文件的体积很小，<strong>恢复速度很快</strong>。</p><h3 id="四、binlog-和-redo-log"><a href="#四、binlog-和-redo-log" class="headerlink" title="四、binlog 和 redo log"></a>四、binlog 和 redo log</h3><p>看到这里，你可能会想：<code>binlog</code> 和 <code>redo log</code> 这俩也太像了吧，都是用作”恢复“的。</p><p>其实他俩除了”恢复”这块是相似的，很多都不一样，下面看我列一下。</p><p><img src="https://s1.ax1x.com/2020/04/28/J565DS.jpg" alt=""></p><h4 id="存储的内容"><a href="#存储的内容" class="headerlink" title="存储的内容"></a>存储的内容</h4><p><code>binlog</code> 记载的是 <code>update/delete/insert</code> 这样的SQL语句，而 <code>redo log</code> 记载的是物理修改的内容（ xxxx 页修改了 xxx ）。</p><p>所以在搜索资料的时候会有这样的说法：<code>redo log</code> 记录的是数据的<strong>物理变化</strong>，<code>binlog</code> 记录的是数据的<strong>逻辑变化</strong>。</p><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p><code>redo log</code> 的作用是为<strong>持久化</strong>而生的。写完内存，如果数据库挂了，那我们可以通过 <code>redo log</code> 来恢复内存还没来得及刷到磁盘的数据，将 <code>redo log</code> 加载到内存里边，那内存就能恢复到挂掉之前的数据了。</p><p><code>binlog</code> 的作用是<strong>复制和恢复</strong>而生的。</p><ul><li>主从服务器需要保持数据的一致性，通过 <code>binlog</code> 来同步数据。</li><li>如果整个数据库的数据都被删除了，<code>binlog</code> 存储着所有的数据变更情况，那么可以通过 <code>binlog</code> 来对数据进行恢复。</li></ul><p>又看到这里，你会想：”如果整个数据库的数据都被删除了，那我可以用 <code>redo log</code> 的记录来恢复吗？“ <strong>不能。</strong></p><p>因为功能的不同，<code>redo log</code> 存储的是物理数据的变更，如果我们内存的数据已经刷到了磁盘了，那 <code>redo log</code> 的数据就无效了。所以 <code>redo log</code> 不会存储着<strong>历史</strong>所有数据的变更，<strong>文件的内容会被覆盖的</strong>。</p><h4 id="binlog-和-redo-log-写入的细节"><a href="#binlog-和-redo-log-写入的细节" class="headerlink" title="binlog 和 redo log 写入的细节"></a>binlog 和 redo log 写入的细节</h4><p><code>redo log</code> 是 MySQL 的 InnoDB 引擎所产生的。</p><p><code>binlog</code> 无论 MySQL 用什么引擎，都会有的。</p><p>InnoDB 是有事务的，事务的四大特性之一：持久性就是靠 <code>redo log</code> 来实现的（如果写入内存成功，但数据还没真正刷到磁盘，如果此时的数据库挂了，我们可以靠 <code>redo log</code> 来恢复内存的数据，这就实现了持久性）。</p><p>上面也提到，在修改的数据的时候，<code>binlog</code> 会记载着变更的类容，<code>redo log</code> 也会记载着变更的内容。（只不过一个存储的是物理变化，一个存储的是逻辑变化）。那他们的写入顺序是什么样的呢？</p><p><code>redo log</code> <strong>事务开始</strong>的时候，就开始记录每次的变更信息，而 <code>binlog</code> 是在<strong>事务提交</strong>的时候才记录。</p><p>于是新有的问题又出现了：我写其中的某一个 <code>log</code> ，失败了，那会怎么办？现在我们的前提是先写 <code>redo log</code> ，再写 <code>binlog</code> ，我们来看看：</p><ul><li>如果写 <code>redo log</code> 失败了，那我们就认为这次事务有问题，回滚，不再写 <code>binlog</code> 。</li><li>如果写 <code>redo log</code> 成功了，写 <code>binlog</code> ，写 <code>binlog</code> 写一半了，但失败了怎么办？我们还是会对这次的<strong>事务回滚</strong>，将无效的 <code>binlog</code> 给删除（因为 <code>binlog</code> 会影响从库的数据，所以需要做删除操作）。</li><li>如果写 <code>redo log</code> 和 <code>binlog</code> 都成功了，那这次算是事务才会真正成功。</li></ul><p><strong>简单来说：</strong>MySQL 需要保证 <code>redo log</code> 和 <code>binlog</code> 的<strong>数据是一致</strong>的，如果不一致，那就乱套了。</p><ul><li>如果 <code>redo log</code> 写失败了，而 <code>binlog</code> 写成功了。那假设内存的数据还没来得及落磁盘，机器就挂掉了。那主从服务器的数据就不一致了。（从服务器通过 <code>binlog</code> 得到最新的数据，而主服务器由于 <code>redo log</code> 没有记载，没法恢复数据）</li><li>如果 <code>redo log</code> 写成功了，而 <code>binlog</code> 写失败了。那从服务器就拿不到最新的数据了。</li></ul><p>MySQL 通过<strong>两阶段提交（2PC）</strong>来保证 <code>redo log</code> 和 <code>binlog</code> 的数据是一致的。</p><p><img src="https://s1.ax1x.com/2020/04/28/J5cDx0.jpg" alt=""></p><p><strong>过程：</strong></p><ul><li>阶段1：InnoDB <code>redo log</code> 写盘，InnoDB 事务进入 <strong><code>prepare</code></strong> 状态。</li><li>阶段2：<code>binlog</code> 写盘，InooDB 事务进入 <strong><code>commit</code></strong> 状态。</li><li>每个事务 <code>binlog</code> 的末尾，会记录一个 <code>XID event</code> ，标志着事务是否提交成功，也就是说，恢复过程中，<code>binlog</code> 最后一个 <code>XID event</code> 之后的内容都应该被 <code>purge</code>（清除）。</li></ul><p><img src="https://s1.ax1x.com/2020/04/28/J5c5xx.jpg" alt=""></p><h3 id="五、什么是-undo-log-？"><a href="#五、什么是-undo-log-？" class="headerlink" title="五、什么是 undo log ？"></a>五、什么是 undo log ？</h3><blockquote><p><code>undo log</code> 有什么用？ </p></blockquote><p><code>undo log</code> 主要有两个作用：回滚和多版本并发控制（MVCC）。</p><p>在数据修改的时候，不仅记录了 <code>redo log</code> ，还记录 <code>undo log</code> ，如果因为某些原因导致事务失败或回滚了，可以用 <code>undo log</code> 进行回滚。</p><p><code>undo log</code> 主要存储的也是逻辑日志，比如我们要 <code>insert</code> 一条数据了，那 <code>undo log</code> 会记录的一条对应的 <code>delete</code> 日志。我们要 <code>update</code> 一条记录时，它会记录一条对应<strong>相反</strong>的update记录。</p><p>这也应该容易理解，毕竟回滚嘛，跟需要修改的操作相反就好，这样就能达到回滚的目的。因为支持回滚操作，所以我们就能保证：“<strong>一个事务包含多个操作，这些操作要么全部执行，要么全都不执行。</strong>”【原子性】</p><p>因为 <code>undo log</code> 存储着修改之前的数据，相当于一个<strong>前版本</strong>，<strong>MVCC</strong> 实现的是读写不阻塞，读的时候只要返回前一个版本的数据就行了。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>这篇文章把 <code>binlog</code> /<code>redo log</code>/<code>undo log</code> 最核心的知识给讲了，还有一些细节性的东西可以自行去补充（比如文章提到的刷盘策略等）。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.jianshu.com/p/4bcfffb27ed5" target="_blank" rel="noopener">https://www.jianshu.com/p/4bcfffb27ed5</a></li><li><a href="https://yq.aliyun.com/articles/617335" target="_blank" rel="noopener">https://yq.aliyun.com/articles/617335</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247485215&idx=1&sn=536d992835b4a40f7dc968acc5bea9c1&chksm=ebd7461edca0cf081bab56fb7b041331714f7d4849b605d8fb9390175f4a3eb7728a346ac02c&token=1230572157&lang=zh_CN###rd" target="_blank" rel="noopener">MySQL的ACID原理！</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247486392&idx=2&sn=9acbd3e958a40e559ea41b878bc1da64&chksm=ebd74ab9dca0c3af3aca763faf2072e709ba54a4bbd8c37b25ba29f0fb88ce56443750342443&token=1436027357&lang=zh_CN#rd" target="_blank" rel="noopener">MySQL 是如何实现 ACID 中的 D 的？</a></li><li><a href="https://www.cnblogs.com/myseries/p/10728533.html" target="_blank" rel="noopener">https://www.cnblogs.com/myseries/p/10728533.html</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN#rd" target="_blank" rel="noopener">一条SQL语句在MySQL中如何执行的？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HyperLogLog</title>
      <link href="/2020/04/27/shu-ju-ku/hyperloglog/"/>
      <url>/2020/04/27/shu-ju-ku/hyperloglog/</url>
      
        <content type="html"><![CDATA[<h2 id="一、HyperLogLog-简介"><a href="#一、HyperLogLog-简介" class="headerlink" title="一、HyperLogLog 简介"></a>一、HyperLogLog 简介</h2><p><strong>HyperLogLog</strong> 是最早由 <a href="http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf" target="_blank" rel="noopener">Flajolet</a> 及其同事在 2007 年提出的一种 <strong>估算基数的近似最优算法</strong>。但跟原版论文不同的是，好像很多书包括 Redis 作者都把它称为一种 <strong>新的数据结构</strong>（算法确实需要一种特定的数据结构来实现）。</p><h3 id="关于基数统计"><a href="#关于基数统计" class="headerlink" title="关于基数统计"></a>关于基数统计</h3><p><strong>基数统计（Cardinality Counting）</strong>通常是用来统计一个集合中不重复的元素个数。</p><p><strong>思考这样的一个场景：</strong> 如果你负责开发维护一个大型的网站，有一天老板找产品经理要网站上每个网页的 <strong>UV（独立访客，每个用户每天只记录一次）</strong>，然后让你来开发这个统计模块，你会如何实现？</p><p>如果统计 <strong>PV（浏览量，用户没点一次记录一次）</strong>，那非常好办，给每个页面配置一个独立的 Redis 计数器就可以了，把这个计数器的 key 后缀加上当天的日期。这样每来一个请求，就执行 <code>INCRBY</code> 指令一次，最终就可以统计出所有的 <strong>PV</strong> 数据了。</p><p>但是 <strong>UV</strong> 不同，它要去重，<strong>同一个用户一天之内的多次访问请求只能计数一次</strong>。这就要求了每一个网页请求都需要带上用户的 ID，无论是登录用户还是未登录的用户，都需要一个唯一 ID 来标识。</p><p>你也许马上就想到了一个 <strong>简单的解决方案</strong> ：那就是 <strong>为每一个页面设置一个独立的 set 集合</strong> 来存储所有当天访问过此页面的用户 ID。但这样的 <strong>问题</strong> 就是：</p><ul><li><p><strong>存储空间巨大：</strong> 如果网站访问量一大，你需要用来存储的 set 集合就会非常大，如果页面再一多…为了一个去重功能耗费的资源就可以直接让你 <strong>老板打死你</strong> 。</p></li><li><p><strong>统计复杂：</strong> 这么多 set 集合如果要聚合统计一下，又是一个复杂的事情。</p></li></ul><h3 id="基数统计的常用方法"><a href="#基数统计的常用方法" class="headerlink" title="基数统计的常用方法"></a>基数统计的常用方法</h3><p>对于上述这样需要 <strong>基数统计</strong> 的事情，通常来说有两种比 set 集合更好的解决方案：</p><h4 id="第一种：B-树"><a href="#第一种：B-树" class="headerlink" title="第一种：B 树"></a>第一种：B 树</h4><p><strong>B 树最大的优势就是插入和查找效率很高</strong>，如果用 B 树存储要统计的数据，可以快速判断新来的数据是否存在，并快速将元素插入 B 树。要计算基础值，只需要计算 B 树的节点个数就行了。</p><p>不过将 B 树结构维护到内存中，能够解决统计和计算的问题，但是 <strong>并没有节省内存</strong> 。</p><h4 id="第二种：Bitmap"><a href="#第二种：Bitmap" class="headerlink" title="第二种：Bitmap"></a>第二种：Bitmap</h4><p><strong>Bitmap</strong> 可以理解为通过一个 Bit 数组来存储特定数据的一种数据结构，<strong>每一个 Bit 位都能独立包含信息</strong>，Bit 是数据的最小存储单位，因此能大量节省空间，也可以将整个 Bit 数据一次性 Load 到内存计算。如果定义一个很大的 Bit 数组，基础统计中 <strong>每一个元素对应到 Bit 数组中的一位</strong>，例如：</p><p><img src="https://s1.ax1x.com/2020/04/26/Jg7kwD.png" alt="Bitmap"></p><p>Bitmap 还有一个明显的优势是 <strong>可以轻松合并多个统计结果</strong>，只需要对多个结果求异或就可以了，也可以大大减少存储内存。可以简单做一个计算，如果要统计 <strong>1 亿</strong> 个数据的基数值，<strong>大约需要的内存：</strong><code>100000000/ 8/ 1024/ 1024 ≈ 12 M</code> ，如果用 <strong>32 Bit</strong> 的 int 代表 <strong>每一个</strong> 统计的数据，<strong>大约需要内存：</strong><code>32 * 100000000/ 8/ 1024/ 1024 ≈ 381 M</code> 。</p><p>可以看到 Bitmap 对于内存的节省显而易见，但仍然不够。统计一个对象的基数值就需要 <code>12 M</code> ，如果统计 1 万个对象，就需要接近 <code>120 G</code> ，对于大数据的场景仍然不适用。</p><h4 id="概率算法"><a href="#概率算法" class="headerlink" title="概率算法"></a>概率算法</h4><p>实际上目前还没有发现更好的在 <strong>大数据场景</strong> 中 <strong>准确计算</strong> 基数的高效算法，因此在不追求绝对精确的情况下，使用概率算法算是一个不错的解决方案。</p><p>概率算法 <strong>不直接存储</strong> 数据集合本身，通过一定的 <strong>概率统计方法预估基数值</strong>，这种方法可以大大节省内存，同时保证误差控制在一定范围内。目前用于基数计数的概率算法包括：</p><ul><li><strong>Linear Counting（LC）：</strong>早期的基数估计算法，LC 在空间复杂度方面并不算优秀，实际上 LC 的空间复杂度与上文中简单 Bitmap 方法是一样的（但是有个常数项级别的降低），都是 O(N<sub>max</sub>) 。</li><li><strong>LogLog Counting（LLC）：</strong>LogLog Counting 相比于 LC 更加节省内存，空间复杂度只有 O(log<sub>2</sub>(log<sub>2</sub>(N<sub>max</sub>))) 。</li><li><strong>HyperLogLog Counting（HLL）：</strong>HyperLogLog Counting 是基于 LLC 的优化和改进，在同样空间复杂度情况下，能够比 LLC 的基数估计误差更小。</li></ul><p>其中，<strong>HyperLogLog</strong> 的表现是惊人的，上面我们简单计算过用 <strong>Bitmap</strong> 存储 <strong>1 亿个</strong> 统计数据大概需要 <code>12 M</code> 内存，而在 <strong>HyperLoglog</strong> 中，只需要不到 <strong>1 K</strong> 内存就能够做到！在 Redis 中实现的 <strong>HyperLoglog</strong> 也只需要 <strong>12 K</strong> 内存，在 <strong>标准误差 0.81%</strong> 的前提下，<strong>能够统计 2<sup>64</sup> 个数据</strong>！</p><p><img src="https://s1.ax1x.com/2020/04/26/J271VU.jpg" alt=""></p><p><strong>这是怎么做到的？！</strong> 下面赶紧来了解一下！</p><h2 id="二、HyperLogLog-原理"><a href="#二、HyperLogLog-原理" class="headerlink" title="二、HyperLogLog 原理"></a>二、HyperLogLog 原理</h2><p>我们来思考一个抛硬币的游戏：你连续掷 n 次硬币，然后说出其中<strong>连续掷为正面的最大次数，我来猜你一共抛了多少次</strong>。</p><p>这很容易理解吧，例如：你说你这一次 <strong>最多连续出现了 2 次</strong> 正面，那么我就可以知道你这一次投掷的次数并不多，所以 <strong>我可能会猜是 5</strong> 或者是其他小一些的数字，但如果你说你这一次 <strong>最多连续出现了 20 次</strong> 正面，虽然我觉得不可能，但我仍然知道你花了特别多的时间，所以 我说 GUN …</p><p><img src="https://s1.ax1x.com/2020/04/26/J2jh1e.png" alt=""></p><p>这期间我可能会要求你重复实验，然后我得到了更多的数据之后就会估计得更准。<strong>我们来把刚才的游戏换一种说法：</strong></p><p><img src="https://s1.ax1x.com/2020/04/26/JRSWVA.png" alt=""></p><p>这张图的意思是，我们给定一系列的随机整数，<strong>记录下低位连续零位的最大长度 K</strong> ，即为图中的 <code>maxbit</code> ，<strong>通过这个 K 值我们就可以估算出随机数的数量 N</strong> 。</p><h3 id="代码实验"><a href="#代码实验" class="headerlink" title="代码实验"></a>代码实验</h3><p>我们可以简单编写代码做一个实验，来探究一下 <code>K</code> 和 <code>N</code> 之间的关系：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PfTest</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">BitKeeper</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> maxbit<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">long</span> value <span class="token operator">=</span> ThreadLocalRandom<span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextLong</span><span class="token punctuation">(</span>2L <span class="token operator">&lt;&lt;</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> bit <span class="token operator">=</span> <span class="token function">lowZeros</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bit <span class="token operator">></span> <span class="token keyword">this</span><span class="token punctuation">.</span>maxbit<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>maxbit <span class="token operator">=</span> bit<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">lowZeros</span><span class="token punctuation">(</span><span class="token keyword">long</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">32</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">>></span> i <span class="token operator">&lt;&lt;</span> i <span class="token operator">!=</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Experiment</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>        <span class="token keyword">private</span> BitKeeper keeper<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">Experiment</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>keeper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BitKeeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>keeper<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">debug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out                <span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %.2f %d\n"</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>n<span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>n<span class="token punctuation">)</span> <span class="token operator">/</span> Math<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>keeper<span class="token punctuation">.</span>maxbit<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Experiment exp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Experiment</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            exp<span class="token punctuation">.</span><span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            exp<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>跟上图中的过程是一致的，话说为啥叫 <code>PfTest</code> 呢，包括 Redis 中的命令也一样带有一个 <code>PF</code> 前缀，还记得嘛，因为 <strong>HyperLogLog</strong> 的提出者上文提到过的，叫 <code>Philippe Flajolet</code> 。</p><p>截取部分输出查看：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//n   n/log2 maxbit</span><span class="token number">34000</span> <span class="token number">15.05</span> <span class="token number">13</span><span class="token number">35000</span> <span class="token number">15.10</span> <span class="token number">13</span><span class="token number">36000</span> <span class="token number">15.14</span> <span class="token number">16</span><span class="token number">37000</span> <span class="token number">15.18</span> <span class="token number">17</span><span class="token number">38000</span> <span class="token number">15.21</span> <span class="token number">14</span><span class="token number">39000</span> <span class="token number">15.25</span> <span class="token number">16</span><span class="token number">40000</span> <span class="token number">15.29</span> <span class="token number">14</span><span class="token number">41000</span> <span class="token number">15.32</span> <span class="token number">16</span><span class="token number">42000</span> <span class="token number">15.36</span> <span class="token number">18</span></code></pre><p>会发现 <code>K</code> 和 <code>N</code> 的对数之间存在显著的线性相关性：<strong>N 约等于 2<sup>k</sup></strong>。</p><h3 id="更近一步：分桶平均"><a href="#更近一步：分桶平均" class="headerlink" title="更近一步：分桶平均"></a>更近一步：分桶平均</h3><p><strong>如果 <code>N</code> 介于 2<sup>k</sup> 和 2<sup>k+1</sup> 之间，用这种方式估计的值都等于 2<sup>k</sup>，这明显是不合理的</strong>，所以我们可以使用多个 <code>BitKeeper</code> 进行加权估计，就可以得到一个比较准确的值了：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PfTest</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">BitKeeper</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 无变化, 代码省略</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Experiment</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> k<span class="token punctuation">;</span>        <span class="token keyword">private</span> BitKeeper<span class="token punctuation">[</span><span class="token punctuation">]</span> keepers<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">Experiment</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token function">Experiment</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>k <span class="token operator">=</span> k<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>keepers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BitKeeper</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>keepers<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BitKeeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">long</span> m <span class="token operator">=</span> ThreadLocalRandom<span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextLong</span><span class="token punctuation">(</span>1L <span class="token operator">&lt;&lt;</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                BitKeeper keeper <span class="token operator">=</span> keepers<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>m <span class="token operator">&amp;</span> <span class="token number">0xfff0000</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">%</span> keepers<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                keeper<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">estimate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">double</span> sumbitsInverse <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>BitKeeper keeper <span class="token operator">:</span> keepers<span class="token punctuation">)</span> <span class="token punctuation">{</span>                sumbitsInverse <span class="token operator">+=</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span> keeper<span class="token punctuation">.</span>maxbit<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">double</span> avgBits <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span> keepers<span class="token punctuation">.</span>length <span class="token operator">/</span> sumbitsInverse<span class="token punctuation">;</span>            <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> avgBits<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>k<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">100000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Experiment exp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Experiment</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            exp<span class="token punctuation">.</span><span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">double</span> est <span class="token operator">=</span> exp<span class="token punctuation">.</span><span class="token function">estimate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %.2f %.2f\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> est<span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>est <span class="token operator">-</span> i<span class="token punctuation">)</span> <span class="token operator">/</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个过程有点 <strong>类似于选秀节目里面的打分</strong>，一堆专业评委打分，但是有一些评委因为自己特别喜欢所以给高了，一些评委又打低了，所以一般都要 <strong>屏蔽最高分和最低分</strong>，然后 <strong>再计算平均值</strong>，这样的出来的分数就差不多是公平公正的了。</p><p>上述代码就有 <strong>1024</strong> 个 “评委”，并且在计算平均值的时候，采用了 <strong>调和平均数</strong>，也就是倒数的平均值，它能有效地平滑离群值的影响：</p><pre class=" language-java"><code class="language-java">avg <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">+</span> <span class="token number">4</span> <span class="token operator">+</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">104</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">4</span> <span class="token operator">=</span> <span class="token number">29</span>avg <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">4</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">5</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">104</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">5.044</span></code></pre><p>观察脚本的输出，误差率百分比控制在个位数：</p><pre class=" language-java"><code class="language-java"><span class="token number">100000</span> <span class="token number">94274.94</span> <span class="token number">0.06</span><span class="token number">200000</span> <span class="token number">194092.62</span> <span class="token number">0.03</span><span class="token number">300000</span> <span class="token number">277329.92</span> <span class="token number">0.08</span><span class="token number">400000</span> <span class="token number">373281.66</span> <span class="token number">0.07</span><span class="token number">500000</span> <span class="token number">501551.60</span> <span class="token number">0.00</span><span class="token number">600000</span> <span class="token number">596078.40</span> <span class="token number">0.01</span><span class="token number">700000</span> <span class="token number">687265.72</span> <span class="token number">0.02</span><span class="token number">800000</span> <span class="token number">828778.96</span> <span class="token number">0.04</span><span class="token number">900000</span> <span class="token number">944683.53</span> <span class="token number">0.05</span></code></pre><p>真实的 HyperLogLog 要比上面的示例代码更加复杂一些，也更加精确一些。上面这个算法在随机次数很少的情况下会出现除零错误，因为 <code>maxbit = 0</code> 是不可以求倒数的。</p><h3 id="真实的-HyperLogLog"><a href="#真实的-HyperLogLog" class="headerlink" title="真实的 HyperLogLog"></a>真实的 HyperLogLog</h3><blockquote><p>有一个神奇的网站，可以动态地让你观察到 HyperLogLog 的算法到底是怎么执行的：<a href="http://content.research.neustar.biz/blog/hll.html" target="_blank" rel="noopener">http://content.research.neustar.biz/blog/hll.html</a></p></blockquote><p><img src="https://s1.ax1x.com/2020/04/26/JRV5wT.png" alt=""></p><p>其中的一些概念这里稍微解释一下，您就可以自行去点击 <code>step</code> 来观察了：</p><ul><li><strong>m 表示分桶个数：</strong> 从图中可以看到，这里分成了 64 个桶；</li><li><strong>蓝色的 Bit 表示在桶中的位置：</strong> 例如图中的 <code>101110</code> 实则表示二进制的 <code>46</code> ，所以该元素被统计在中间大表格 <code>Register Values</code> 中标红的第 46 个桶之中；</li><li><strong>绿色的 Bit 表示第一个 1 出现的位置：</strong>从图中可以看到标绿的 Bit 中，从右往左数，第一位就是 1 ，所以在 <code>Register Values</code> 第 46 个桶中写入 1 ；</li><li><strong>红色 Bit 表示绿色 Bit 的值的累加：</strong>下一个出现在第 46 个桶的元素值会被累加；</li></ul><h3 id="为什么要统计-Hash-值中第一个-1-出现的位置？"><a href="#为什么要统计-Hash-值中第一个-1-出现的位置？" class="headerlink" title="为什么要统计 Hash 值中第一个 1 出现的位置？"></a>为什么要统计 Hash 值中第一个 1 出现的位置？</h3><p>因为第一个 1 出现的位置可以同我们抛硬币的游戏中第一次抛到正面的抛掷次数对应起来，根据上面掷硬币实验的结论，记录每个数据的第一个出现的位置 <code>K</code> ，就可以通过其中最大值 K<sub>max</sub> 来推导出数据集合中的基数：<strong>N = 2<sup>K<sub>max</sub></sup></strong>。</p><h3 id="PF-的内存占用为什么是-12-KB？"><a href="#PF-的内存占用为什么是-12-KB？" class="headerlink" title="PF 的内存占用为什么是 12 KB？"></a>PF 的内存占用为什么是 12 KB？</h3><p>我们上面的算法中使用了 <strong>1024</strong> 个桶，网站演示也只有 <strong>64</strong> 个桶，不过在 Redis 的 HyperLogLog 实现中，用的是 <strong>16384</strong> 个桶，即：2<sup>14</sup>，也就是说，就像上面网站中间那个 <code>Register Values</code> 大表格有 <strong>16384</strong> 格。</p><p><strong>而 Redis 最大能够统计的数据量是 2<sup>64</sup></strong>，即每个桶的 <code>maxbit</code> 需要 <strong>6</strong> 个 Bit 来存储，最大可以表示 <code>maxbit = 63</code> ，于是总共占用内存就是：<strong>(2<sup>14</sup>) x 6 / 8</strong>（每个桶 6 Bit，而这么多桶本身要占用 16384 Bit，再除以 8 转换成 KB），算出来的结果就是 <code>12 KB</code> 。</p><h2 id="三、Redis-中的-HyperLogLog-实现"><a href="#三、Redis-中的-HyperLogLog-实现" class="headerlink" title="三、Redis 中的 HyperLogLog 实现"></a>三、Redis 中的 HyperLogLog 实现</h2><p>从上面我们算是对 <strong>HyperLogLog</strong> 的算法和思想有了一定的了解，并且知道了一个 <strong>HyperLogLog</strong> 实际占用的空间大约是 <code>12 KB</code> ，但 Redis 对于内存的优化非常变态，当 <strong>计数比较小</strong> 的时候，大多数桶的计数值都是 <strong>零</strong>，这个时候 Redis 就会适当节约空间，转换成另外一种 <strong>稀疏存储方式</strong>，与之相对的，正常的存储模式叫做 <strong>密集存储</strong>，这种方式会恒定地占用 <code>12 KB</code> 。</p><h3 id="密集型存储结构"><a href="#密集型存储结构" class="headerlink" title="密集型存储结构"></a>密集型存储结构</h3><p>密集型的存储结构非常简单，就是 <strong>16384 个 6 Bit 连续串成</strong> 的字符串位图：</p><p><img src="https://s1.ax1x.com/2020/04/26/JRZl1s.png" alt=""></p><p>我们都知道，一个字节是由 8 个 Bit 组成的，这样 6 Bit 排列的结构就会导致，有一些桶会 <strong>跨越字节边界</strong>，我们需要 <strong>对这一个或者两个字节进行适当的移位拼接</strong> 才可以得到具体的计数值。</p><p>假设桶的编号为 <code>index</code> ，这个 6 Bit 计数值的起始字节偏移用 <code>offset_bytes</code> 表示，它在这个字节的其实比特位置偏移用 <code>offset_bits</code> 表示，于是我们有：</p><pre class=" language-python"><code class="language-python">offset_bytes <span class="token operator">=</span> <span class="token punctuation">(</span>index <span class="token operator">*</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">8</span>offset_bits <span class="token operator">=</span> <span class="token punctuation">(</span>index <span class="token operator">*</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">8</span></code></pre><p>前者是商，后者是余数。比如 <code>bucket 2</code> 的字节偏移是 1，也就是第 2 个字节。它的位偏移是 4，也就是第 2 个字节的第 5 个位开始是 bucket 2 的计数值。需要注意的是 <strong>字节位序是左边低位右边高位</strong>，而通常我们使用的字节都是左边高位右边低位。</p><p>这里就涉及到两种情况，<strong>如果 <code>offset_bits</code> 小于等于 2</strong>，说明这 <strong>6 Bit 在一个字节的内部</strong>，可以直接使用下面的表达式得到计数值 <code>val</code> ：</p><pre class=" language-python"><code class="language-python">val <span class="token operator">=</span> buffer<span class="token punctuation">[</span>offset_bytes<span class="token punctuation">]</span> <span class="token operator">>></span> offset_bits  <span class="token comment" spellcheck="true"># 向右移位</span></code></pre><p><strong>如果 <code>offset_bits</code> 大于 2</strong>，那么就会涉及到 <strong>跨越字节边界</strong>，我们需要拼接两个字节的位片段：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 低位值</span>low_val <span class="token operator">=</span> buffer<span class="token punctuation">[</span>offset_bytes<span class="token punctuation">]</span> <span class="token operator">>></span> offset_bits<span class="token comment" spellcheck="true"># 低位个数</span>low_bits <span class="token operator">=</span> <span class="token number">8</span> <span class="token operator">-</span> offset_bits<span class="token comment" spellcheck="true"># 拼接，保留低6位</span>val <span class="token operator">=</span> <span class="token punctuation">(</span>high_val <span class="token operator">&lt;&lt;</span> low_bits <span class="token operator">|</span> low_val<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0b111111</span></code></pre><p>不过下面 Redis 的源码要晦涩一点，看形式它似乎只考虑了跨越字节边界的情况。这是因为如果 6 Bit 在单个字节内，上面代码中的 <code>high_val</code> 的值是零，所以这一份代码可以同时照顾单字节和双字节：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 获取指定桶的计数值</span><span class="token macro property">#<span class="token directive keyword">define</span> HLL_DENSE_GET_REGISTER(target,p,regnum) do { \    uint8_t *_p = (uint8_t*) p; \    unsigned long _byte = regnum*HLL_BITS/8; \ </span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> _fb <span class="token operator">=</span> regnum<span class="token operator">*</span>HLL_BITS<span class="token operator">&amp;</span><span class="token number">7</span><span class="token punctuation">;</span> \  # <span class="token operator">%</span><span class="token number">8</span> <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token number">7</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> _fb8 <span class="token operator">=</span> <span class="token number">8</span> <span class="token operator">-</span> _fb<span class="token punctuation">;</span> \    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> b0 <span class="token operator">=</span> _p<span class="token punctuation">[</span>_byte<span class="token punctuation">]</span><span class="token punctuation">;</span> \    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> b1 <span class="token operator">=</span> _p<span class="token punctuation">[</span>_byte<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> \    target <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>b0 <span class="token operator">>></span> _fb<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>b1 <span class="token operator">&lt;&lt;</span> _fb8<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> HLL_REGISTER_MAX<span class="token punctuation">;</span> \<span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 设置指定桶的计数值</span><span class="token macro property">#<span class="token directive keyword">define</span> HLL_DENSE_SET_REGISTER(p,regnum,val) do { \    uint8_t *_p = (uint8_t*) p; \    unsigned long _byte = regnum*HLL_BITS/8; \    unsigned long _fb = regnum*HLL_BITS&amp;7; \    unsigned long _fb8 = 8 - _fb; \    unsigned long _v = val; \    _p[_byte] &amp;= ~(HLL_REGISTER_MAX &lt;&lt; _fb); \    _p[_byte] |= _v &lt;&lt; _fb; \    _p[_byte+1] &amp;= ~(HLL_REGISTER_MAX >> _fb8); \    _p[_byte+1] |= _v >> _fb8; \} while(0)</span></code></pre><h3 id="稀疏存储结构"><a href="#稀疏存储结构" class="headerlink" title="稀疏存储结构"></a>稀疏存储结构</h3><p>稀疏存储适用于很多计数值都是零的情况。下图表示了一般稀疏存储计数值的状态：</p><p><img src="https://s1.ax1x.com/2020/04/26/JRZY7T.png" alt=""></p><p>当 <strong>多个连续桶的计数值都是零</strong> 时，Redis 提供了几种不同的表达形式：</p><ul><li><code>00xxxxxx</code> ：前缀两个零表示接下来的 6 Bit 整数值加 1 就是零值计数器的数量，注意这里要加 1 是因为数量如果为零是没有意义的。比如 <code>00010101</code> 表示连续 <code>22</code> 个零值计数器。</li><li><code>01xxxxxx yyyyyyyy</code> ：6 Bit 最多只能表示连续 <code>64</code> 个零值计数器，这样扩展出的  14 Bit 可以表示最多连续 <code>16384</code> 个零值计数器。这意味着 HyperLogLog 数据结构中 <code>16384</code> 个桶的初始状态，所有的计数器都是零值，可以直接使用 2 个字节来表示。</li><li><code>1vvvvvxx</code> ：中间 5 Bit 表示计数值，尾部 2 Bit 表示连续几个桶。它的意思是连续 <code>(xx +1)</code> 个计数值都是 <code>(vvvvv + 1)</code> 。比如 <code>10101011</code> 表示连续 <code>4</code> 个计数值都是 <code>11</code> 。</li></ul><blockquote><p>注意：<strong>上面第三种方式</strong> 的计数值最大只能表示到 <code>32</code> ，而 HyperLogLog 的密集存储单个计数值用 6 Bit 表示，最大可以表示到 <code>63</code> 。<strong>当稀疏存储的某个计数值需要调整到大于 <code>32</code> 时，Redis 就会立即转换 HyperLogLog 的存储结构，将稀疏存储转换成密集存储。</strong></p></blockquote><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>HyperLogLog 除了需要存储 16384 个桶的计数值之外，它还有一些附加的字段需要存储，比如总计数缓存、存储类型。所以它使用了一个额外的对象头来表示：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> hllhdr <span class="token punctuation">{</span>    <span class="token keyword">char</span> magic<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* 魔术字符串"HYLL" */</span>    uint8_t encoding<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 存储类型 HLL_DENSE or HLL_SPARSE. */</span>    uint8_t notused<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 保留三个字节未来可能会使用 */</span>    uint8_t card<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 总计数缓存 */</span>    uint8_t registers<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 所有桶的计数器 */</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>所以 <strong>HyperLogLog</strong> 整体的内部结构就是 <strong>HLL 对象头</strong> 加上 <strong>16384</strong> 个桶的计数值位图。它在 Redis 的内部结构表现就是一个字符串位图。你可以把 <strong>HyperLogLog 对象当成普通的字符串来进行处理：</strong></p><pre class=" language-console"><code class="language-console">> PFADD codehole python java golang(integer) 1> GET codehole"HYLL\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80C\x03\x84MK\x80P\xb8\x80^\xf3"</code></pre><p>但是 <strong>不可以</strong> 使用 <strong>HyperLogLog</strong> 指令来 <strong>操纵普通的字符串</strong>，<strong>因为它需要检查对象头魔术字符串是否是 “HYLL”</strong>。</p><h2 id="四、HyperLogLog-的使用"><a href="#四、HyperLogLog-的使用" class="headerlink" title="四、HyperLogLog 的使用"></a>四、HyperLogLog 的使用</h2><p><strong>HyperLogLog</strong> 提供了两个指令 <strong><code>PFADD</code></strong> 和 <strong><code>PFCOUNT</code></strong> ，字面意思就是一个是增加，另一个是获取计数。<code>PFADD</code> 和 <code>set</code> 集合的 <code>SADD</code> 的用法是一样的，来一个用户 ID，就将用户 ID 塞进去就是，<code>PFCOUNT</code> 和 <code>SCARD</code> 的用法是一致的，直接获取计数值：</p><pre class=" language-console"><code class="language-console">> PFADD codehole user1(interger) 1> PFCOUNT codehole(integer) 1> PFADD codehole user2(integer) 1> PFCOUNT codehole(integer) 2> PFADD codehole user3(integer) 1> PFCOUNT codehole(integer) 3> PFADD codehole user4 user 5(integer) 1> PFCOUNT codehole(integer) 5</code></pre><p>我们可以用 Java 编写一个脚本来试试 HyperLogLog 的准确性到底有多少：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JedisTest</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      jedis<span class="token punctuation">.</span><span class="token function">pfadd</span><span class="token punctuation">(</span><span class="token string">"codehole"</span><span class="token punctuation">,</span> <span class="token string">"user"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">long</span> total <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">pfcount</span><span class="token punctuation">(</span><span class="token string">"codehole"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d\n"</span><span class="token punctuation">,</span> <span class="token number">100000</span><span class="token punctuation">,</span> total<span class="token punctuation">)</span><span class="token punctuation">;</span>    jedis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结果输出如下：</p><pre class=" language-java"><code class="language-java"><span class="token number">100000</span> <span class="token number">99723</span></code></pre><p>发现 <code>10</code> 万条数据只差了 <code>277</code> ，按照百分比误差率是 <code>0.277%</code> ，对于巨量的 UV 需求来说，这个误差率真的不算高。</p><p>当然，除了上面的 <code>PFADD</code> 和 <code>PFCOUNT</code> 之外，还提供了第三个 <code>PFMEGER</code> 指令，用于将多个计数值累加在一起形成一个新的 <code>PF</code> 值：</p><pre class=" language-console"><code class="language-console">> PFADD  nosql  "Redis"  "MongoDB"  "Memcached"(integer) 1> PFADD  RDBMS  "MySQL" "MSSQL" "PostgreSQL"(integer) 1> PFMERGE  databases  nosql  RDBMSOK> PFCOUNT  databases(integer) 6</code></pre><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><ol><li>Redis(1)——5种基本数据结构 - <a href="https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/" target="_blank" rel="noopener">https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/</a></li><li>Redis(2)——跳跃表 - <a href="https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/" target="_blank" rel="noopener">https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/</a></li><li>Redis(3)——分布式锁深入探究 - <a href="https://www.wmyskxz.com/2020/03/01/redis-3/" target="_blank" rel="noopener">https://www.wmyskxz.com/2020/03/01/redis-3/</a></li></ol><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ol><li>【算法原文】HyperLogLog: the analysis of a near-optimal<br>cardinality estimation algorithm - <a href="http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf" target="_blank" rel="noopener">http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf</a></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>【Redis 作者博客】Redis new data structure: the HyperLogLog - <a href="http://antirez.com/news/75" target="_blank" rel="noopener">http://antirez.com/news/75</a></li><li>神奇的 HyperLogLog 算法 - <a href="http://www.rainybowe.com/blog/2017/07/13/%E7%A5%9E%E5%A5%87%E7%9A%84HyperLogLog%E7%AE%97%E6%B3%95/index.html" target="_blank" rel="noopener">http://www.rainybowe.com/blog/2017/07/13/%E7%A5%9E%E5%A5%87%E7%9A%84HyperLogLog%E7%AE%97%E6%B3%95/index.html</a></li><li>深度探索 Redis HyperLogLog 内部数据结构 - <a href="https://zhuanlan.zhihu.com/p/43426875" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/43426875</a></li><li>《Redis 深度历险》- 钱文品/ 著</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis总结</title>
      <link href="/2020/04/26/shu-ju-ku/redis-zong-jie/"/>
      <url>/2020/04/26/shu-ju-ku/redis-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis-总结"><a href="#Redis-总结" class="headerlink" title="Redis 总结"></a>Redis 总结</h2><h3 id="回望过去"><a href="#回望过去" class="headerlink" title="回望过去"></a>回望过去</h3><p>上几期吊打系列我们提到了 Redis 的很多知识，还没看的小伙伴可以回顾一下！</p><ul><li><a href="https://www.niewenjun.com/2020/04/22/shu-ju-ku/redis-ji-chu">《吊打面试官》系列-Redis基础</a></li><li><a href="https://www.niewenjun.com/2020/04/24/shu-ju-ku/redis-huan-cun-xue-beng-chuan-tou-ji-chuan">《吊打面试官》系列-Redis缓存雪崩、穿透、击穿</a></li><li><a href="https://www.niewenjun.com/2020/04/24/shu-ju-ku/redis-ji-qun-chi-jiu-hua-lru">《吊打面试官》系列-Redis集群、持久化、LRU</a></li><li><a href="https://www.niewenjun.com/2020/04/25/shu-ju-ku/redis-xian-cheng-mo-xing-shuang-xie-yi-zhi-xing">《吊打面试官》系列-Redis线程模型、双写一致性</a></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>话不多说，一张贴图。</p><p><img src="https://s1.ax1x.com/2020/04/26/JcRq2D.jpg" alt="Redis 总结"></p><h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><h4 id="Bitmap："><a href="#Bitmap：" class="headerlink" title="Bitmap："></a><strong>Bitmap：</strong></h4><p>位图是支持按 Bit 位来存储信息，可以用来实现 <strong>布隆过滤器（BloomFilter）</strong>。</p><h4 id="HyperLogLog："><a href="#HyperLogLog：" class="headerlink" title="HyperLogLog："></a><strong>HyperLogLog：</strong></h4><p>提供不精确的去重计数功能，比较适合用来做大规模数据的去重统计，例如统计 UV 。</p><h4 id="Geospatial："><a href="#Geospatial：" class="headerlink" title="Geospatial："></a><strong>Geospatial：</strong></h4><p>可以用来保存地理位置，并作位置距离计算或者根据半径计算位置等。有没有想过用 Redis 来实现附近的人？或者计算最优地图路径？</p><p>这三个其实也可以算作一种数据结构，不知道还有多少朋友记得，我在梦开始的地方，Redis 基础中提到过，你如果只知道五种基础类型那只能拿 60 分，如果你能讲出高级用法，那就觉得你<strong>有点东西</strong>。</p><h4 id="Pub-Sub："><a href="#Pub-Sub：" class="headerlink" title="Pub/Sub："></a><strong>Pub/Sub：</strong></h4><p>功能是订阅发布功能，可以用作简单的消息队列。 </p><h4 id="Pipeline："><a href="#Pipeline：" class="headerlink" title="Pipeline："></a><strong>Pipeline：</strong></h4><p>可以批量执行一组指令，一次性返回全部结果，可以减少频繁的请求应答。</p><h4 id="Lua："><a href="#Lua：" class="headerlink" title="Lua："></a><strong>Lua：</strong></h4><p><strong>Redis</strong> 支持提交 <strong>Lua</strong> 脚本来执行一系列的功能。</p><p>秒杀场景经常使用这个东西，讲道理有点香，利用他的原子性。</p><p>话说你们想看秒杀的设计么？我记得我面试好像每次都问啊，后面有时间的话出一期关于<strong>秒杀系统设计</strong>的吧。</p><h4 id="事务："><a href="#事务：" class="headerlink" title="事务："></a><strong>事务：</strong></h4><p>最后一个功能是事务，但 <strong>Redis</strong> 提供的不是严格的事务，<strong>Redis</strong> 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去。</p><h3 id="考点与加分项"><a href="#考点与加分项" class="headerlink" title="考点与加分项"></a>考点与加分项</h3><p><strong>拿笔记一下！</strong></p><p><img src="https://s1.ax1x.com/2020/04/26/JcWLF0.jpg" alt=""></p><h4 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h4><p>面试的时候问你缓存，主要是考察缓存特性的理解，对 <strong>MC</strong>、<strong>Redis</strong> 的特点和使用方式的掌握。</p><ul><li><p>要知道缓存的使用场景，不同类型缓存的使用方式，例如：</p><ul><li>对 DB 热点数据进行缓存减少 DB 压力；对依赖的服务进行缓存，提高并发性能；</li><li>单纯 K-V 缓存的场景可以使用 <strong>MC</strong>，而需要缓存 List、Set 等特殊数据格式，可以使用 <strong>Redis</strong> ；</li><li>需要缓存一个用户最近播放视频的列表可以使用 <strong>Redis</strong> 的 List 来保存、需要计算排行榜数据时，可以使用 <strong>Redis</strong> 的 ZSet 结构来保存。</li></ul></li><li><p>要了解 <strong>MC</strong> 和 <strong>Redis</strong> 的常用命令，例如原子增减、对不同数据结构进行操作的命令等。</p></li><li><p>了解 <strong>MC</strong> 和 <strong>Redis</strong> 在内存中的存储结构，这对评估使用容量会很有帮助。</p></li><li><p>了解 <strong>MC</strong>  和 <strong>Redis</strong> 的数据失效方式和删除策略，比如主动触发的定期删除和被动触发的惰性剔除。</p></li><li><p>要理解 <strong>Redis</strong> 的持久化、主从同步与 <strong>Cluster</strong> 部署的原理，比如 <strong>RDB</strong> 和 <strong>AOF</strong> 的实现方式与区别。</p></li><li><p>要知道缓存穿透、击穿、雪崩分别的异同点以及解决方案。</p></li><li><p>不管你有没有电商经验我觉得你都应该知道秒杀的具体实现，以及细节点。</p></li><li><p>……..</p></li></ul><h4 id="加分项"><a href="#加分项" class="headerlink" title="加分项"></a>加分项</h4><p>如果想要在面试中获得更好的表现，还应了解下面这些加分项。</p><ul><li><p>是要结合实际应用场景来介绍缓存的使用。例如调用后端服务接口获取信息时，可以使用本地+远程的<strong>多级缓存</strong>；对于动态排行榜类的场景可以考虑通过 <strong>Redis</strong> 的 <strong>Sorted Set</strong> 来实现等。</p></li><li><p>最好你有过分布式缓存设计和使用经验，例如项目中在什么场景使用过 <strong>Redis</strong> ，使用了什么数据结构，解决哪类的问题；使用 <strong>MC</strong> 时根据预估值大小调整 <strong>McSlab</strong> 分配参数等。</p></li><li><p>最好可以了解缓存使用中可能产生的问题。比如 <strong>Redis</strong> 是单线程处理请求，应尽量避免耗时较高的单个请求任务，防止相互影响；<strong>Redis</strong> 服务应避免和其他 CPU 密集型的进程部署在同一机器；或者禁用 <strong>Swap</strong> 内存交换，防止 <strong>Redis</strong> 的缓存数据交换到硬盘上，影响性能。再比如前面提到的 <strong>MC</strong> 钙化问题等。</p></li><li><p>要了解 <strong>Redis</strong> 的典型应用场景，例如，使用 <strong>Redis</strong> 来实现分布式锁；使用 <strong>Bitmap</strong> 来实现 <strong>BloomFilter</strong>，使用 <strong>HyperLogLog</strong> 来进行 UV 统计等。</p></li><li><p>知道 Redis 4.0、5.0 中的新特性，例如支持多播的可持久化消息队列 <strong>Stream</strong>；通过 <strong>Module</strong> 系统来进行定制功能扩展等。</p></li><li><p>……..</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis线程模型、双写一致性</title>
      <link href="/2020/04/25/shu-ju-ku/redis-xian-cheng-mo-xing-shuang-xie-yi-zhi-xing/"/>
      <url>/2020/04/25/shu-ju-ku/redis-xian-cheng-mo-xing-shuang-xie-yi-zhi-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-线程模型、双写一致性"><a href="#Redis-线程模型、双写一致性" class="headerlink" title="Redis 线程模型、双写一致性"></a>Redis 线程模型、双写一致性</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>Redis</strong> 在互联网技术存储方面使用如此广泛，几乎所有的后端技术面试官都要在 <strong>Redis</strong> 的使用和原理方面对小伙伴们进行 360° 的刁难。作为一个在互联网公司面一次拿一次 offer 的面霸（<strong>请允许我使用一下夸张的修辞手法</strong>），打败了无数竞争对手，每次都只能看到无数落寞的身影失望的离开，略感愧疚，在一个寂寞难耐的夜晚，我痛定思痛，决定开始写<strong>《吊打面试官》</strong>系列，希望能帮助各位读者以后面试势如破竹，对面试官进行 360° 的反击，吊打问你的面试官，让一同面试的同僚瞠目结舌，疯狂收割大厂 offer ！</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>上几期吊打系列我们提到了 Redis 的很多知识，还没看的小伙伴可以回顾一下！</p><ul><li><a href="https://www.niewenjun.com/2020/04/22/shu-ju-ku/redis-ji-chu">《吊打面试官》系列-Redis基础</a></li><li><a href="https://www.niewenjun.com/2020/04/24/shu-ju-ku/redis-huan-cun-xue-beng-chuan-tou-ji-chuan">《吊打面试官》系列-Redis缓存雪崩、穿透、击穿</a></li><li><a href="https://www.niewenjun.com/2020/04/24/shu-ju-ku/redis-ji-qun-chi-jiu-hua-lru">《吊打面试官》系列-Redis集群、持久化、LRU</a></li></ul><p>那提到 <strong>Redis</strong> 我相信各位在面试，或者实际开发过程中对基本类型的使用场景，并发竞争带来的问题，以及缓存数据库双写入一致性的问题等，我们有请下一位受害者。</p><h2 id="面试开始"><a href="#面试开始" class="headerlink" title="面试开始"></a>面试开始</h2><blockquote><p>一个大腹便便，穿着格子衬衣的中年男子，拿着一个满是划痕的 Mac 向你走来，看着快秃顶的头发，心想着肯定是尼玛顶级架构师吧！但是我们腹有诗书气自华，虚都不虚。</p></blockquote><p><img src="https://s1.ax1x.com/2020/04/26/J6Xd1A.jpg" alt=""></p><h3 id="小伙子，你还记得我在第一章里面问过你，Redis-有几种基础数据类型么？"><a href="#小伙子，你还记得我在第一章里面问过你，Redis-有几种基础数据类型么？" class="headerlink" title="小伙子，你还记得我在第一章里面问过你，Redis 有几种基础数据类型么？"></a>小伙子，你还记得我在第一章里面问过你，Redis 有几种基础数据类型么？</h3><p>嗯嗯，帅气的面试官，我肯定记得，没齿难忘！！！</p><p>我特么谢谢你，都四面了还不给 Offer ！</p><p><img src="https://s1.ax1x.com/2020/04/26/J6Xr0f.jpg" alt=""></p><h3 id="那你能说一下他们的特性，还有分别的使用场景么？"><a href="#那你能说一下他们的特性，还有分别的使用场景么？" class="headerlink" title="那你能说一下他们的特性，还有分别的使用场景么？"></a>那你能说一下他们的特性，还有分别的使用场景么？</h3><p>行吧，那我先从 String 说起。</p><h4 id="String："><a href="#String：" class="headerlink" title="String："></a>String：</h4><p>这是最简单的类型，就是普通的 set 和 get ，做简单的 KV 缓存。</p><p>但是真实的开发环境中，很多仔可能会把很多比较复杂的结构也统一转成 <strong>String</strong> 去存储使用，比如有的仔他就喜欢把对象或者 <strong>List</strong> 转换为 <strong>JSONString</strong> 进行存储，拿出来再反序列话啥的。</p><p>我在这里就不讨论这样做的对错了，但是我还是希望大家能在最合适的场景使用最合适的数据结构，对象找不到最合适的但是类型可以选最合适的嘛，之后别人接手你的代码一看这么<strong>规范</strong>，诶这小伙子<strong>有点东西</strong>呀，看到你啥都是用的 <strong>String</strong>，<strong>垃圾！</strong></p><p><img src="https://s1.ax1x.com/2020/04/26/J6jZut.jpg" alt=""></p><p>好了这些都是题外话了，道理还是希望大家记在心里，习惯成自然嘛，小习惯成就你。</p><p><strong>String</strong> 的实际应用场景比较广泛的有：</p><ul><li><p><strong>缓存功能：String</strong> 字符串是最常用的数据类型，不仅仅是 <strong>Redis</strong> ，各个语言都是最基本类型，因此，利用 <strong>Redis</strong> 作为缓存，配合其它数据库作为存储层，利用 <strong>Redis</strong> 支持高并发的特点，可以大大加快系统的读写速度、以及降低后端数据库的压力。</p></li><li><p><strong>计数器：</strong>许多系统都会使用 <strong>Redis</strong> 作为系统的实时计数器，可以快速实现计数和查询的功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其它存储介质当中进行永久保存。</p></li><li><p><strong>共享用户 Session ：</strong>用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存 <strong>Cookie</strong> ，但是可以利用 <strong>Redis</strong> 将用户的 <strong>Session</strong> 集中管理，在这种模式只需要保证 <strong>Redis</strong> 的高可用，每次用户 <strong>Session</strong> 的更新和获取都可以快速完成。大大提高效率。</p></li></ul><h4 id="Hash："><a href="#Hash：" class="headerlink" title="Hash："></a>Hash：</h4><p>这个是类似 <strong>Map</strong> 的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是<strong>这个对象没嵌套其他的对象</strong>）给缓存在 <strong>Redis</strong> 里，然后每次读写缓存的时候，可以就操作 <strong>Hash</strong> 里的<strong>某个字段</strong>。</p><p>但是这个的场景其实还是多少单一了一些，因为现在很多对象都是比较复杂的，比如你的商品对象可能里面就包含了很多属性，其中也有对象。我自己使用的场景用得不是那么多。</p><h4 id="List："><a href="#List：" class="headerlink" title="List："></a>List：</h4><p><strong>List</strong> 是有序列表，这个还是可以玩儿出很多花样的。</p><p>比如可以通过 <strong>List</strong> 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西。</p><p>比如可以通过 <strong><code>lrange</code></strong> 命令，读取某个闭区间内的元素，可以基于 <strong>List</strong> 实现<strong>分页查询</strong>，这个是很棒的一个功能，基于 <strong>Redis</strong> 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。</p><p>比如可以搞个简单的<strong>消息队列</strong>，从 <strong>List</strong> 头怼进去，从 <strong>List</strong> 屁股那里弄出来。</p><p><strong>List</strong> 本身就是我们在开发过程中比较常用的数据结构了，热点数据更不用说了。</p><ul><li><p><strong>消息队列：Redis</strong> 的链表结构，可以轻松实现阻塞队列，可以使用左进右出的命令组成来完成队列的设计。</p><p>比如：数据的生产者可以通过 <strong>Lpush</strong> 命令从左边插入数据，多个数据消费者，可以使用 <strong>BRpop</strong> 命令阻塞地“抢”列表尾部的数据。</p></li><li><p>文章列表或者数据分页展示的应用。</p><p>比如，我们常用的博客网站的文章列表，当用户量越来越多时，而且每一个用户都有自己的文章列表，而且当文章多时，都需要分页展示，这时可以考虑使用 <strong>Redis</strong> 的列表，列表不但有序同时还支持按照范围内获取元素，可以完美解决分页查询功能。大大提高查询效率。</p></li></ul><h4 id="Set："><a href="#Set：" class="headerlink" title="Set："></a>Set：</h4><p><strong>Set</strong> 是无序集合，会自动去重的那种。</p><p>直接基于 <strong>Set</strong> 将系统里需要去重的数据扔进去，自动就给去重了，如果你需要对一些数据进行快速的全局去重，你当然也可以基于 <strong>JVM</strong> 内存里的 <strong>HashSet</strong> 进行去重，但是如果你的某个系统部署在多台机器上呢？得基于 <strong>Redis</strong> 进行全局的 <strong>Set</strong> 去重。</p><p>可以基于 <strong>Set</strong> 玩儿交集、并集、差集的操作，比如交集吧，我们可以把两个人的好友列表整一个交集，看看俩人的共同好友是谁？对吧。</p><p>反正这些场景比较多，因为对比很快，操作也简单，两个查询一个 <strong>Set</strong> 搞定。</p><h4 id="Sorted-Set："><a href="#Sorted-Set：" class="headerlink" title="Sorted Set："></a>Sorted Set：</h4><p><strong>Sorted Set</strong> 是排序的 <strong>Set</strong> ，去重但可以排序，写进去的时候给一个分数，自动根据分数排序。</p><p>有序集合的使用场景与集合类似，但是 set 集合不是自动有序的，而 <strong>Sorted Set</strong> 可以利用分数进行成员间的排序，而且是插入时就排序好。所以当你需要一个有序且不重复的集合列表时，就可以选择 <strong>Sorted Set</strong> 数据结构作为选择方案。</p><ul><li>排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。</li><li>用 <strong>Sorted Set</strong> 来做带权重的队列，比如普通消息的 score 为 1 ，重要消息的 score 为 2 ，然后工作线程可以选择按 score 的倒序来获取工作任务。让重要的任务优先执行。</li></ul><p>如微博热搜榜，就是有个后面的热度值，前面就是名称：</p><p><img src="https://s1.ax1x.com/2020/04/26/J6jLa8.jpg" alt="微博热搜榜"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>Redis</strong> 基础类型有五种，这个我在基础里面也有提到了，这个问题其实一般都是对 P6 以下，也就是 1-3 年左右的小伙伴可能是会问得比较多的问题。</p><p>能回答出来五种我想大家都可以，但是不知道大家是否知道，五种类型具体的使用场景，以及什么时候用什么类型最合适呢？</p><p>要是你回答的不好，没说出几种数据类型，也没说什么场景，你完了，面试官对你印象肯定不好，觉得你平时就是做个简单的 set 和 get 。所以看似很简单的面试题实则最容易看出你的深浅了，大家都要注意<strong>打好基础</strong>。</p><h3 id="为什么要用-Redis-而不用-Map-Guava-做缓存"><a href="#为什么要用-Redis-而不用-Map-Guava-做缓存" class="headerlink" title="为什么要用 Redis 而不用 Map/Guava 做缓存?"></a>为什么要用 Redis 而不用 Map/Guava 做缓存?</h3><blockquote><p>下面的内容来自 segmentfault 一位网友的提问，地址：<a href="https://segmentfault.com/q/1010000009106416" target="_blank" rel="noopener">https://segmentfault.com/q/1010000009106416</a></p></blockquote><p>缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 Map 或者 Guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 JVM 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p><p>使用 Redis 或 Memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 Redis 或  Memcached 服务的高可用，整个程序架构上较为复杂。</p><h3 id="你有没有考虑过，如果你多个系统同时操作（并发）Redis-带来的数据问题？"><a href="#你有没有考虑过，如果你多个系统同时操作（并发）Redis-带来的数据问题？" class="headerlink" title="你有没有考虑过，如果你多个系统同时操作（并发）Redis 带来的数据问题？"></a>你有没有考虑过，如果你多个系统同时操作（并发）Redis 带来的数据问题？</h3><p>嗯嗯这个问题我以前开发的时候遇到过，其实并发过程中确实会有这样的问题，比如下面这样的情况：</p><p><img src="https://s1.ax1x.com/2020/04/26/J6vnMR.jpg" alt="并发操作 Redis"></p><p>系统 A、B、C 三个系统，分别去操作 <strong>Redis</strong> 的同一个Key，本来顺序是 1，2，3 是正常的，但是因为系统 A 网络突然抖动了一下，B、C 在他前面操作了 <strong>Redis</strong> ，这样数据不就错了么。</p><p>就好比下单，支付，退款三个顺序你变了，你先退款，再下单，再支付，那流程就会失败，那数据不就乱了？你订单还没生成你却支付，退款了？明显走不通了，这在线上是很恐怖的事情。</p><h3 id="那这种情况怎么解决呢？"><a href="#那这种情况怎么解决呢？" class="headerlink" title="那这种情况怎么解决呢？"></a>那这种情况怎么解决呢？</h3><p>我们可以找个管家帮我们管理好数据的嘛！</p><p><img src="https://s1.ax1x.com/2020/04/26/J6voYF.jpg" alt="ZooKeeper 分布式锁"></p><p>某个时刻，多个系统实例都去更新某个 Key 。可以基于 <strong>ZooKeeper</strong> 实现分布式锁。每个系统通过 <strong>ZooKeeper</strong> 获取分布式锁，确保同一时间，只能有一个系统实例在操作某个 Key，别人都不允许读和写。</p><p>你要写入缓存的数据，都是从 <strong>MySQL</strong> 里查出来的，都得写入 <strong>MySQL</strong> 中，写入 <strong>MySQL</strong> 中的时候必须保存一个时间戳，从 <strong>MySQL</strong> 查出来的时候，时间戳也查出来。</p><p>每次要<strong>写之前，先判断</strong>一下当前这个 Value 的时间戳是否比缓存里的 Value 的时间戳要新。如果是的话，那么可以写，否则，就不能用旧的数据覆盖新的数据。</p><h3 id="你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？"><a href="#你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？" class="headerlink" title="你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？"></a>你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</h3><p>一般来说，如果允许缓存可以稍微的跟数据库偶尔有不一致的情况，也就是说如果你的系统<strong>不是严格要求</strong> “缓存+数据库” 必须保持一致性的话，最好不要做这个方案，即：<strong>读请求和写请求串行化</strong>，串到一个<strong>内存队列</strong>里去。</p><p>串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p><p>把一些列的操作都放到队列里面，顺序肯定不会乱，但是并发高了，这队列很容易阻塞，反而会成为整个系统的弱点、瓶颈。</p><p><img src="https://s1.ax1x.com/2020/04/26/J6xctO.jpg" alt=""></p><h3 id="你了解最经典的-KV、DB-读写模式么？"><a href="#你了解最经典的-KV、DB-读写模式么？" class="headerlink" title="你了解最经典的 KV、DB 读写模式么？"></a>你了解最经典的 KV、DB 读写模式么？</h3><p>最经典的缓存+数据库读写的模式，就是 <strong><code>Cache Aside Pattern</code></strong> 。</p><ul><li>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</li><li>更新的时候，<strong>先更新数据库，然后再删除缓存</strong>。</li></ul><h3 id="为什么是删除缓存，而不是更新缓存？"><a href="#为什么是删除缓存，而不是更新缓存？" class="headerlink" title="为什么是删除缓存，而不是更新缓存？"></a>为什么是删除缓存，而不是更新缓存？</h3><p>原因很简单，很多时候，在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。</p><p>比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值的。</p><p>另外更新缓存的代价有时候是很高的。是不是说，每次修改数据库的时候，都一定要将其对应的缓存更新一份？也许有的场景是这样，但是对于<strong>比较复杂的缓存数据计算的场景</strong>，就不是这样了。如果你频繁修改一个缓存涉及的多个表，缓存也频繁更新。但是问题在于，<strong>这个缓存到底会不会被频繁访问到？</strong></p><p>举个栗子：一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有<strong>大量的冷数据</strong>。</p><p>实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。<strong>用到缓存才去算缓存。</strong></p><p>其实删除缓存，而不是更新缓存，就是一个 Lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。</p><p>像 <strong>Mybatis</strong> 、<strong>Hibernate</strong>，都有懒加载思想。查询一个部门，部门带了一个员工的 <strong>List</strong>，没有必要说每次查询部门，都里面的 1000 个员工的数据也同时查出来啊。80% 的情况，查这个部门，就只是要访问这个部门的信息就可以了。先查部门，同时要访问里面的员工，那么这个时候只有在你要访问里面的员工的时候，才会去数据库里面查询 1000 个员工。</p><h3 id="最初级的缓存不一致问题及解决方案"><a href="#最初级的缓存不一致问题及解决方案" class="headerlink" title="最初级的缓存不一致问题及解决方案"></a>最初级的缓存不一致问题及解决方案</h3><p><strong>问题：</strong>先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。</p><p><img src="https://s1.ax1x.com/2020/04/26/Jcijit.png" alt="redis-junior-inconsistent"></p><p><strong>解决思路：</strong>先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。</p><h3 id="比较复杂的数据不一致问题分析"><a href="#比较复杂的数据不一致问题分析" class="headerlink" title="比较复杂的数据不一致问题分析"></a>比较复杂的数据不一致问题分析</h3><p>数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，<strong>查到了修改前的旧数据</strong>，放到了缓存中。随后数据变更的程序完成了数据库的修改。完了，数据库和缓存中的数据不一样了…</p><p><strong>为什么上亿流量高并发场景下，缓存会出现这个问题？</strong></p><p>只有在对一个数据在并发的进行读写的时候，才可能会出现这种问题。其实如果说你的并发量很低的话，特别是读并发很低，每天访问量就 1 万次，那么很少的情况下，会出现刚才描述的那种不一致的场景。但是问题是，如果每天的是上亿的流量，每秒并发读是几万，每秒只要有数据更新的请求，就<strong>可能会出现上述的数据库+缓存不一致的情况</strong>。</p><p><strong>解决方案如下：</strong></p><p>更新数据的时候，根据<strong>数据的唯一标识</strong>，将操作路由之后，发送到一个 JVM 内部队列中。读取数据的时候，如果发现数据不在缓存中，那么将重新执行“读取数据+更新缓存”的操作，根据唯一标识路由之后，也发送到同一个 JVM 内部队列中。</p><p>一个队列对应一个工作线程，每个工作线程<strong>串行</strong>拿到对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先删除缓存，然后再去更新数据库，但是还没完成更新。此时如果一个读请求过来，没有读到缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。</p><p>这里有一个<strong>优化点</strong>，一个队列中，其实<strong>多个更新缓存请求串在一起是没意义的</strong>，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可。</p><p>待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中。</p><p>如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。</p><p><strong>高并发的场景下，该解决方案要注意的问题：</strong></p><ul><li><strong><code>读请求长时阻塞</code></strong></li></ul><p>由于读请求进行了非常轻度的异步化，所以一定要注意读超时的问题，每个读请求必须在超时时间范围内返回。</p><p>该解决方案，最大的风险点在于说，<strong>可能数据更新很频繁</strong>，导致队列中积压了大量更新操作在里面，然后<strong>读请求会发生大量的超时</strong>，最后导致大量的请求直接走数据库。务必通过一些模拟真实的测试，看看更新数据的频率是怎样的。</p><p>另外一点，因为一个队列中，可能会积压针对多个数据项的更新操作，因此需要根据自己的业务情况进行测试，可能需要<strong>部署多个服务</strong>，每个服务分摊一些数据的更新操作。如果一个内存队列里居然会挤压 100 个商品的库存修改操作，每个库存修改操作要耗费 10ms 去完成，那么最后一个商品的读请求，可能等待 10 * 100 = 1000ms = 1s 后，才能得到数据，这个时候就导致<strong>读请求的长时阻塞</strong>。</p><p>一定要做根据实际业务系统的运行情况，去进行一些压力测试，和模拟线上环境，去看看最繁忙的时候，内存队列可能会挤压多少更新操作，可能会导致最后一个更新操作对应的读请求，会 hang 多少时间，如果读请求在 200ms 返回，如果你计算过后，哪怕是最繁忙的时候，积压 10 个更新操作，最多等待 200ms，那还可以的。</p><p><strong>如果一个内存队列中可能积压的更新操作特别多</strong>，那么你就要<strong>加机器</strong>，让每个机器上部署的服务实例处理更少的数据，那么每个内存队列中积压的更新操作就会越少。</p><p>其实根据之前的项目经验，一般来说，数据的写频率是很低的，因此实际上正常来说，在队列中积压的更新操作应该是很少的。像这种针对读高并发、读缓存架构的项目，一般来说写请求是非常少的，每秒的 QPS 能到几百就不错了。</p><p>我们来<strong>实际粗略测算一下</strong>。</p><p>如果一秒有 500 的写操作，如果分成 5 个时间片，每 200ms 就 100 个写操作，放到 20 个内存队列中，每个内存队列，可能就积压 5 个写操作。每个写操作性能测试后，一般是在 20ms 左右就完成，那么针对每个内存队列的数据的读请求，也就最多 hang 一会儿，200ms 以内肯定能返回了。</p><p>经过刚才简单的测算，我们知道，单机支撑的写 QPS 在几百是没问题的，如果写 QPS 扩大了 10 倍，那么就扩容机器，扩容 10 倍的机器，每个机器 20 个队列。</p><ul><li><strong><code>读请求并发量过高</code></strong></li></ul><p>这里还必须做好压力测试，确保恰巧碰上上述情况的时候，还有一个风险，就是突然间大量读请求会在几十毫秒的延时 hang 在服务上，看服务能不能扛的住，需要多少机器才能扛住最大的极限情况的峰值。</p><p>但是因为并不是所有的数据都在同一时间更新，缓存也不会同一时间失效，所以每次可能也就是少数数据的缓存失效了，然后那些数据对应的读请求过来，并发量应该也不会特别大。</p><ul><li><strong><code>多服务实例部署的请求路由</code></strong></li></ul><p>可能这个服务部署了多个实例，那么必须<strong>保证</strong>说，执行数据更新操作，以及执行缓存更新操作的请求，都通过 Nginx 服务器<strong>路由到相同的服务实例上</strong>。</p><p>比如说，对同一个商品的读写请求，全部路由到同一台机器上。可以自己去做服务间的按照某个请求参数的 Hash 路由，也可以用 Nginx 的 Hash 路由功能等等。</p><ul><li><strong><code>热点商品的路由问题，导致请求的倾斜</code></strong></li></ul><p>万一某个商品的读写请求特别高，全部打到相同的机器的相同的队列里面去了，可能会造成某台机器的压力过大。就是说，因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以其实要根据业务系统去看，如果更新频率不是太高的话，这个问题的影响并不是特别大，但是的确可能某些机器的负载会高一些。</p><blockquote><p>关于这道面试题的详细讨论，见 <a href="https://github.com/doocs/advanced-java/issues/54" target="_blank" rel="noopener">#54</a> 。</p></blockquote><h3 id="Redis-和-Memcached-有啥区别，为啥选择用-Redis-作为你们的缓存中间件？"><a href="#Redis-和-Memcached-有啥区别，为啥选择用-Redis-作为你们的缓存中间件？" class="headerlink" title="Redis 和 Memcached 有啥区别，为啥选择用 Redis 作为你们的缓存中间件？"></a>Redis 和 Memcached 有啥区别，为啥选择用 Redis 作为你们的缓存中间件？</h3><p><img src="https://s1.ax1x.com/2020/04/26/Jca0Fs.jpg" alt="Redis 和 Memcached 的区别"></p><ul><li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）：</strong>Redis 不仅仅支持简单的 K/V 类型的数据，同时还提供 Hash、List、Set、ZSet 等数据结构的存储。Memcache 支持简单的数据类型，如 String 。</li><li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中。</strong></li><li><strong>集群模式：</strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据，但是 Redis 目前是原生支持 Cluster 模式的。</li><li><strong>Memcached 是多线程、非阻塞 IO 复用的网络模型，Redis 使用单线程的多路 IO 复用模型。</strong></li></ul><h3 id="Redis-的线程模型了解么？"><a href="#Redis-的线程模型了解么？" class="headerlink" title="Redis 的线程模型了解么？"></a>Redis 的线程模型了解么？</h3><p><img src="https://s1.ax1x.com/2020/04/26/JcsQnx.png" alt="Redis 线程模型"></p><p><strong>Redis</strong> 内部使用文件事件分派器，这个文件事件分派器是单线程的，所以 <strong>Redis</strong> 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 <strong>Socket</strong>，根据 <strong>Socket</strong> 上的事件来选择对应的事件处理器进行处理。</p><p>Redis 的线程模型包含 4 个部分：</p><ul><li>多个 <strong>Socket</strong></li><li>IO 多路复用程序</li><li>文件事件分派器</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><p>多个 <strong>Socket</strong> 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 <strong>Socket</strong> ，会将 <strong>Socket</strong> 产生的事件放入队列中排队，文件事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p><h2 id="面试结束"><a href="#面试结束" class="headerlink" title="面试结束"></a>面试结束</h2><h3 id="小伙子对你面试了四轮，你说话有理有据，逻辑清晰，来公司后肯定是一把好手，我想要不你来当我的-Leader-吧，哈哈？"><a href="#小伙子对你面试了四轮，你说话有理有据，逻辑清晰，来公司后肯定是一把好手，我想要不你来当我的-Leader-吧，哈哈？" class="headerlink" title="小伙子对你面试了四轮，你说话有理有据，逻辑清晰，来公司后肯定是一把好手，我想要不你来当我的 Leader 吧，哈哈？"></a>小伙子对你面试了四轮，你说话有理有据，逻辑清晰，来公司后肯定是一把好手，我想要不你来当我的 Leader 吧，哈哈？</h3><p>面试官别跟我开玩笑了，我跟您这样日积月累的技术专家还是有很多差距的，您的经验和技术上的深度，没有很长时间的磨练是无法达到的，我还得多跟您学习。</p><h3 id="好的，小伙子有点东西，你年少有为不自卑，知道什么是珍贵，就是你了来上班吧。"><a href="#好的，小伙子有点东西，你年少有为不自卑，知道什么是珍贵，就是你了来上班吧。" class="headerlink" title="好的，小伙子有点东西，你年少有为不自卑，知道什么是珍贵，就是你了来上班吧。"></a>好的，小伙子有点东西，你年少有为不自卑，知道什么是珍贵，就是你了来上班吧。</h3><p>好的面试官，不过我想我在 Java 基础、MQ 、Dubbo 等领域还有好多知识点您没问我，要不下次继续面我？</p><p>能撑到最后，你自己都忍不住自己给自己点个赞了！</p><hr><p><strong>《吊打面试官》Redis 系列 —- 全剧终</strong></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>既然都说了是 <strong>Redis</strong> 的终章我最后也做个 <strong>Redis</strong> 方面常见面试题的总结，答案大家要去思考，我前面的文章基本上都提到了，教大家怎么回答只是帮大家组织下语言，真正的场景解决方案还是要大家理解的。</p><ul><li>在集群模式下，Redis 的 Key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 Hash 算法吗？</li><li>使用 Redis 有哪些好处？</li><li>Redis 相比 Memcached 有哪些优势？</li><li>Redis 常见性能问题和解决方案？</li><li>MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据？</li><li>Memcache 与 Redis 的区别都有哪些？</li><li>Redis 常见的性能问题都有哪些？如何解决？</li><li>在什么样的场景下可以充分的利用 Redis 的特性，大大提高 Redis 的效率？</li><li>Redis 的缓存雪崩、穿透、击穿了解么？有什么异同点？分别怎么解决？</li><li>Redis 的基本类型有哪些？他们的使用场景了解么？比较高级的用法你使用过么？</li><li>Redis 主从怎么同步数据的？集群的高可用怎么保证？持久化机制了解么？</li><li>为什么 Redis 单线程却能支撑高并发？</li><li>如何保证缓存和数据库数据的一致性？</li><li>项目中是怎么用缓存的，用了缓存之后会带来什么问题？</li></ul><p>好了，以上就是这篇文章的全部内容了，能看到这里的人呀，都是<strong>人才</strong>，祝各位看官都能成为 offer 收割机^∨^。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis集群、持久化、LRU</title>
      <link href="/2020/04/24/shu-ju-ku/redis-ji-qun-chi-jiu-hua-lru/"/>
      <url>/2020/04/24/shu-ju-ku/redis-ji-qun-chi-jiu-hua-lru/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-集群、哨兵、持久化、LRU"><a href="#Redis-集群、哨兵、持久化、LRU" class="headerlink" title="Redis 集群、哨兵、持久化、LRU"></a>Redis 集群、哨兵、持久化、LRU</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>Redis</strong> 在互联网技术存储方面使用如此广泛，几乎所有的后端技术面试官都要在 <strong>Redis</strong> 的使用和原理方面对小伙伴们进行 360° 的刁难。作为一个在互联网公司面一次拿一次 offer 的面霸（<strong>请允许我使用一下夸张的修辞手法</strong>），打败了无数竞争对手，每次都只能看到无数落寞的身影失望的离开，略感愧疚，在一个寂寞难耐的夜晚，我痛定思痛，决定开始写<strong>《吊打面试官》</strong>系列，希望能帮助各位读者以后面试势如破竹，对面试官进行 360° 的反击，吊打问你的面试官，让一同面试的同僚瞠目结舌，疯狂收割大厂 <strong>offer</strong> ！</p><hr><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>上几期<strong>《吊打面试官》</strong>还没看的小伙伴可以回顾一下！</p><ul><li><a href="https://www.niewenjun.com/2020/04/22/shu-ju-ku/redis-ji-chu">《吊打面试官》系列-Redis基础</a></li><li><a href="https://www.niewenjun.com/2020/04/24/shu-ju-ku/redis-huan-cun-xue-beng-chuan-tou-ji-chuan">《吊打面试官》系列-Redis缓存雪崩、穿透、击穿</a></li></ul><p>大家都知道一个技术的引入方便了开发，解决了各种问题，但是也会带来对应的问题，<strong>技术是把双刃剑</strong>嘛，集群的引入也会带来很多问题，如：集群的高可用怎么保证，数据怎么同步等等，我们话不多说，有请下一位受害者为我们展示。</p><h2 id="面试开始"><a href="#面试开始" class="headerlink" title="面试开始"></a>面试开始</h2><blockquote><p>三个大腹便便，穿着格子衬衣的中年男子，拿着三个满是划痕的 Mac 向你走来，看着快秃顶的头发，心想着肯定是尼玛顶级架构师吧！而且还是三个，但是我们腹有诗书气自华，根本虚都不虚好伐。</p></blockquote><p><img src="https://s1.ax1x.com/2020/04/24/JDwjkq.jpg" alt=""></p><h3 id="小伙子你好，之前问过了你基础知识以及一些缓存的常见几个大问题了，那你能跟我聊聊为啥-Redis-那么快么？"><a href="#小伙子你好，之前问过了你基础知识以及一些缓存的常见几个大问题了，那你能跟我聊聊为啥-Redis-那么快么？" class="headerlink" title="小伙子你好，之前问过了你基础知识以及一些缓存的常见几个大问题了，那你能跟我聊聊为啥 Redis 那么快么？"></a>小伙子你好，之前问过了你基础知识以及一些缓存的常见几个大问题了，那你能跟我聊聊为啥 Redis 那么快么？</h3><p>哦，帅气迷人的面试官您好，我们可以先看一下关系型数据库跟 Redis 本质上的区别。</p><p><img src="https://s1.ax1x.com/2020/04/24/JD0y40.jpg" alt=""></p><p><strong>Redis</strong> 采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由 C 语言编写，官方提供的数据是可以达到 100000+ 的 <strong>QPS（每秒内查询次数）</strong>。</p><ul><li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。它的，数据存在内存中，类似于 <strong>HashMap</strong> ，<strong>HashMap</strong> 的优势就是查找和操作的时间复杂度都是 O(1) ；</li><li>数据结构简单，对数据操作也简单，<strong>Redis</strong> 中的数据结构是专门进行设计的；</li><li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 <strong>CPU</strong>，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li><li>使用 <strong>I/O 多路复用</strong>模型，<strong>非阻塞</strong> IO ；</li><li>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，<strong>Redis</strong> 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li></ul><blockquote><p>Redis 线程模型：socket 套接字、I/O 多路复用程序、文件事件分派器（单线程）、事件处理器。</p></blockquote><h3 id="我可以问一下啥是上下文切换么？"><a href="#我可以问一下啥是上下文切换么？" class="headerlink" title="我可以问一下啥是上下文切换么？"></a>我可以问一下啥是上下文切换么？</h3><p>我可以打个比方么：我记得有过一个小伙伴微信问过我上下文切换是啥，为啥可能会线程不安全，我是这么说的，就好比你看一本英文书，你看到第十页发现有个单词不会读，你加了个书签，然后去查字典，过了一会你又回来继续从书签那里读，OK 到目前为止没啥问题。</p><p>如果是你一个人读肯定没啥问题，但是你去查的时候，别的小伙伴好奇你在看啥他就翻了一下你的书，然后溜了，哦豁，你再看的时候就发现书不是你看的那一页了。不知道到这里为止我有没有解释清楚，以及为啥会线程不安全，就是因为你一个人怎么看都没事，但是人多了换来换去的操作一本书数据就乱了。可能我的解释很粗糙，但是道理应该是一样的。</p><h3 id="那他是单线程的，我们现在服务器都是多核的，那不是很浪费？"><a href="#那他是单线程的，我们现在服务器都是多核的，那不是很浪费？" class="headerlink" title="那他是单线程的，我们现在服务器都是多核的，那不是很浪费？"></a>那他是单线程的，我们现在服务器都是多核的，那不是很浪费？</h3><p>是的他是单线程的，但是，我们可以在单机开多个 <strong>Redis实例</strong> 嘛。</p><h3 id="既然提到了单机会有瓶颈，那你们是怎么解决这个瓶颈的？"><a href="#既然提到了单机会有瓶颈，那你们是怎么解决这个瓶颈的？" class="headerlink" title="既然提到了单机会有瓶颈，那你们是怎么解决这个瓶颈的？"></a>既然提到了单机会有瓶颈，那你们是怎么解决这个瓶颈的？</h3><p>我们用到了集群的部署方式也就是 <strong>Redis Cluster</strong>，并且是主从同步读写分离，类似 <strong>Mysql</strong> 的主从同步，<strong>Redis Cluster</strong> 支撑 N 个 <strong>Redis Master Node</strong>，每个 <strong>Master Node</strong> 都可以挂载多个 <strong>Slave Node</strong> 。</p><p>这样整个 <strong>Redis</strong> 就可以横向扩容了。如果你要支撑更大数据量的缓存，那就横向扩容更多的 <strong>Master</strong> 节点，每个 <strong>Master</strong> 节点就能存放更多的数据了。</p><h3 id="哦？那问题就来了，他们之间是怎么进行数据交互的？以及-Redis-是怎么进行持久化的？Redis-数据都在内存中，一断电或者重启不就木有了嘛？"><a href="#哦？那问题就来了，他们之间是怎么进行数据交互的？以及-Redis-是怎么进行持久化的？Redis-数据都在内存中，一断电或者重启不就木有了嘛？" class="headerlink" title="哦？那问题就来了，他们之间是怎么进行数据交互的？以及 Redis 是怎么进行持久化的？Redis 数据都在内存中，一断电或者重启不就木有了嘛？"></a>哦？那问题就来了，他们之间是怎么进行数据交互的？以及 Redis 是怎么进行持久化的？Redis 数据都在内存中，一断电或者重启不就木有了嘛？</h3><p>是的，持久化的话是 <strong>Redis</strong> 高可用中比较重要的一个环节，因为 <strong>Redis</strong> 数据在内存的特性，持久化必须得有，我了解到的持久化是有两种方式的。</p><ul><li><code>RDB</code>：<strong>RDB</strong> 持久化机制，是对 <strong>Redis</strong> 中的数据执行<strong>周期性</strong>的持久化。</li><li><code>AOF</code>：<strong>AOF</strong> 机制对每条写入命令作为日志，以 <strong>append-only</strong> 的模式写入一个日志文件中，因为这个模式是只<strong>追加</strong>的方式，所以没有任何磁盘寻址的开销，所以很快，有点像 MySQL 中的 <strong><code>binlog</code></strong> 。</li></ul><p>两种方式都可以把 <strong>Redis</strong> 内存中的数据持久化到磁盘上，然后再将这些数据备份到别的地方去，<strong>RDB</strong> 更适合做<strong>冷备</strong>，<strong>AOF</strong> 更适合做<strong>热备</strong>，比如我杭州的某电商公司有这两个数据，我备份一份到我杭州的节点，再备份一个到上海的，就算发生无法避免的自然灾害，也不会两个地方都一起挂吧，这<strong>灾备</strong>也就是<strong>异地容灾</strong>，地球毁灭他没办法。</p><blockquote><p><strong>Tips：两种机制全部开启的时候，Redis 在重启的时候会默认使用 AOF 去重新构建数据，因为 AOF 的数据是比 RDB 更完整的。</strong></p></blockquote><h3 id="那这两种机制各自优缺点是啥？"><a href="#那这两种机制各自优缺点是啥？" class="headerlink" title="那这两种机制各自优缺点是啥？"></a>那这两种机制各自优缺点是啥？</h3><p>我先说 <strong>RDB</strong> 吧。</p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>他会生成多个数据文件，每个数据文件分别都代表了某一时刻 <strong>Redis</strong> 里面的数据，这种方式，有没有觉得很适合做<strong>冷备</strong>，完整的数据运维设置定时任务，定时同步到远端的服务器，比如阿里的云服务，这样一旦线上挂了，你想恢复多少分钟之前的数据，就去远端拷贝一份之前的数据就好了。</p><p><strong>RDB</strong> 对 <strong>Redis</strong> 的性能影响非常小，是因为在同步数据的时候他只是 <strong><code>fork</code></strong> 了一个子进程去做持久化的，而且他在数据恢复的时候速度比 <strong>AOF</strong> 来的快。</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p><strong>RDB</strong> 都是快照文件，都是默认五分钟甚至更久的时间才会生成一次，这意味着你这次同步到下次同步这中间五分钟的数据都很可能全部丢失掉。<strong>AOF</strong> 则最多丢一秒的数据，<strong>数据完整性</strong>上高下立判。</p><p>还有就是 <strong>RDB</strong> 在生成数据快照的时候，如果文件很大，客户端可能会暂停几毫秒甚至几秒，你公司在做秒杀的时候他刚好在这个时候 <strong>fork</strong> 了一个子进程去生成一个大快照，哦豁，出大问题。</p><p>我们再来说说 <strong>AOF</strong> 。</p><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><p>上面提到了，<strong>RDB</strong> 五分钟一次生成快照，但是 <strong>AOF</strong> 是一秒一次去通过一个后台的线程 <strong><code>fsync</code></strong> 操作，那最多丢这一秒的数据。</p><p><strong>AOF</strong> 在对日志文件进行操作的时候是以 <code>append-only</code> 的方式去写的，他只是追加的方式写数据，自然就少了很多磁盘寻址的开销了，写入性能惊人，文件也不容易破损。</p><p><strong>AOF</strong> 的日志是通过一个叫<strong>非常可读</strong>的方式记录的，这样的特性就适合做<strong>灾难性数据误删除</strong>的紧急恢复了，比如公司的实习生通过 <strong><code>flushall</code></strong> 清空了所有的数据，只要这个时候后台重写还没发生，你马上拷贝一份 <strong>AOF</strong> 日志文件，把最后一条 <strong><code>flushall</code></strong> 命令删了就完事了。</p><blockquote><p><strong>Tips：我说的命令你们别真去线上系统操作啊，想试去自己买的服务器上装个 Redis 试，别到时候把服务器搞崩了，Redis 官网上的命令都去看看，不要乱试！！！</strong></p></blockquote><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><p>一样的数据，<strong>AOF</strong> 文件比 <strong>RDB</strong> 还要大。</p><p><strong>AOF</strong> 开启后，<strong>Redis</strong> 支持写的 <strong>QPS</strong> 会比 <strong>RDB</strong> 支持写的要低，他不是每秒都要去异步刷新（ <strong><code>fsync</code></strong> ）一次日志嘛，当然即使这样性能还是很高，我记得 <strong>Elasticsearch</strong> 也是这样的，异步刷新缓存区的数据去持久化，为啥这么做呢，不直接来一条怼一条呢，那我会告诉你这样性能可能低到没办法用的，大家可以思考下为啥哟。</p><h3 id="那两者怎么选择？"><a href="#那两者怎么选择？" class="headerlink" title="那两者怎么选择？"></a>那两者怎么选择？</h3><p><img src="https://s1.ax1x.com/2020/04/24/JDrUgK.jpg" alt=""></p><p>小孩子才做选择，<strong>我全都要</strong>，你单独用 <strong>RDB</strong> 你会丢失很多数据，你单独用 <strong>AOF</strong> ，你数据恢复没 <strong>RDB</strong> 来的快，真出什么时候第一时间用 <strong>RDB</strong> 恢复，然后 <strong>AOF</strong> 做数据补全，真香！冷备热备一起上，才是互联网时代一个高健壮性系统的王道。</p><h3 id="看不出来年纪轻轻有点东西的呀，对了我听你提到了高可用，Redis-还有其他保证集群高可用的方式么？"><a href="#看不出来年纪轻轻有点东西的呀，对了我听你提到了高可用，Redis-还有其他保证集群高可用的方式么？" class="headerlink" title="看不出来年纪轻轻有点东西的呀，对了我听你提到了高可用，Redis 还有其他保证集群高可用的方式么？"></a>看不出来年纪轻轻有点东西的呀，对了我听你提到了高可用，Redis 还有其他保证集群高可用的方式么？</h3><p>！！！晕 自己给自己埋个坑（其实是明早就准备好了，故意抛出这个词等他问，就怕他不问）。</p><p>假装思考一会（<strong>不要太久，免得以为你真的不会</strong>），哦我想起来了，还有哨兵集群 <strong>Sentinel</strong> 。</p><p>哨兵必须用三个实例去保证自己的健壮性的，哨兵+主从并<strong>不能保证数据不丢失</strong>，但是可以保证集群的<strong>高可用</strong>。</p><p>为啥必须要三个实例呢？我们先看看两个哨兵会咋样。</p><p><img src="https://s1.ax1x.com/2020/04/24/JDry4I.jpg" alt="两个哨兵集群"></p><p>Master 宕机了 S1 和 S2 两个哨兵只要有一个认为你宕机了就切换了，并且会选举出一个哨兵去执行故障，但是这个时候也需要大多数哨兵都是运行的。</p><p>那这样有啥问题呢？M1 宕机了，S1 没挂那其实是 OK 的，但是整个机器都挂了呢？哨兵就只剩下 S2 个裸屌了，没有哨兵去允许故障转移了，虽然另外一个机器上还有 R1 ，但是故障转移就是不执行。</p><p>经典的哨兵集群是这样的：</p><p><img src="https://s1.ax1x.com/2020/04/24/JDsCP1.jpg" alt="经典的三哨兵集群"></p><p>M1 所在的机器挂了，哨兵还有两个，两个人一看他不是挂了嘛，那我们就选举一个出来执行故障转移不就好了。</p><p>暖男我，小的总结下哨兵组件的主要功能：</p><ul><li><p><strong>集群监控：</strong>负责监控 Redis Master 和 Slave 进程是否正常工作。</p></li><li><p><strong>消息通知：</strong>如果某个 <strong>Redis</strong> 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</p></li><li><p><strong>故障转移：</strong>如果 Master Node 挂掉了，会自动转移到 Slave Node 上。</p></li><li><p><strong>配置中心：</strong>如果故障转移发生了，通知 Client 客户端新的 Master 地址。</p></li></ul><h3 id="我记得你还提到了主从同步，能说一下主从之间的数据怎么同步的么？"><a href="#我记得你还提到了主从同步，能说一下主从之间的数据怎么同步的么？" class="headerlink" title="我记得你还提到了主从同步，能说一下主从之间的数据怎么同步的么？"></a>我记得你还提到了主从同步，能说一下主从之间的数据怎么同步的么？</h3><p>面试官您的记性可真是一级棒呢，我都要忘了你还记得，我特么谢谢你，提到这个，就跟我前面提到的数据持久化的 <strong>RDB</strong> 和 <strong>AOF</strong> 有着比密切的关系了。</p><p>我先说下为啥要用主从这样的架构模式，前面提到了单机 <strong>QPS</strong> 是有上限的，而且 <strong>Redis</strong> 的特性就是必须支撑读高并发的，那你一台机器又读又写，<strong>这谁顶得住啊</strong>，不当人啊！但是你让这个 Master 机器去写，数据同步给别的 Slave 机器，他们都拿去读，分发掉大量的请求那是不是好很多，而且扩容的时候还可以轻松实现水平扩容。</p><p><img src="https://s1.ax1x.com/2020/04/24/JDyKw4.jpg" alt="Redis 主从同步"></p><p><strong>回归正题，他们数据怎么同步的呢？</strong></p><p>你启动一台 Slave 的时候，他会发送一个 <strong><code>psync</code></strong> 命令给 Master ，如果是这个 Slave 第一次连接到 Master ，他会触发一个全量复制。Master 就会启动一个线程，生成 <strong>RDB</strong> 快照，还会把新的写请求都缓存在内存中，<strong>RDB</strong> 文件生成后，Master 会将这个 <strong>RDB</strong> 发送给 Slave 的，Slave 拿到之后做的第一件事情就是写进本地的磁盘，然后加载进内存，然后 Master 会把内存里面缓存的那些新命令都发给 Slave 。</p><h3 id="数据传输的时候断网了或者服务器挂了怎么办啊？"><a href="#数据传输的时候断网了或者服务器挂了怎么办啊？" class="headerlink" title="数据传输的时候断网了或者服务器挂了怎么办啊？"></a>数据传输的时候断网了或者服务器挂了怎么办啊？</h3><p>传输过程中有什么网络问题啥的，会自动重连的，并且连接之后会把缺少的数据补上的。</p><p><strong>大家需要记得的就是，RDB 快照的数据生成的时候，缓存区也必须同时开始接受新请求，不然你旧的数据过去了，你在同步期间的增量数据咋办？是吧？</strong></p><h3 id="那说了这么多你能说一下他的内存淘汰机制么，来手写一下-LRU-代码？"><a href="#那说了这么多你能说一下他的内存淘汰机制么，来手写一下-LRU-代码？" class="headerlink" title="那说了这么多你能说一下他的内存淘汰机制么，来手写一下 LRU 代码？"></a>那说了这么多你能说一下他的内存淘汰机制么，来手写一下 LRU 代码？</h3><p><img src="https://s1.ax1x.com/2020/04/24/JDyJl6.gif" alt=""></p><h4 id="手写LRU？你是不是想直接跳起来说一句：Are-U-F-k-Kidding-me-？"><a href="#手写LRU？你是不是想直接跳起来说一句：Are-U-F-k-Kidding-me-？" class="headerlink" title="手写LRU？你是不是想直接跳起来说一句：Are U F**k Kidding me ？"></a>手写LRU？你是不是想直接跳起来说一句：Are U F**k Kidding me ？</h4><p><strong>Redis</strong> 的过期策略，是有 <strong>定期删除+惰性删除</strong> 两种。</p><p>定期好理解，默认 <strong>100ms</strong> 就随机抽一些设置了过期时间的 Key ，去检查是否过期，过期了就删了。</p><h3 id="为啥不扫描全部设置了过期时间的-key-呢？"><a href="#为啥不扫描全部设置了过期时间的-key-呢？" class="headerlink" title="为啥不扫描全部设置了过期时间的 key 呢？"></a>为啥不扫描全部设置了过期时间的 key 呢？</h3><p>假如 Redis 里面所有的 key 都有过期时间，都扫描一遍？那太恐怖了，而且我们线上基本上也都是会设置一定的过期时间的。全扫描跟你去查数据库不带 where 条件不走索引全表扫描一样，100ms 一次，Redis 累都累死了。</p><h3 id="如果一直没随机到很多-key-，里面不就存在大量的无效-key-了？"><a href="#如果一直没随机到很多-key-，里面不就存在大量的无效-key-了？" class="headerlink" title="如果一直没随机到很多 key ，里面不就存在大量的无效 key 了？"></a>如果一直没随机到很多 key ，里面不就存在大量的无效 key 了？</h3><p>好问题，<strong>惰性删除</strong>，见名知意，惰性嘛，我不主动删，我懒，我等你来查询了我看看你过期没，过期就删了还不给你返回，没过期该怎么样就怎么样。</p><h3 id="最后就是如果的如果，定期没删，我也没查询，那可咋整？"><a href="#最后就是如果的如果，定期没删，我也没查询，那可咋整？" class="headerlink" title="最后就是如果的如果，定期没删，我也没查询，那可咋整？"></a>最后就是如果的如果，定期没删，我也没查询，那可咋整？</h3><p><strong>内存淘汰机制！</strong></p><p>官网上给到的内存淘汰机制是以下几个：</p><ul><li><strong>noeviction：</strong>当内存不足写入新数据时，写入操作会<strong>报错</strong>，同时不删除数据。</li><li><strong>allkeys-lru：</strong>当内存不足写入新数据时，淘汰<strong>最近最少使用（LRU）</strong>的数据。</li><li><strong>volatile-lru：</strong>当内存不足写入新数据时，从<strong>已设置过期时间</strong>的数据集中挑选最近最少使用（LRU）的数据淘汰。</li><li><strong>allkeys-random：</strong>当内存不足写入新数据时，<strong>随机</strong>选择 Key 淘汰。</li><li><strong>volatile-random：</strong>当内存不足写入新数据时，从已设置过期时间的数据集中挑选任意数据淘汰。</li><li><strong>allkeys-lfu：</strong>当内存不足写入新数据时，移除<strong>最不经常</strong>使用的 Key 。</li><li><strong>volatile-lfu：</strong>当内存不足写入新数据时，从已设置过期时间的数据集中挑选最不经常使用的数据淘汰。</li><li><strong>volatile-ttl：</strong>当内存不足写入新数据时，从已设置过期时间的数据集中挑选将要过期的数据淘汰，并且优先回收存活时间（TTL）较短的键，使得新添加的数据有空间存放。</li></ul><blockquote><p>如果没有键满足回收的前提条件的话，策略 <strong>volatile-lru</strong> 、<strong>volatile-random</strong> 以及 <strong>volatile-ttl</strong> 就和 <strong>noeviction</strong> 差不多了。</p></blockquote><p>至于 <strong>LRU</strong> 我也简单提一下，手写实在是太长了，大家可以去 <strong>Redis官网</strong> 看看，我把*<em>近似 LUR *</em>效果给大家看看。</p><blockquote><p><strong>Tips：Redis 为什么不使用真实的 LRU 实现是因为这需要太多的内存。不过近似的 LRU 算法对于应用而言应该是等价的。使用真实的 LRU 算法与近似的算法可以通过下面的图像对比。</strong></p></blockquote><p><img src="https://s1.ax1x.com/2020/04/24/JDc5Q0.jpg" alt="LRU 比较"></p><p>你可以看到三种点在图片中, 形成了三种带。</p><ul><li>浅灰色带是已经被回收的对象。</li><li>灰色带是没有被回收的对象。</li><li>绿色带是被添加的对象。</li><li>在 <strong>LRU</strong> 实现的理论中，我们希望的是，在旧键中的第一半将会过期。<strong>Redis</strong> 的 <strong>LRU</strong> 算法则是概率地过期旧的键。</li></ul><p>你可以看到，在都是五个采样的时候 Redis 3.0 比 Redis 2.8 要好，Redis 2.8 中在最后一次访问之间的大多数的对象依然保留着。使用 10 个采样大小的 Redis 3.0 的近似值已经非常接近理论的性能。</p><blockquote><p>注意：LRU 只是个预测键将如何被访问的模型。另外，如果你的数据访问模式非常接近幂定律，大部分的访问将集中在一个键的集合中，LRU 的近似算法将处理得很好。</p></blockquote><p>其实在大家熟悉的 <strong>LinkedHashMap</strong> 中也实现了 LRU 算法的，实现如下：</p><p><img src="https://s1.ax1x.com/2020/04/24/JDgVSI.jpg" alt="LRU 算法"></p><p>当容量超过 100 时，开始执行 <strong>LRU</strong> 策略：将最近最少未使用的 <strong>TimeoutInfoHolder</strong> 对象 <strong>evict</strong> 掉。</p><p>真实面试中会让你写 LUR 算法，你可别搞原始的那个，那真 TM 多，写不完的，你要么怼上面这个，要么怼下面这个，找一个数据结构实现下 Java 版本的 LRU 还是比较容易的，知道啥原理就好了。</p><p><img src="https://s1.ax1x.com/2020/04/24/JDgd7F.jpg" alt="LRU 算法"></p><h2 id="面试结束"><a href="#面试结束" class="headerlink" title="面试结束"></a>面试结束</h2><h3 id="小伙子，你确实有点东西，HRBP-会联系你的，请务必保持你的手机畅通好么？"><a href="#小伙子，你确实有点东西，HRBP-会联系你的，请务必保持你的手机畅通好么？" class="headerlink" title="小伙子，你确实有点东西，HRBP 会联系你的，请务必保持你的手机畅通好么？"></a>小伙子，你确实有点东西，HRBP 会联系你的，请务必保持你的手机畅通好么？</h3><p>好的谢谢面试官，面试官真好，我还想再面几次，噗此。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，我们玩归玩，闹归闹，别拿面试开玩笑，我这么写是为了节目效果，大家面试请认真对待。</p><p>以上就是这篇文章的全部内容了，能看到这里的人呀，都是<strong>人才</strong>，祝各位看官都能成为 offer 收割机^∨^。</p><p>给大家推荐几本经典的 Redis 入门的书籍和我参考的资料：</p><ul><li><p><a href="http://www.redis.cn/" target="_blank" rel="noopener">Redis中文官网</a></p></li><li><p>《Redis入门指南(第2版)》</p></li><li><p>《Redis实战》</p></li><li><p>《Redis设计与实现》</p></li><li><p>《<a href="https://github.com/doocs/technical-books#architecture" target="_blank" rel="noopener">大型网站技术架构</a>——李智慧》</p></li><li><p>《<a href="https://github.com/doocs/technical-books#database" target="_blank" rel="noopener">Redis 设计与实现</a>——黄健宏》</p></li><li><p>《<a href="https://github.com/doocs/technical-books#database" target="_blank" rel="noopener">Redis 深度历险</a>——钱文品》</p></li><li><p>《<a href="https://github.com/doocs/technical-books#architecture" target="_blank" rel="noopener">亿级流量网站架构核心技术</a>——张开涛》</p></li><li><p>《<a href="https://github.com/doocs/advanced-java" target="_blank" rel="noopener">中华石杉</a>——石杉》</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>布隆过滤器（Bloom Filter）</title>
      <link href="/2020/04/24/shu-ju-ku/bu-long-guo-lu-qi-bloomfilter/"/>
      <url>/2020/04/24/shu-ju-ku/bu-long-guo-lu-qi-bloomfilter/</url>
      
        <content type="html"><![CDATA[<h2 id="避免缓存穿透的利器之-Bloom-Filter"><a href="#避免缓存穿透的利器之-Bloom-Filter" class="headerlink" title="避免缓存穿透的利器之 Bloom Filter"></a>避免缓存穿透的利器之 Bloom Filter</h2><h3 id="Bloom-Filter-概念"><a href="#Bloom-Filter-概念" class="headerlink" title="Bloom Filter 概念"></a>Bloom Filter 概念</h3><p>布隆过滤器（英语：Bloom Filter）是 1970 年由一个叫布隆的小伙子提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><p><strong>面试关联：一般都会在回答缓存穿透，或者海量数据去重这个时候引出来，加分项哟。</strong></p><h3 id="Bloom-Filter-原理"><a href="#Bloom-Filter-原理" class="headerlink" title="Bloom Filter 原理"></a>Bloom Filter 原理</h3><p>布隆过滤器的原理是，当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点，把它们置为 <strong>1</strong> 。检索时，我们只要看看这些点是不是都是 <strong>1</strong> 就（大约）知道集合中有没有它了：如果这些点有任何一个 <strong>0</strong> ，则被检元素<strong>一定不在</strong>；如果都是 <strong>1</strong> ，则被检元素<strong>很可能在</strong>。这就是布隆过滤器的基本思想。</p><p>Bloom Filter 跟单哈希函数 Bit-Map 不同之处在于：Bloom Filter 使用了 k 个哈希函数，每个字符串跟 k 个 bit 对应。从而降低了冲突的概率。</p><p> <img src="https://s1.ax1x.com/2020/04/24/JD9CLV.jpg" alt="Bloom Filter"></p><p>简单的说一下就是我们先把我们数据库的数据都加载到我们的过滤器中，比如数据库的id现在有：1、2、3。</p><p>那就用id：1 为例子他在上图中经过三次 hash 之后，把三次原本值 0 的地方改为 1 。</p><p>下次我进来查询如果 id 也是 1 那我就把 1 拿去三次 hash 发现跟上面的三个位置完全一样，那就能证明过滤器中有 1 的。</p><p>反之如果不一样就说明不存在了。</p><p>那应用的场景在哪里呢？一般我们都会用来防止缓存穿透。</p><p><img src="https://s1.ax1x.com/2020/04/24/JBLHSK.png" alt="缓存穿透"></p><p>简单来说就是你数据库的 id 都是 1 开始然后自增的，那我知道你接口是通过 id 查询的，我就拿负数去查询，这个时候，会发现缓存里面没这个数据，我又去数据库查也没有，一个请求这样，100 个，1000 个，10000 个呢？你的 DB 基本上就扛不住了，如果在缓存里面加上这个，是不是就不存在了，你判断没这个数据就不去查了，直接 return 一个数据为空不就好了嘛。</p><p>这玩意这么好使那有啥缺点么？有的，我们接着往下看。</p><h3 id="Bloom-Filter-的缺点"><a href="#Bloom-Filter-的缺点" class="headerlink" title="Bloom Filter 的缺点"></a>Bloom Filter 的缺点</h3><p>Bloom Filter之所以能做到在时间和空间上的效率比较高，是因为牺牲了判断的准确率、删除的便利性。</p><ul><li><p><strong>存在误判。</strong>可能要查到的元素并没有在容器中，但是 hash 之后得到的 k 个位置上值都是 1 。如果 Bloom Filter 中存储的是黑名单，那么可以通过建立一个白名单来存储可能会误判的元素。</p></li><li><p><strong>删除困难。</strong>一个放入容器的元素映射到 Bit 数组的 k 个位置上是 1 ，删除的时候不能简单的直接置为 0 ，可能会影响其他元素的判断。可以采用 <a href="http://wiki.corp.qunar.com/confluence/download/attachments/199003276/US9740797.pdf?version=1&modificationDate=1526538500000&api=v2" target="_blank" rel="noopener">Counting Bloom Filter</a> 。</p></li></ul><h3 id="Bloom-Filter-实现"><a href="#Bloom-Filter-实现" class="headerlink" title="Bloom Filter 实现"></a>Bloom Filter 实现</h3><p>布隆过滤器有许多实现与优化，Guava 中就提供了一种 Bloom Filter 的实现。</p><p>在使用 Bloom Filter 时，绕不过的两点是预估数据量 n 以及期望的误判率 fpp 。</p><p>在实现 Bloom Filter 时，绕不过的两点就是 hash 函数的选取以及 bit 数组的大小。</p><p>对于一个确定的场景，我们预估要存的数据量为 n ，期望的误判率为 fpp ，然后需要计算我们需要的 Bit 数组的大小 m ，以及 hash 函数的个数 k ，并选择 hash 函数。</p><h4 id="1-Bit-数组大小选择"><a href="#1-Bit-数组大小选择" class="headerlink" title="(1) Bit 数组大小选择"></a>(1) Bit 数组大小选择</h4><p>根据预估数据量 n 以及误判率 fpp ，Bit 数组大小的 m 的计算方式：</p><p><img src="https://s1.ax1x.com/2020/04/24/JDCFXt.png" alt="Bit 数组大小"></p><h4 id="2-哈希函数选择"><a href="#2-哈希函数选择" class="headerlink" title="(2) 哈希函数选择"></a>(2) 哈希函数选择</h4><p>由预估数据量 n 以及 Bit 数组长度 m ，可以得到一个 hash 函数的个数 k ：</p><p><img src="https://s1.ax1x.com/2020/04/24/JDC5ut.png" alt="哈希函数"></p><p>哈希函数的选择对性能的影响应该是很大的，一个好的哈希函数要能近似等概率的将字符串映射到各个 Bit 。选择 k 个不同的哈希函数比较麻烦，一种简单的方法是选择一个哈希函数，然后送入 k 个不同的参数。</p><p>哈希函数个数 k 、Bit 数组大小 m 、加入的字符串数量 n 的关系可以参考：</p><p><a href="http://pages.cs.wisc.edu/~cao/papers/summary-cache/node8.html" target="_blank" rel="noopener">Bloom Filters - the math</a> 、<a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="noopener">Bloom_Filter - wikipedia</a></p><p>要使用 Bloom Filter，需要引入 Guava 包：</p><pre class=" language-java"><code class="language-java"> <span class="token operator">&lt;</span>dependency<span class="token operator">></span>     <span class="token operator">&lt;</span>groupId<span class="token operator">></span>com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>guava<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>     <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>guava<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>     <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">28.1</span><span class="token operator">-</span>jre<span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span> <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>    </code></pre><p>测试分两步：</p><p>1、往过滤器中放一百万个数，然后去验证这一百万个数是否能通过过滤器；</p><p>2、另外找一万个数，去检验漏网之鱼的数量。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 测试布隆过滤器(可用于Redis缓存穿透) */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestBloomFilter</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> total <span class="token operator">=</span> <span class="token number">1000000</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> BloomFilter<span class="token operator">&lt;</span>Integer<span class="token operator">></span> bf <span class="token operator">=</span> BloomFilter<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Funnels<span class="token punctuation">.</span><span class="token function">integerFunnel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> total<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//    private static BloomFilter&lt;Integer> bf = BloomFilter.create(Funnels.integerFunnel(), total, 0.001);</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 初始化1000000条数据到过滤器中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> total<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            bf<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 匹配已在过滤器中的值，是否有匹配不上的</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> total<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bf<span class="token punctuation">.</span><span class="token function">mightContain</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"有坏人逃脱了~~~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 匹配不在过滤器中的10000个值，有多少匹配出来</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> total<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> total <span class="token operator">+</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bf<span class="token punctuation">.</span><span class="token function">mightContain</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"误伤的数量："</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行结果：</p><pre class=" language-java"><code class="language-java">误伤的数量：<span class="token number">320</span></code></pre><p>运行结果表示，遍历这一百万个在过滤器中的数时，都被识别出来了。一万个不在过滤器中的数，误伤了 320 个，错误率是 0.03 左右。</p><p>看下 Bloom Filter 的源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> BloomFilter<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">create</span><span class="token punctuation">(</span>Funnel<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">></span> funnel<span class="token punctuation">,</span> <span class="token keyword">int</span> expectedInsertions<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">create</span><span class="token punctuation">(</span>funnel<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> expectedInsertions<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> BloomFilter<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">create</span><span class="token punctuation">(</span>Funnel<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">></span> funnel<span class="token punctuation">,</span> <span class="token keyword">long</span> expectedInsertions<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">create</span><span class="token punctuation">(</span>funnel<span class="token punctuation">,</span> expectedInsertions<span class="token punctuation">,</span> <span class="token number">0.03</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// FYI, for 3%, we always get 5 hash functions</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> BloomFilter<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">create</span><span class="token punctuation">(</span>          Funnel<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">></span> funnel<span class="token punctuation">,</span> <span class="token keyword">long</span> expectedInsertions<span class="token punctuation">,</span> <span class="token keyword">double</span> fpp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">create</span><span class="token punctuation">(</span>funnel<span class="token punctuation">,</span> expectedInsertions<span class="token punctuation">,</span> fpp<span class="token punctuation">,</span> BloomFilterStrategies<span class="token punctuation">.</span>MURMUR128_MITZ_64<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> BloomFilter<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">create</span><span class="token punctuation">(</span>      Funnel<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">></span> funnel<span class="token punctuation">,</span> <span class="token keyword">long</span> expectedInsertions<span class="token punctuation">,</span> <span class="token keyword">double</span> fpp<span class="token punctuation">,</span> Strategy strategy<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span></code></pre><p>Bloom Filter 一共四个 <code>create()</code> 方法，不过最终都是走向第四个。看一下每个参数的含义：</p><p><strong>funnel：</strong>数据类型（一般是调用 Funnels 工具类中的）</p><p><strong>expectedInsertions：</strong>期望插入的值的个数</p><p><strong>fpp：</strong>错误率（默认值为 0.03 ）</p><p><strong>strategy：</strong>哈希算法（我也不懂啥意思）</p><h3 id="Bloom-Filter-的应用"><a href="#Bloom-Filter-的应用" class="headerlink" title="Bloom Filter 的应用"></a>Bloom Filter 的应用</h3><p>在最后一个 <code>create()</code> 方法中，设置一个断点：</p><p><img src="https://s1.ax1x.com/2020/04/24/JDkJM9.png" alt="create()"></p><p>上面的 <strong><code>numBits</code></strong> ，表示存一百万个 int 类型数字，需要的位数为 7298440 ，700 多万位。理论上存一百万个数，一个 int 是 4 字节 32 位，需要 4<em>8</em>1000000 = 3200 万位。如果使用 HashMap 去存，按 HashMap 50% 的存储效率，需要 6400 万位。可以看出 Bloom Filter 的存储空间很小，只有 HashMap 的 1/10 左右。</p><p>上面的 <strong><code>numHashFunctions</code></strong> ，表示需要 5 个函数去存这些数字。</p><p>使用第三个 <code>create()</code> 方法，我们设置下错误率：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> BloomFilter<span class="token operator">&lt;</span>Integer<span class="token operator">></span> bf <span class="token operator">=</span> BloomFilter<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Funnels<span class="token punctuation">.</span><span class="token function">integerFunnel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token number">0.0003</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>再运行看看：</p><pre class=" language-java"><code class="language-java">误伤的数量：<span class="token number">4</span></code></pre><p>此时误伤的数量为 4 ，错误率为 0.04% 左右。</p><p><img src="https://s1.ax1x.com/2020/04/24/JDAaOs.png" alt=""></p><p>当错误率设为 0.0003 时，所需要的位数为 16883499 ，1600 万位，需要 12 个函数。</p><p>和上面对比可以看出，错误率越大，所需空间和时间越小，错误率越小，所需空间和时间约大 。</p><p>常见的几个应用场景：</p><ul><li><p><strong>Cerberus</strong> 在收集监控数据的时候，有的系统的监控项量会很大，需要检查一个监控项的名字是否已经被记录到 DB 过了, 如果没有的话就需要写入 DB 。</p></li><li><p><strong>爬虫过滤。</strong>已抓到的 URL 就不再抓，可用 Bloom Filter 过滤。</p></li><li><p><strong>垃圾邮件过滤。</strong>如果用哈希表，每存储一亿个 Email 地址，就需要 1.6GB 的内存（用哈希表实现的具体办法是将每一个 Email 地址对应成一个八字节的信息指纹，然后将这些信息指纹存入哈希表，由于哈希表的存储效率一般只有 50% ，因此一个 Email 地址需要占用十六个字节。一亿个地址大约要 1.6GB ，即十六亿字节的内存）。因此存贮几十亿个邮件地址可能需要上百 GB 的内存。而 Bloom Filter 只需要哈希表 1/8 到 1/4 的大小就能解决同样的问题。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>好了，以上就是这篇文章的全部内容了，能看到这里的人呀，都是<strong>人才</strong>，祝各位看官都能成为 offer 收割机^∨^。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis缓存雪崩、穿透、击穿</title>
      <link href="/2020/04/24/shu-ju-ku/redis-huan-cun-xue-beng-chuan-tou-ji-chuan/"/>
      <url>/2020/04/24/shu-ju-ku/redis-huan-cun-xue-beng-chuan-tou-ji-chuan/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-缓存雪崩、穿透、击穿"><a href="#Redis-缓存雪崩、穿透、击穿" class="headerlink" title="Redis 缓存雪崩、穿透、击穿"></a>Redis 缓存雪崩、穿透、击穿</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>Redis</strong> 在互联网技术存储方面使用如此广泛，几乎所有的后端技术面试官都要在 <strong>Redis</strong> 的使用和原理方面对小伙伴们进行 360° 的刁难。作为一个在互联网公司面一次拿一次 offer 的面霸（<strong>请允许我使用一下夸张的修辞手法</strong>），打败了无数竞争对手，每次都只能看到无数落寞的身影失望的离开，略感愧疚，在一个寂寞难耐的夜晚，我痛定思痛，决定开始写<strong>《吊打面试官》</strong>系列，希望能帮助各位读者以后面试势如破竹，对面试官进行 360° 的反击，吊打问你的面试官，让一同面试的同僚瞠目结舌，疯狂收割大厂 offer ！</p><h2 id="一点感慨"><a href="#一点感慨" class="headerlink" title="一点感慨"></a>一点感慨</h2><p>本来都把稿子放到公众号保存了，洗澡的时候想了一下晚上的比赛，觉得还是打开电脑写点东西，跟文章内容没关系，只是一点个人的感慨，不知道多少小伙伴看了 <strong>SKT VS G2</strong> 的比赛，又不知道多少小伙伴还记得 <strong>Faker</strong> 手抖的那一幕。</p><p> <img src="https://s1.ax1x.com/2020/04/24/JBSLJs.gif" alt=""></p><p>不知道你们看了是什么感受，我看到他手抖的时候我内心也抖了，世界赛我支持的都是 <strong>LPL</strong> 的队伍，但是我喜欢李哥这个人，那种对胜利的执著，这么多年了那种坚持自己的坚持，这么多利益诱惑在面前却只想要胜利，这样的人我好喜欢啊，我想很多人也喜欢。</p><p>可能就像很多网友说的那样，英雄迟暮，但是我觉得他还是有点东西，就像很多人说我们程序员只能吃年轻饭一样，但是如果你坚持自己的坚持，做个腹有诗书气自华的仔，我想最后肯定会得到自己的得到。</p><p>好了我也不煽情了，我们开始讲技术吧。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>上一期吊打系列我们提到了 Redis 的基础知识，还没看的小伙伴可以回顾一下！</p><ul><li><a href="https://www.niewenjun.com/2020/04/22/shu-ju-ku/redis-ji-chu">《吊打面试官》系列-Redis基础</a></li></ul><p>那提到 <strong>Redis</strong> 我相信各位在面试，或者实际开发过程中对缓存<strong>雪崩</strong>，<strong>穿透</strong>，<strong>击穿</strong>也不陌生吧，就算没遇到过但是你肯定听过，那三者到底有什么区别，我们又应该怎么去防止这样的情况发生呢，我们有请下一位受害者。</p><h2 id="面试开始"><a href="#面试开始" class="headerlink" title="面试开始"></a>面试开始</h2><blockquote><p>一个大腹便便，穿着格子衬衣的中年男子，拿着一个满是划痕的 Mac 向你走来，看着快秃顶的头发，心想着肯定是尼玛顶级架构师吧！但是我们腹有诗书气自华，虚都不虚。</p></blockquote><p> <img src="https://s1.ax1x.com/2020/04/24/JBifDx.jpg" alt=""></p><h3 id="小伙子我看你的简历上写到了-Redis-，那么我们直接开门见山，直接怼常见的几个大问题，Redis-雪崩了解么？"><a href="#小伙子我看你的简历上写到了-Redis-，那么我们直接开门见山，直接怼常见的几个大问题，Redis-雪崩了解么？" class="headerlink" title="小伙子我看你的简历上写到了 Redis ，那么我们直接开门见山，直接怼常见的几个大问题，Redis 雪崩了解么？"></a>小伙子我看你的简历上写到了 Redis ，那么我们直接开门见山，直接怼常见的几个大问题，Redis 雪崩了解么？</h3><p>帅气迷人的面试官您好，我了解的，目前电商首页以及热点数据都会去做缓存 ，一般缓存都是定时任务去刷新，或者是查不到之后去更新的，定时任务刷新就有一个问题。</p><p><strong>举个简单的例子：</strong>如果所有首页的 Key 失效时间都是 12 小时，中午 12 点刷新的，我零点有个秒杀活动大量用户涌入，假设当时每秒 6000 个请求，本来缓存在可以扛住每秒 5000 个请求，但是缓存当时所有的 Key 都失效了。此时 1 秒 6000 个请求全部落数据库，数据库必然扛不住，它会报一下警，真实情况可能 DBA 都没反应过来就直接挂了。此时，如果没用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。这就是我理解的缓存雪崩。</p><p><strong>我刻意看了下我做过的项目感觉再吊的都不允许这么大的 QPS 直接打 DB 去，不过没慢 SQL 加上分库，大表分表可能还还算能顶，但是跟用了 Redis 的差距还是很大。</strong></p><p> <img src="https://s1.ax1x.com/2020/04/24/JBEixH.png" alt="缓存雪崩"></p><p><strong>同一时间大面积失效，那一瞬间 Redis 跟没有一样，那这个数量级别的请求直接打到数据库几乎是灾难性的，你想想如果打挂的是一个用户服务的库，那其他依赖他的库所有的接口几乎都会报错，如果没做熔断等策略基本上就是瞬间挂一片的节奏，你怎么重启用户都会把你打挂，等你能重启的时候，用户早就睡觉去了，并且对你的产品失去了信心，什么垃圾产品。</strong></p><h3 id="面试官摸了摸自己的头发，嗯还不错，那这种情况咋整？你都是怎么去应对的？"><a href="#面试官摸了摸自己的头发，嗯还不错，那这种情况咋整？你都是怎么去应对的？" class="headerlink" title="面试官摸了摸自己的头发，嗯还不错，那这种情况咋整？你都是怎么去应对的？"></a>面试官摸了摸自己的头发，嗯还不错，那这种情况咋整？你都是怎么去应对的？</h3><p>处理缓存雪崩简单，在批量往 <strong>Redis</strong> 存数据的时候，把每个 Key 的失效时间都加个随机值就好了，这样可以保证数据不会在同一时间大面积失效，我相信，Redis 这点流量还是顶得住的。</p><pre class=" language-java"><code class="language-java"> <span class="token function">setRedis</span><span class="token punctuation">(</span>Key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> time <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10000</span><span class="token punctuation">)</span>；</code></pre><p>如果 <strong>Redis</strong> 是集群部署，将热点数据均匀分布在不同的 <strong>Redis</strong> 库中也能避免全部失效的问题，不过本渣我在生产环境中操作集群的时候，单个服务都是对应的单个 <strong>Redis</strong> 分片，是为了方便数据的管理，但是也同样有了可能会失效这样的弊端，失效时间随机是个好策略。</p><p>或者设置热点数据永远不过期，有更新操作就更新缓存就好了（比如运维更新了首页商品，那你刷下缓存就完事了，不要设置过期时间），电商首页的数据也可以用这个操作，保险。</p><h3 id="那你了解缓存穿透和击穿么，可以说说他们跟雪崩的区别么？"><a href="#那你了解缓存穿透和击穿么，可以说说他们跟雪崩的区别么？" class="headerlink" title="那你了解缓存穿透和击穿么，可以说说他们跟雪崩的区别么？"></a>那你了解缓存穿透和击穿么，可以说说他们跟雪崩的区别么？</h3><p>嗯，了解，我先说一下缓存穿透吧，缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，我们数据库的 id 都是 1 开始自增上去的，如发起为id值为 <strong>-1</strong> 的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大，严重会击垮数据库。</p><p> <img src="https://s1.ax1x.com/2020/04/24/JBLHSK.png" alt="缓存穿透"></p><p><strong>像这种你如果不对参数做校验，数据库 id 都是大于 0 的，我一直用小于 0 的参数去请求你，每次都能绕开 Redis 直接打到数据库，数据库也查不到，每次都这样，并发高点就容易崩掉了。</strong></p><p>至于<strong>缓存击穿</strong>嘛，这个跟<strong>缓存雪崩</strong>有点像，但是又有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了 DB ，而缓存击穿不同的是<strong>缓存击穿</strong>是指一个 Key 非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个 Key 在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个完好无损的桶上凿开了一个洞。</p><p><img src="https://s1.ax1x.com/2020/04/24/JBOAmQ.jpg" alt="缓存击穿"></p><h3 id="面试官露出欣慰的眼光，那他们分别怎么解决？"><a href="#面试官露出欣慰的眼光，那他们分别怎么解决？" class="headerlink" title="面试官露出欣慰的眼光，那他们分别怎么解决？"></a>面试官露出欣慰的眼光，那他们分别怎么解决？</h3><p><strong>缓存穿透</strong>我会在<strong>接口层增加校验</strong>，比如用户鉴权校验，参数做校验，不合法的参数直接代码 Return ，比如：id 做基础校验，id &lt;= 0 的直接拦截等。</p><p><strong>这里我想提的一点就是，我们在开发程序的时候都要有一颗“不信任”的心，就是不要相信任何调用方，比如你提供了 API 接口出去，你有这几个参数，那我觉得作为被调用方，任何可能的参数情况都应该被考虑到，做校验，因为你不相信调用你的人，你不知道他会传什么参数给你。</strong></p><p><strong>举个简单的例子，你这个接口是分页查询的，但是你没对分页参数的大小做限制，调用的人万一一口气查 <code>Integer.MAX_VALUE</code> ，一次请求就要你几秒，多几个并发你不就挂了么？是公司同事调用还好大不了发现了改掉，但是如果是黑客或者竞争对手呢？在你双十一当天就调你这个接口会发生什么，就不用我说了吧。</strong></p><p>从缓存取不到的数据，在数据库中也没有取到，这时也可以将对应 Key 的 Value 对写为 null 、位置错误、稍后重试这样的值具体取啥问产品，或者看具体的场景，缓存有效时间可以设置短点，如 30 秒（设置太长会导致正常情况也没法使用）。</p><p>这样可以防止攻击用户反复用同一个 id 暴力攻击，但是我们要知道正常用户是不会在单秒内发起这么多次请求的，那网关层 <strong><code>Nginx</code></strong> 本渣我也记得有配置项，可以让运维大大对单个 IP 每秒访问次数超出阈值的 IP 都拉黑。</p><h3 id="那你还有别的办法么？"><a href="#那你还有别的办法么？" class="headerlink" title="那你还有别的办法么？"></a>那你还有别的办法么？</h3><p>还有我记得 <strong>Redis</strong> 还有一个高级用法<strong>布隆过滤器（Bloom Filter）</strong>这个也能很好的防止缓存穿透的发生，他的原理也很简单就是利用高效的数据结构和算法快速判断出你这个 Key 是否在数据库中存在，不存在你 return 就好了，存在你就去查了 DB 刷新 KV 再 return 。</p><blockquote><p>传送门：<a href="https://www.niewenjun.com/2020/04/24/shu-ju-ku/bu-long-guo-lu-qi-bloomfilter">避免缓存穿透的利器之Bloom Filter</a></p></blockquote><p>那又有小伙伴说了如果黑客有很多个 IP 同时发起攻击呢？这点我一直也不是很想得通，但是一般级别的黑客没这么多肉鸡，再者正常级别的 <strong>Redis</strong> 集群都能抗住这种级别的访问的，小公司我想他们不会感兴趣的。把系统的高可用做好了，集群还是很能顶的。</p><p><strong>缓存击穿</strong>的话，设置热点数据永远不过期。或者加上互斥锁就能搞定了。</p><p><strong>作为暖男，代码我肯定帮你们准备好了。</strong><br> <img src="https://s1.ax1x.com/2020/04/24/JBvd10.png" alt="代码示例"></p><h2 id="面试结束"><a href="#面试结束" class="headerlink" title="面试结束"></a>面试结束</h2><p><strong>嗯嗯还不错，三个点都回答得很好，今天也不早了，面试就先到这里，明天你再过来二面我继续问一下你关于 Redis 集群高可用，主从同步，哨兵等知识点的问题。</strong></p><p>晕居然还有下一轮面试！（强行下一期的伏笔哈哈）但是为了 offer 还是得舔，嗯嗯，好的帅气面试官。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们玩归玩，闹归闹，别拿面试开玩笑。</p><p>本文简单的介绍了，<strong>Redis</strong> 的<strong>雪崩</strong>、<strong>击穿</strong>、<strong>穿透</strong>，三者其实都差不多，但是又有一些区别，在面试中其实这是问到缓存必问的，大家不要把三者搞混了，因为缓存雪崩、穿透和击穿，是缓存最大的问题，要么不出现，一旦出现就是致命性的问题，所以面试官一定会问你。</p><p>大家一定要理解是<strong>怎么发生的</strong>，以及是怎么去<strong>避免</strong>的，发生之后又怎么去<strong>抢救</strong>，你可以不是知道很深入，但是你不能一点都不去想，面试有时候不一定是对知识面的拷问，或许是对你的态度的拷问，如果你思路清晰，然后<strong>知其然还知其所以然</strong>那就很赞，还知道怎么预防那来上班吧。</p><h3 id="最后暖男我继续给你们做个小的技术总结："><a href="#最后暖男我继续给你们做个小的技术总结：" class="headerlink" title="最后暖男我继续给你们做个小的技术总结："></a>最后暖男我继续给你们做个小的技术总结：</h3><p>一般避免以上情况发生我们从三个时间段去分析下：</p><ul><li>事前：<strong>Redis</strong> 高可用，主从+哨兵，<strong>Redis Cluster</strong>，避免全盘崩溃。</li><li>事中：本地 <strong>ehcache</strong> 缓存 + <strong>Hystrix</strong> 限流+降级，避免 <strong>MySQL</strong> 被打死。</li><li>事后：<strong>Redis</strong> 持久化 <strong>RDB</strong>+<strong>AOF</strong> ，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</li></ul><p>限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？<strong>走降级</strong>！可以返回一些默认的值，或者友情提示，或者空白的值。</p><p><strong>好处：</strong></p><p>数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。 只要数据库不死，就是说，对用户来说，3/5 的请求都是可以被处理的。 只要有 3/5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来一次。</p><p><strong>这个在目前主流的互联网大厂里面是最常见的，你是不是好奇，某明星爆出什么事情，你发现你去微博怎么刷都空白界面，但是有的人又直接进了，你多刷几次也出来了，现在知道了吧，那是做了降级，牺牲部分用户的体验换来服务器的安全，可还行？</strong></p><p>好了，以上就是这篇文章的全部内容了，能看到这里的人呀，都是<strong>人才</strong>，祝各位看官都能成为 offer 收割机^∨^。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据结构底层原理</title>
      <link href="/2020/04/23/shu-ju-ku/redis-shu-ju-jie-gou-di-ceng-yuan-li/"/>
      <url>/2020/04/23/shu-ju-ku/redis-shu-ju-jie-gou-di-ceng-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis-数据结构底层原理"><a href="#Redis-数据结构底层原理" class="headerlink" title="Redis 数据结构底层原理"></a>Redis 数据结构底层原理</h2><h3 id="简单动态字符串（SDS）"><a href="#简单动态字符串（SDS）" class="headerlink" title="简单动态字符串（SDS）"></a>简单动态字符串（SDS）</h3><p><strong>Redis</strong> 是用 C 语言写的，但是 C 语言处理字符串和数组的成本是很高的，下面我分别说几个例子。</p><ul><li>极其容易造成缓冲区溢出问题。比如用 <code>strcat()</code> ，在用这个函数之前必须要先给目标变量分配足够的空间，否则就会溢出。</li><li>如果要获取字符串的长度，没有数据结构的支撑，可能就需要遍历，它的复杂度是 O(N) 。</li><li>内存重分配。C 字符串的每次变更（增长或缩短）都会对数组做内存重分配。同样，如果是缩短，没有处理好多余的空间，也会造成内存泄漏。</li></ul><p>好了，Redis 自己构建了一种名叫 <code>Simple dynamic string(SDS)</code> 的数据结构，它分别对这几个问题做了处理。</p><p><img src="https://s1.ax1x.com/2020/04/23/JdL10I.png" alt="SDS"></p><p>SDS 定义：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> sdshdr <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//记录 buf 数组中已使用字节的数量</span>     <span class="token comment" spellcheck="true">//等于 SDS 保存字符串的长度</span>     <span class="token keyword">int</span> len<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//记录 buf 数组中未使用字节的数量</span>     <span class="token keyword">int</span> free<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//字节数组，用于保存字符串</span>     <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>我们看上面对于 SDS 数据类型的定义：</p><ul><li><code>len</code> 保存了 SDS 保存字符串的长度。</li><li><code>buf[]</code> 数组用来保存字符串的每个元素。</li><li><code>free</code> 记录了 buf 数组中未使用的字节数量。</li></ul><p>上面的定义相对于 C 语言对于字符串的定义，多出了 <strong>len</strong> 属性以及 <strong>free</strong> 属性。为什么不使用 C 语言字符串实现，而是使用 SDS 呢？这样实现有什么好处？</p><ul><li><strong>常数复杂度获取字符串长度：</strong>由于 <code>len</code> 属性的存在，我们获取 <strong>SDS</strong> 字符串的长度只需要读取 <code>len</code> 属性，时间复杂度为 O(1) 。而对于 C 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n) 。</li><li><strong>杜绝缓冲区溢出：</strong>我们知道在 C 语言中使用 <code>strcat</code> 函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而对于 <strong>SDS</strong> 数据类型，在进行字符修改的时候，会首先根据记录的 <code>len</code> 属性检查内存空间是否满足需求，如果不满足，会进行相应的空间扩展，然后再进行修改操作，所以不会出现缓冲区溢出。</li><li><strong>减少修改字符串的内存重新分配次数：</strong>C 语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。而对于 <strong>SDS</strong> ，由于 <code>len</code> 属性和 <code>free</code> 属性的存在，对于修改字符串 <strong>SDS</strong> 实现了空间预分配和惰性空间释放两种策略：<ul><li><strong>空间预分配：</strong>对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。</li><li><strong>惰性空间释放：</strong>对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 <code>free</code> 属性将这些字节的数量记录下来，等待后续使用。</li></ul></li><li><strong>二进制安全：</strong>因为 C 字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此 C 字符串无法正确存取；而所有 <strong>SDS</strong> 的 API 都是以处理二进制的方式来处理 <code>buf</code> 里面的元素，并且 <strong>SDS</strong> 不是以空字符串来判断是否结束，而是以 <code>len</code> 属性表示的长度来判断字符串是否结束。</li><li><strong>兼容部分 C 字符串函数：</strong>虽然 <strong>SDS</strong> 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库 <code>&lt;string.h&gt;</code> 中的一部分函数。</li></ul><p><img src="https://s1.ax1x.com/2020/04/23/JdOTqs.png" alt="总结"></p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是一种常用的数据结构，C 语言内部是没有内置这种数据结构的实现，所以 Redis 自己构建了链表的实现。Redis 的链表在双向链表上扩展了头、尾节点、元素数等属性。</p><p><img src="https://s1.ax1x.com/2020/04/23/JwKnXQ.png" alt="链表"></p><p>ListNode 节点数据结构：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span>  <span class="token keyword">struct</span> listNode <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//前置节点</span>       <span class="token keyword">struct</span> listNode <span class="token operator">*</span>prev<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//后置节点</span>       <span class="token keyword">struct</span> listNode <span class="token operator">*</span>next<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//节点的值</span>       <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">;</span>  <span class="token punctuation">}</span> listNode<span class="token punctuation">;</span></code></pre><p>链表数据结构：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> list <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//表头节点</span>     listNode <span class="token operator">*</span>head<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//表尾节点</span>     listNode <span class="token operator">*</span>tail<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//链表所包含的节点数量</span>     <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//节点值复制函数</span>     <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>free<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//节点值释放函数</span>     <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>free<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//节点值对比函数</span>     <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>match<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> list<span class="token punctuation">;</span></code></pre><p>从上面可以看到，Redis 的链表有这几个特点：</p><ul><li>双端：链表具有前置节点和后置节点的引用，获取这两个节点时间复杂度都为 O(1) 。</li><li>无环：表头节点的 <strong>prev</strong> 指针和表尾节点的 <strong>next</strong> 指针都指向 NULL ，对链表的访问都是以 NULL 结束。</li><li>带链表长度计数器：通过 <strong>len</strong> 属性获取链表长度的时间复杂度为 O(1) 。</li><li>多态：链表节点使用 <strong>void*</strong> 指针来保存节点值，可以保存各种不同类型的值。</li></ul><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>Redis 的字典使用哈希表作为底层实现，Redis 的 Hash ，就是在 <strong><code>数组+链表</code></strong> 的基础上，进行了一些 <strong>rehash</strong> 优化等。</p><p><img src="https://s1.ax1x.com/2020/04/23/JwSgaj.png" alt="字典"></p><p>哈希表：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> dictht <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 哈希表数组</span>    dictEntry <span class="token operator">*</span><span class="token operator">*</span>table<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 哈希表大小</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 哈希表大小掩码，用于计算索引值</span>    <span class="token comment" spellcheck="true">// 总是等于 size - 1</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sizemask<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 该哈希表已有节点的数量</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span><span class="token punctuation">}</span> dictht<span class="token punctuation">;</span></code></pre><p>哈希表节点：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> dictEntry <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 键</span>    <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 值</span>    <span class="token keyword">union</span> <span class="token punctuation">{</span>        <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span>        uint64_t u64<span class="token punctuation">;</span>        int64_t s64<span class="token punctuation">;</span>    <span class="token punctuation">}</span> v<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 指向下个哈希表节点，形成链表</span>    <span class="token keyword">struct</span> dictEntry <span class="token operator">*</span>next<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 单链表结构</span><span class="token punctuation">}</span> dictEntry<span class="token punctuation">;</span></code></pre><p>字典：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> dict <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 类型特定函数</span>    dictType <span class="token operator">*</span>type<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 私有数据</span>    <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 哈希表（dictht ht[2] 代表有两个 dictht 数组）</span>    dictht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// rehash 索引</span>    <span class="token comment" spellcheck="true">// 当 rehash 不在进行时，值为 -1</span>    <span class="token keyword">int</span> rehashidx<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* rehashing not in progress if rehashidx == -1 */</span><span class="token punctuation">}</span> dict<span class="token punctuation">;</span></code></pre><p>从上面可以看到，Redis 的字典有这几个特点：</p><ul><li><p>Reids 的 Hash 采用<strong>链地址法</strong>来处理冲突，然后它没有使用红黑树优化。</p></li><li><p>哈希表节点采用<strong>单链表</strong>结构。</p></li><li><p>rehash 优化。当哈希表保存的键值对太多或者太少时，就要通过 rehash（重新散列）来对哈希表进行相应的扩展或者收缩。具体步骤：</p><ul><li>如果执行扩展操作，会基于原哈希表创建一个大小等于 <code>ht[0].used * 2</code> 的哈希表（也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表）。相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。</li><li>重新利用上面的哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。</li><li>所有键值对都迁徙完毕后，释放原哈希表的内存空间。</li></ul></li><li><p><strong>触发扩容的条件：</strong>（负载因子 = 哈希表已保存节点数量 / 哈希表大小）</p><ul><li>服务器目前没有执行 <strong>BGSAVE</strong> 命令或者 <strong>BGREWRITEAOF</strong> 命令，并且负载因子大于等于 <strong>1</strong> 。</li><li>服务器目前正在执行 <strong>BGSAVE</strong> 命令或者 <strong>BGREWRITEAOF</strong> 命令，并且负载因子大于等于 <strong>5</strong> 。</li></ul></li><li><p><strong>渐进式 rehash：</strong>Redis 考虑到大量数据迁移带来的 CPU 繁忙（可能导致一段时间内停止服务），所以采用了渐进式 rehash 的方案。</p><ul><li>为 <code>ht[1]</code> 分配空间，同时持有两个哈希表（一个空表、一个有数据）。</li><li>维持一个计数器 <code>rehashidx</code> ，初始值 <strong>0</strong> 。</li><li>每次对字典增删改查，会顺带将 <code>ht[0]</code> 中的数据迁移到 <code>ht[1]</code> ，<code>rehashidx++</code>（注意：<code>ht[0]</code> 中的数据是只减不增的）。</li><li>直到 rehash 操作完成，<code>rehashidx</code> 值设为 <strong>-1</strong> 。</li></ul><blockquote><p>好处：采用分而治之的思想，将庞大的迁移工作量划分到每一次 CURD 中，避免了服务繁忙。</p></blockquote></li></ul><h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><p>跳跃表（skipList）是一种有序数据结构，它通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。具有如下性质：</p><ul><li>由很多层结构组成。</li><li>每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的 <strong>head</strong> 节点和后面的 <strong>NIL</strong> 节点。</li><li>最底层的链表包含了所有的元素。</li><li>如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层的元素是当前层的元素的子集）。</li><li>链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点。</li></ul><p><img src="https://s1.ax1x.com/2020/04/23/JwePPO.png" alt="跳跃表"></p><p>跳跃表节点：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> zskiplistNode <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 后退指针</span>    <span class="token keyword">struct</span> zskiplistNode <span class="token operator">*</span>backward<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 分值</span>    <span class="token keyword">double</span> score<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 成员对象</span>    robj <span class="token operator">*</span>obj<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 层</span>    <span class="token keyword">struct</span> zskiplistLevel <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 前进指针</span>        <span class="token keyword">struct</span> zskiplistNode <span class="token operator">*</span>forward<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 跨度</span>        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> span<span class="token punctuation">;</span>     <span class="token punctuation">}</span> level<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span> zskiplistNode<span class="token punctuation">;</span></code></pre><p>跳跃表：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> zskiplist <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 表头节点和表尾节点</span>    <span class="token keyword">struct</span> zskiplistNode <span class="token operator">*</span>header<span class="token punctuation">,</span> <span class="token operator">*</span>tail<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 表中节点的数量</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 表中层数最大的节点的层数</span>    <span class="token keyword">int</span> level<span class="token punctuation">;</span><span class="token punctuation">}</span> zskiplist<span class="token punctuation">;</span></code></pre><p>跳跃表的几个概念：</p><ul><li>层：<code>level[]</code> 字段，层的数量越多，访问节点速度越快。（因为它相当于是索引，层数越多，它索引就越细，就能很快找到索引值。）</li><li>前进指针：层中有一个 <code>forward</code> 字段，用于从表头向表尾方向访问。</li><li>跨度：<code>span</code> 字段，用于记录两个节点之间的距离。</li><li>后退指针：<code>backward</code> 字段用于从表尾向表头方向访问。</li></ul><p>跳跃表的操作：</p><ul><li>搜索：从最高层的链表节点开始，如果比当前节点大并且比当前层的下一个节点小，那么则往下找，也就是和当前层的下一层的节点的下一个节点进行比较，以此类推，一直找到最底层的最后一个节点，如果找到则返回，反之则返回空。</li><li>插入：首先确定插入的层数，有一种方法是假设抛一枚硬币，如果是正面就累加，直到遇见反面为止，最后记录正面的次数作为插入的层数。当确定插入的层数 <strong>k</strong> 后，则需要将新元素插入到从底层到 <strong>k</strong> 层。</li><li>删除：在各个层中找到包含指定值的节点，然后将节点从链表中删除即可，如果删除以后只剩下头尾两个节点，则删除这一层。</li></ul><h3 id="整数集合（intset）"><a href="#整数集合（intset）" class="headerlink" title="整数集合（intset）"></a>整数集合（intset）</h3><p>Reids 对整数存储专门作了优化，intset 就是 Redis 用于保存整数值的集合数据结构。当一个集合中只包含整数元素，Redis 就会用这个来存储。它可以保存类型为 int16_t、int32_t 或者 int64_t 的整数值，并且保证集合中不会出现重复元素。</p><p>整数集合：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> intset <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 编码方式</span>    uint32_t encoding<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 集合包含的元素数量</span>    uint32_t length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 保存元素的数组</span>    int8_t contents<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span> intset<span class="token punctuation">;</span></code></pre><ul><li><p><strong>升级：</strong>当我们新增的元素类型比原集合元素类型的长度要大时（如 int16 -&gt; int32 ），需要对整数集合进行升级，才能将新元素放入整数集合中。</p><ul><li>根据新元素类型，扩展整数集合底层数组的大小，并为新元素分配空间。</li><li>将底层数组现有的所有元素都转成与新元素相同类型的元素，并将转换后的元素放到正确的位置，放置过程中，维持整个元素顺序都是有序的。</li><li>将新元素添加到整数集合中（保证有序）。</li></ul><blockquote><p>升级能极大地节省内存。</p></blockquote></li><li><p><strong>降级：</strong>整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。</p></li></ul><h3 id="压缩列表（ziplist）"><a href="#压缩列表（ziplist）" class="headerlink" title="压缩列表（ziplist）"></a>压缩列表（ziplist）</h3><p>ziplist 是 Redis 为了节约内存而开发的顺序型数据结构。它被用在列表键和哈希键中。一般用于小数据存储。<strong>压缩列表并不是对数据利用某种算法进行压缩，而是将数据按照一定规则编码在一块连续的内存区域，目的是节省内存。</strong></p><p><img src="https://s1.ax1x.com/2020/04/23/JwM0Kg.png" alt="压缩列表"></p><p><img src="https://s1.ax1x.com/2020/04/23/JwMR2T.png" alt="压缩列表各参数说明"></p><blockquote><p>ziplist 没有明确定义结构体，这里只做大概的演示。</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> entry <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">/*前一个元素长度需要空间和前一个元素长度*/</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> prevlengh<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/*元素内容编码*/</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> encoding<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/*元素实际内容*/</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>data<span class="token punctuation">;</span><span class="token punctuation">}</span> zlentry<span class="token punctuation">;</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> ziplist <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">/*ziplist分配的内存大小*/</span>     uint32_t zlbytes<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/*达到尾部的偏移量*/</span>     uint32_t zltail<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/*存储元素实体个数*/</span>     uint16_t zllen<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/*存储内容实体元素*/</span>     <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span> entry<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/*尾部标识*/</span>     <span class="token keyword">unsigned</span> <span class="token keyword">char</span> zlend<span class="token punctuation">;</span><span class="token punctuation">}</span> ziplist<span class="token punctuation">;</span></code></pre><p>压缩列表的每个 <code>entry</code> 构成如下：</p><p><img src="https://s1.ax1x.com/2020/04/23/JwQuon.png" alt="entry 构成"></p><p><strong>previous_entry_length：</strong>记录压缩列表前一个字节的长度。<code>previous_entry_length</code> 的长度可能是 <strong>1</strong> 个字节或者是 <strong>5</strong> 个字节，如果上一个节点的长度小于 254 ，则该节点只需要一个字节就可以表示前一个节点的长度了，如果前一个节点的长度大于等于 254 ，则 <code>previous length</code> 的第一个字节为 254 ，后面用 4 个字节表示当前节点前一个节点的长度。利用此原理即当前节点位置减去上一个节点的长度即得到上一个节点的起始位置，压缩列表可以从尾部向头部遍历。这么做很有效地减少了内存的浪费。</p><p><strong>encoding：</strong>节点的 <code>encoding</code> 保存的是节点的 <code>content</code> 的内容类型以及长度，<code>encoding</code> 类型一共有两种，一种是字节数组，另一种是整数，<code>encoding</code> 区域长度为 <strong>1</strong> 字节、<strong>2</strong> 字节或者 <strong>5</strong> 字节长。</p><p><strong>content：</strong><code>content</code> 区域用于保存节点的内容，节点内容类型和长度由 <code>encoding</code> 决定。</p><h3 id="快速列表（quicklist）"><a href="#快速列表（quicklist）" class="headerlink" title="快速列表（quicklist）"></a>快速列表（quicklist）</h3><p>一个由 ziplist 组成的双向链表。但是一个 quicklist 可以有多个 quicklist 节点，它很像 B 树的存储方式。是在 Redis 3.2 版本中新加的数据结构，用在列表的底层实现。</p><p><img src="https://s1.ax1x.com/2020/04/23/JwlEfx.png" alt="快速列表"></p><p>表头结构：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> quicklist <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//指向头部(最左边)quicklist节点的指针</span>    quicklistNode <span class="token operator">*</span>head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//指向尾部(最右边)quicklist节点的指针</span>    quicklistNode <span class="token operator">*</span>tail<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//ziplist中的entry节点计数器</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> count<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* total count of all entries in all ziplists */</span>    <span class="token comment" spellcheck="true">//quicklist的quicklistNode节点计数器</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">/* number of quicklistNodes */</span>    <span class="token comment" spellcheck="true">//保存ziplist的大小，配置文件设定，占16bits</span>    <span class="token keyword">int</span> fill <span class="token punctuation">:</span> <span class="token number">16</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">/* fill factor for individual nodes */</span>    <span class="token comment" spellcheck="true">//保存压缩程度值，配置文件设定，占16bits，0表示不压缩</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> compress <span class="token punctuation">:</span> <span class="token number">16</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* depth of end nodes not to compress;0=off */</span><span class="token punctuation">}</span> quicklist<span class="token punctuation">;</span></code></pre><p>quicklist 节点结构：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> quicklistNode <span class="token punctuation">{</span>    <span class="token keyword">struct</span> quicklistNode <span class="token operator">*</span>prev<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//前驱节点指针</span>    <span class="token keyword">struct</span> quicklistNode <span class="token operator">*</span>next<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//后继节点指针</span>    <span class="token comment" spellcheck="true">//不设置压缩数据参数recompress时指向一个ziplist结构</span>    <span class="token comment" spellcheck="true">//设置压缩数据参数recompress指向quicklistLZF结构</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>zl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//压缩列表ziplist的总长度</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> sz<span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">/* ziplist size in bytes */</span>    <span class="token comment" spellcheck="true">//ziplist中包的节点数，占16 bits长度</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> count <span class="token punctuation">:</span> <span class="token number">16</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* count of items in ziplist */</span>    <span class="token comment" spellcheck="true">//表示是否采用了LZF压缩算法压缩quicklist节点，1表示压缩过，2表示没压缩，占2 bits长度</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> encoding <span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* RAW==1 or LZF==2 */</span>    <span class="token comment" spellcheck="true">//表示一个quicklistNode节点是否采用ziplist结构保存数据，2表示压缩了，1表示没压缩，默认是2，占2bits长度</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> container <span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/* NONE==1 or ZIPLIST==2 */</span>    <span class="token comment" spellcheck="true">//标记quicklist节点的ziplist之前是否被解压缩过，占1bit长度</span>    <span class="token comment" spellcheck="true">//如果recompress为1，则等待被再次压缩</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> recompress <span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* was this node previous compressed? */</span>    <span class="token comment" spellcheck="true">//测试时使用</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> attempted_compress <span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* node can't compress; too small */</span>    <span class="token comment" spellcheck="true">//额外扩展位，占10bits长度</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> extra <span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* more bits to steal for future usage */</span><span class="token punctuation">}</span> quicklistNode<span class="token punctuation">;</span></code></pre><p><strong>相关配置：</strong></p><p>在 redis.conf 中的 <strong>ADVANCED CONFIG</strong> 部分：</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">list-max-ziplist-size</span> <span class="token attr-value">-2</span><span class="token attr-name">list-compress-depth</span> <span class="token attr-value">0</span></code></pre><p><strong>list-max-ziplist-size ：</strong>它可以取正值，也可以取负值。</p><p>当取<strong>正值</strong>的时候，表示按照数据项个数来限定每个 quicklist 节点上的 ziplist 长度。比如，当这个参数配置成 5 的时候，表示每个 quicklist 节点的 ziplist 最多包含 5 个数据项。</p><p>当取<strong>负值</strong>的时候，表示按照占用字节数来限定每个 quicklist 节点上的 ziplist 长度。这时，它只能取 -1 到 -5 这五个值，每个值含义如下：</p><ul><li>-5：每个 quicklist 节点上的 ziplist 大小不能超过 64 Kb 。（注：1kb = 1024 bytes）</li><li>-4：每个 quicklist 节点上的 ziplist 大小不能超过 32 Kb 。</li><li>-3：每个 quicklist 节点上的 ziplist 大小不能超过 16 Kb 。</li><li>-2：每个 quicklist 节点上的 ziplist 大小不能超过 8 Kb 。（ -2 是 Redis 给出的<strong>默认值</strong>）</li></ul><p><strong>list-compress-depth：</strong>表示一个 quicklist 两端<strong>不被压缩</strong>的节点个数。</p><blockquote><p>这里的节点个数是指 quicklist 双向链表的节点个数，而不是指 ziplist 里面的数据项个数。实际上，一个 quicklist 节点上的 ziplist ，如果被压缩，就是整体被压缩的。</p></blockquote><p><strong>list-compress-depth</strong> 的取值含义如下：</p><ul><li>0：是个特殊值，表示都不压缩。这是 Redis 的<strong>默认值</strong>。</li><li>1：表示 quicklist 两端各有 1 个节点不压缩，中间的节点压缩。</li><li>2：表示 quicklist 两端各有 2 个节点不压缩，中间的节点压缩。</li><li>3：表示 quicklist 两端各有 3 个节点不压缩，中间的节点压缩。</li><li>以此类推…</li></ul><p>Redis 对于 quicklist 内部节点的压缩算法，采用的是 <strong>LZF</strong> ——一种无损压缩算法。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上介绍的简单字符串、链表、字典、跳跃表、整数集合、压缩列表、快速列表等数据结构就是 Redis 底层的一些数据结构，用来实现 Redis 的五大数据类型。</p><p>好了，以上就是这篇文章的全部内容了，能看到这里的人呀，都是<strong>人才</strong>，祝各位看官都能成为 offer 收割机^∨^。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>《Redis设计与实现》</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础</title>
      <link href="/2020/04/22/shu-ju-ku/redis-ji-chu/"/>
      <url>/2020/04/22/shu-ju-ku/redis-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-基础"><a href="#Redis-基础" class="headerlink" title="Redis 基础"></a>Redis 基础</h1><p><strong>Redis</strong> 在互联网技术存储方面使用如此广泛，几乎所有的后端技术面试官都要在 <strong>Redis</strong> 的使用和原理方面对小伙伴们进行 360° 的刁难。作为一个在互联网公司面一次拿一次 offer 的面霸（<strong>请允许我使用一下夸张的修辞手法</strong>），打败了无数竞争对手，每次都只能看到无数落寞的身影失望的离开，略感愧疚，在一个寂寞难耐的夜晚，我痛定思痛，决定开始写《吊打面试官》系列，希望能帮助各位读者以后面试势如破竹，对面试官进行 360° 的反击，吊打问你的面试官，让一同面试的同僚铩羽而归，疯狂收割大厂 offer ！</p><h2 id="面试开始"><a href="#面试开始" class="headerlink" title="面试开始"></a>面试开始</h2><blockquote><p>一个大腹便便，穿着格子衬衣的中年男子，拿着一个满是划痕的 Mac 向你走来，看着快秃顶的头发，心想着肯定是尼玛顶级架构师吧！但是我们腹有诗书气自华，虚都不虚。</p></blockquote><p> <img src="https://s1.ax1x.com/2020/04/23/JdyFeA.png" alt=""></p><h3 id="小伙子您好，看你简历上写了你项目里面用到了-Redis-，你们为啥用-Redis-？"><a href="#小伙子您好，看你简历上写了你项目里面用到了-Redis-，你们为啥用-Redis-？" class="headerlink" title="小伙子您好，看你简历上写了你项目里面用到了 Redis ，你们为啥用 Redis ？"></a>小伙子您好，看你简历上写了你项目里面用到了 Redis ，你们为啥用 Redis ？</h3><p>心里忍不住暗骂，这叫啥问题，大家不都是用的这个嘛，但是你不能说出来。</p><p>认真回答道：<strong>帅气迷人的面试官您好</strong>，因为传统的关系型数据库如 MySQL 已经不能适用所有的场景了，比如秒杀的库存扣减，APP 首页的访问流量高峰等等，都很容易把数据库打崩，所以引入了缓存中间件，目前市面上比较常用的缓存中间件有 <strong>Redis</strong> 和 <strong>Memcached</strong> 。不过综和考虑了他们的优缺点，最后选择了 Redis 。</p><p><strong>至于更细节的对比朋友们记得查阅 Redis 和 Memcached 的区别，比如两者的优缺点对比和各自的场景，后续我有时间也会写出来。</strong></p><h3 id="那小伙子，我再问你，Redis-有哪些数据结构呀？"><a href="#那小伙子，我再问你，Redis-有哪些数据结构呀？" class="headerlink" title="那小伙子，我再问你，Redis 有哪些数据结构呀？"></a>那小伙子，我再问你，Redis 有哪些数据结构呀？</h3><p>字符串 <strong><code>String</code></strong> 、字典 <strong><code>Hash</code></strong> 、列表 <strong><code>List</code></strong> 、集合 <strong><code>Set</code></strong> 、有序集合 <strong><code>SortedSet（ZSet）</code></strong>。</p><p><strong>这里我相信 99% 的读者都能回答上来 Redis 的5个基本数据类型。如果回答不出来的小伙伴我们就要加油补课哟，大家知道五种类型最适合的场景更好。</strong></p><p>但是，如果你是 Redis 中高级用户，而且你要在这次面试中突出你和其他候选人的不同，还需要加上下面几种数据结构 HyperLogLog、Geo、Pub/Sub 。</p><p>如果你还想加分，那你说还玩过 Redis Module，像 BloomFilter，RedisSearch，Redis-ML，这个时候面试官得眼睛就开始发亮了，心想这个小伙子<strong>有点东西啊</strong>。</p><blockquote><p>注：本人在面试回答到 Redis 相关的问题的时候，经常提到 BloomFilter（布隆过滤器）这玩意的使用场景是真的多，而且用起来是真的香，原理也好理解，看一下文章就可以在面试官面前侃侃而谈了，不香么？传送门：<a href="https://www.niewenjun.com/2020/04/24/shu-ju-ku/bu-long-guo-lu-qi-bloomfilter">避免缓存穿透的利器之Bloom Filter</a></p></blockquote><h3 id="如果有大量的-key-需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的-key-需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的 key 需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的 key 需要设置同一时间过期，一般需要注意什么？</h3><p>如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，Redis 可能会出现短暂的卡顿现象。严重的话会出现缓存雪崩，我们一般需要在时间上加一个随机值，使得过期时间分散一些。</p><p><strong>电商首页经常会使用定时任务刷新缓存，可能大量的数据失效时间都十分集中，如果失效时间一样，又刚好在失效的时间点大量用户涌入，就有可能造成缓存雪崩。</strong></p><h3 id="那你使用过-Redis-分布式锁么，它是什么回事？"><a href="#那你使用过-Redis-分布式锁么，它是什么回事？" class="headerlink" title="那你使用过 Redis 分布式锁么，它是什么回事？"></a>那你使用过 Redis 分布式锁么，它是什么回事？</h3><p>先拿 <code>setnx</code> 来争抢锁，抢到之后，再用 <code>expire</code> 给锁加一个过期时间防止锁忘记了释放。</p><h3 id="这时候对方会告诉你说你回答得不错，然后接着问如果在-setnx-之后执行-expire-之前进程意外-crash-或者要重启维护了，那会怎么样？"><a href="#这时候对方会告诉你说你回答得不错，然后接着问如果在-setnx-之后执行-expire-之前进程意外-crash-或者要重启维护了，那会怎么样？" class="headerlink" title="这时候对方会告诉你说你回答得不错，然后接着问如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，那会怎么样？"></a>这时候对方会告诉你说你回答得不错，然后接着问如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，那会怎么样？</h3><p>这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要<strong>抓一抓自己得脑袋，故作思考片刻</strong>，好像接下来的结果是你主动思考出来的，然后回答：我记得 <strong><code>set</code></strong> 指令有非常复杂的参数，这个应该是可以同时把 <code>setnx</code> 和 <code>expire</code> 合成一条指令来用的！</p><h3 id="对方这时会显露笑容，心里开始默念：嗯，这小子还不错，开始有点意思了。"><a href="#对方这时会显露笑容，心里开始默念：嗯，这小子还不错，开始有点意思了。" class="headerlink" title="对方这时会显露笑容，心里开始默念：嗯，这小子还不错，开始有点意思了。"></a>对方这时会显露笑容，心里开始默念：嗯，这小子还不错，开始有点意思了。</h3><h3 id="假如-Redis-里面有-1-亿个-key-，其中有-10w-个-key-是以某个固定的已知的前缀开头的，如何将它们全部找出来？"><a href="#假如-Redis-里面有-1-亿个-key-，其中有-10w-个-key-是以某个固定的已知的前缀开头的，如何将它们全部找出来？" class="headerlink" title="假如 Redis 里面有 1 亿个 key ，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如何将它们全部找出来？"></a>假如 Redis 里面有 1 亿个 key ，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如何将它们全部找出来？</h3><p>使用 <strong><code>keys</code></strong> 指令可以扫出指定模式的 key 列表。</p><h3 id="对方接着追问：如果这个-Redis-正在给线上的业务提供服务，那使用-keys-指令会有什么问题？"><a href="#对方接着追问：如果这个-Redis-正在给线上的业务提供服务，那使用-keys-指令会有什么问题？" class="headerlink" title="对方接着追问：如果这个 Redis 正在给线上的业务提供服务，那使用 keys 指令会有什么问题？"></a>对方接着追问：如果这个 Redis 正在给线上的业务提供服务，那使用 keys 指令会有什么问题？</h3><p>这个时候你要回答 Redis 关键的一个特性：Redis 是<strong>单线程</strong>的。<code>keys</code> 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 <strong><code>scan</code></strong> 指令，<strong><code>scan</code></strong> 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 <code>keys</code> 指令长。</p><blockquote><p>不过，增量式迭代命令也不是没有缺点的： 举个例子， 使用 <strong>SMEMBERS</strong> 命令可以返回集合键当前包含的所有元素， 但是对于 <strong>SCAN</strong> 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 。</p></blockquote><h3 id="使用过-Redis-做异步队列么，你是怎么用的？"><a href="#使用过-Redis-做异步队列么，你是怎么用的？" class="headerlink" title="使用过 Redis 做异步队列么，你是怎么用的？"></a>使用过 Redis 做异步队列么，你是怎么用的？</h3><p> 一般使用 <strong><code>List</code></strong> 结构作为队列，<strong>rpush</strong> 生产消息，<strong>lpop</strong> 消费消息。当 lpop 没有消息的时候，要适当 <strong>sleep</strong> 一会再重试。</p><h3 id="如果对方追问可不可以不用-sleep-呢？"><a href="#如果对方追问可不可以不用-sleep-呢？" class="headerlink" title="如果对方追问可不可以不用 sleep 呢？"></a>如果对方追问可不可以不用 sleep 呢？</h3><p>List 还有个指令叫 <strong><code>blpop</code></strong> ，在没有消息的时候，它会阻塞住直到消息到来。</p><h3 id="如果对方接着追问能不能生产一次消费多次呢？"><a href="#如果对方接着追问能不能生产一次消费多次呢？" class="headerlink" title="如果对方接着追问能不能生产一次消费多次呢？"></a>如果对方接着追问能不能生产一次消费多次呢？</h3><p>使用 <strong><code>pub/sub</code></strong> 主题订阅者模式，可以实现 1 : N 的消息队列。</p><h3 id="如果对方继续追问-pub-sub-有什么缺点？"><a href="#如果对方继续追问-pub-sub-有什么缺点？" class="headerlink" title="如果对方继续追问 pub/sub 有什么缺点？"></a>如果对方继续追问 pub/sub 有什么缺点？</h3><p>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 <strong>RocketMQ</strong> 等。</p><h3 id="如果对方究极-TM-追问-Redis-如何实现延时队列？"><a href="#如果对方究极-TM-追问-Redis-如何实现延时队列？" class="headerlink" title="如果对方究极 TM 追问 Redis 如何实现延时队列？"></a>如果对方究极 TM 追问 Redis 如何实现延时队列？</h3><p>这一套连招下来，我估计现在你很想把面试官一棒打死（<strong>面试官自己都想打死自己了怎么问了这么多自己都不知道的</strong>），但是你很克制。平复一下激动的内心，然后神态自若的回答道：使用 SortedSet ，拿时间戳作为 score ，消息内容作为 key 调用 <strong>zadd</strong> 来生产消息，消费者用 <strong>zrangebyscore</strong> 指令获取 N 秒之前的数据轮询进行处理。</p><p><strong>到这里，面试官暗地里已经对你竖起了大拇指。并且已经默默给了你 A+ ，但是他不知道的是此刻你却竖起了中指，在椅子背后。</strong></p><h3 id="Redis-是怎么持久化的？服务主从数据怎么交互的？"><a href="#Redis-是怎么持久化的？服务主从数据怎么交互的？" class="headerlink" title="Redis 是怎么持久化的？服务主从数据怎么交互的？"></a>Redis 是怎么持久化的？服务主从数据怎么交互的？</h3><p><strong><code>RDB</code></strong> 做<strong>镜像全量持久化</strong>，<strong><code>AOF</code></strong> 做<strong>增量持久化</strong>。因为 RDB 会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要 AOF 来配合使用。在 Redis 实例重启时，会使用 RDB 持久化文件重新构建内存，再使用 AOF 重放近期的操作指令来实现完整恢复重启之前的状态。</p><blockquote><p>这里很好理解，把 <strong>RDB</strong> 理解为一整个表全量的数据，<strong>AOF</strong> 理解为每次操作的日志就好了，服务器重启的时候先把表的数据全部搞进去，但是他可能不完整，你再回放一下日志，数据不就完整了嘛。不过 <strong>Redis</strong> 本身的机制是 <strong>AOF</strong> 持久化开启且存在 <strong>AOF</strong> 文件时，优先加载 <strong>AOF</strong> 文件；<strong>AOF</strong> 关闭或者 <strong>AOF</strong> 文件不存在时，加载 <strong>RDB</strong> 文件；加载 <strong>AOF/RDB</strong> 文件城后，<strong>Redis</strong> 启动成功；<strong>AOF/RDB</strong> 文件存在错误时，<strong>Redis</strong> 启动失败并打印错误信息。</p></blockquote><h3 id="对方追问那如果突然机器掉电会怎样？"><a href="#对方追问那如果突然机器掉电会怎样？" class="headerlink" title="对方追问那如果突然机器掉电会怎样？"></a>对方追问那如果突然机器掉电会怎样？</h3><p>取决于 AOF 日志 <code>sync</code> 属性的配置，如果不要求性能，在每条写指令时都 sync 一下磁盘，就不会丢失数据。但是在高性能的要求下每次都 sync 是不现实的，一般都使用定时 sync ，比如 1s 1 次，这个时候最多就会丢失 1s 的数据。</p><h3 id="对方追问-RDB-的原理是什么？"><a href="#对方追问-RDB-的原理是什么？" class="headerlink" title="对方追问 RDB 的原理是什么？"></a>对方追问 RDB 的原理是什么？</h3><p>你给出两个词汇就可以了，<strong><code>fork</code></strong> 和 <strong><code>cow</code></strong> 。fork 是指 Redis 通过创建<strong>子进程</strong>来进行 RDB 操作，cow 指的是 copy on write ，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p><blockquote><p>注：回答这个问题的时候，如果你还能说出 AOF 和 RDB 的优缺点，我觉得我是面试官在这个问题上我会给你点赞，两者其实区别还是很大的，而且涉及到 Redis 集群的数据同步问题等等。</p></blockquote><h3 id="Pipeline-有什么好处，为什么要用-Pipeline-？"><a href="#Pipeline-有什么好处，为什么要用-Pipeline-？" class="headerlink" title="Pipeline 有什么好处，为什么要用 Pipeline ？"></a>Pipeline 有什么好处，为什么要用 Pipeline ？</h3><p>可以<strong>将多次 IO 往返的时间缩减为一次</strong>，前提是 pipeline 执行的指令之间没有因果相关性。使用 <strong>redis-benchmark</strong> 进行压测的时候可以发现影响 Redis 的 QPS 峰值的一个重要因素是 pipeline 批次指令的数目。</p><h3 id="Redis-的同步机制了解么？"><a href="#Redis-的同步机制了解么？" class="headerlink" title="Redis 的同步机制了解么？"></a>Redis 的同步机制了解么？</h3><p>Redis 可以使用主从同步，从从同步。第一次同步时，主节点做一次 <strong><code>bgsave</code></strong> ，并同时将后续修改操作记录到内存 buffer ，待完成后将 RDB 文件全量同步到复制节点，复制节点接受完成后将 RDB 镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的增量数据通过 AOF 日志同步即可，有点类似数据库的 binlog 。</p><h3 id="是否使用过Redis集群，集群的高可用怎么保证，集群的原理是什么？"><a href="#是否使用过Redis集群，集群的高可用怎么保证，集群的原理是什么？" class="headerlink" title="是否使用过Redis集群，集群的高可用怎么保证，集群的原理是什么？"></a>是否使用过Redis集群，集群的高可用怎么保证，集群的原理是什么？</h3><p><strong>Redis Sentinal</strong> 着眼于高可用，在 Master 宕机时会自动将 Slave 提升为 Master ，继续提供服务。</p><p><strong>Redis Cluster</strong> 着眼于扩展性，在单个 Redis 内存不足时，使用 Cluster 进行分片存储。</p><h2 id="面试结束"><a href="#面试结束" class="headerlink" title="面试结束"></a>面试结束</h2><h3 id="小伙子你可以的，什么时候有时间来上班啊，要不明天就来吧？"><a href="#小伙子你可以的，什么时候有时间来上班啊，要不明天就来吧？" class="headerlink" title="小伙子你可以的，什么时候有时间来上班啊，要不明天就来吧？"></a>小伙子你可以的，什么时候有时间来上班啊，要不明天就来吧？</h3><p>你强装镇定，这么急啊我还需要租房，要不下礼拜一吧。</p><h3 id="好的。心想这小子这么-NB-是不是很多-Offer-在手上，不行我得叫-HR-给他加钱。"><a href="#好的。心想这小子这么-NB-是不是很多-Offer-在手上，不行我得叫-HR-给他加钱。" class="headerlink" title="好的。心想这小子这么 NB 是不是很多 Offer 在手上，不行我得叫 HR 给他加钱。"></a>好的。心想这小子这么 NB 是不是很多 Offer 在手上，不行我得叫 HR 给他加钱。</h3><p>能撑到最后，你自己都忍不住自己给自己点个赞了!</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>在技术面试的时候，不管是 Redis 还是什么问题，如果你能举出实际的例子，或者是直接说自己开发过程的问题和收获会给面试官的印象分会加很多，回答逻辑性也要强一点，不要东一点西一点，容易把自己都绕晕的。</strong></p><p><strong>还有一点就是我问你为啥用 Redis 你不要一上来就直接回答问题了，你可以这样回答：</strong></p><p><strong>帅气的面试官您好</strong>，首先我们的项目 DB 遇到了瓶颈，特别是秒杀和热点数据这样的场景 DB 基本上就扛不住了，那就需要缓存中间件的加入了，目前市面上有的缓存中间件有 Redis 和 Memcached ，他们的优缺点……，综合这些然后再结合我们项目特点，最后我们在技术选型的时候选了谁。</p><p>如果你这样有条不紊，有理有据的回答了我的问题而且还说出这么多我问题外的知识点，我会觉得你不只是一个会写代码的人，你逻辑清晰，你对技术选型，对中间件对项目都有自己的理解和思考，说白了就是你的 offer 有戏了。</p><p>好了，以上就是这篇文章的全部内容了，能看到这里的人呀，都是<strong>人才</strong>，祝各位看官都能成为 offer 收割机^∨^。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引总结</title>
      <link href="/2020/04/21/shu-ju-ku/mysql-suo-yin-zong-jie/"/>
      <url>/2020/04/21/shu-ju-ku/mysql-suo-yin-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL-索引总结"><a href="#MySQL-索引总结" class="headerlink" title="MySQL 索引总结"></a>MySQL 索引总结</h2><h3 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h3><p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有：B 树、B+ 树和 Hash 。</strong></p><p>索引的作用就相当于目录的作用。打个比方：我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p><h3 id="为什么要使用索引？"><a href="#为什么要使用索引？" class="headerlink" title="为什么要使用索引？"></a>为什么要使用索引？</h3><ul><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li><li>可以大大加快数据的检索速度（大大减少的检索的数据量）,  这也是创建索引的最主要的原因。 </li><li>帮助服务器避免排序和临时表。</li><li>将随机 IO 变为顺序 IO 。</li><li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li></ul><h3 id="索引这么多优点，为什么不对表中的每一个列创建一个索引呢？"><a href="#索引这么多优点，为什么不对表中的每一个列创建一个索引呢？" class="headerlink" title="索引这么多优点，为什么不对表中的每一个列创建一个索引呢？"></a>索引这么多优点，为什么不对表中的每一个列创建一个索引呢？</h3><ul><li><p><strong>创建索引和维护索引需要耗费许多时间：</strong>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低 SQL 执行效率。</p></li><li><p><strong>占用物理存储空间：</strong>除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 </p></li><li><p>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 </p></li></ul><h3 id="使用索引的注意事项？"><a href="#使用索引的注意事项？" class="headerlink" title="使用索引的注意事项？"></a>使用索引的注意事项？</h3><ol><li>在经常需要搜索的列上，可以加快搜索的速度。</li><li>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 </li><li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li><li>对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引。</li><li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度。</li><li>避免 where 子句中对字段施加函数，这会造成无法命中索引。</li><li>在使用 InnoDB 时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</li><li>将打算加索引的列设置为 NOT NULL ，否则将导致引擎放弃使用索引而进行全表扫描。</li><li>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗。MySQL 5.7 可以通过查询 sys 库的 <code>chema_unused_indexes</code> 视图来查询哪些索引从未被使用。</li><li>在使用 limit offset 查询缓慢时，可以借助索引来提高性能。</li></ol><h3 id="MySQL-索引主要使用的两种数据结构"><a href="#MySQL-索引主要使用的两种数据结构" class="headerlink" title="MySQL 索引主要使用的两种数据结构"></a>MySQL 索引主要使用的两种数据结构</h3><p><strong>哈希索引</strong></p><p>对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择 B+Tree 索引。</p><p><strong>B+Tree 索引</strong></p><p><img src="https://s1.ax1x.com/2020/04/21/JJ7lrD.png" alt="B+Tree 索引"></p><h3 id="B-树和-B-树的区别"><a href="#B-树和-B-树的区别" class="headerlink" title="B 树和 B+ 树的区别"></a>B 树和 B+ 树的区别</h3><ul><li>B 树的<strong>所有节点既存放键（key）也存放数据（data）</strong>，而 <strong>B+ 树只有叶子节点存放 key 和 data</strong>，其他的节点只存放 key 。</li><li>B 树的叶子节点都是独立的，B+ 树的叶子节点有一条引用链指向与它相邻的叶子节点，因此 B+ 树更适合做<strong>范围查找</strong>。</li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了，而 <strong>B+ 树的检索效率就很稳定了</strong>，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li></ul><h3 id="Hash-索引和-B-树索引优劣分析"><a href="#Hash-索引和-B-树索引优劣分析" class="headerlink" title="Hash 索引和 B+ 树索引优劣分析"></a>Hash 索引和 B+ 树索引优劣分析</h3><p><strong>Hash 索引定位快</strong></p><p>Hash 索引指的就是 Hash 表，最大的优点就是能够在很短的时间内，根据 Hash 函数定位到数据所在的位置，这是 B+ 树所不能比的。</p><p><strong>Hash 冲突问题</strong></p><p>知道 HashMap 或 HashTable 的同学，相信都知道它们最大的缺点就是 Hash 冲突了。不过对于数据库来说这还不算最大的缺点。</p><p><strong>Hash 索引不支持顺序和范围查询（ Hash 索引不支持顺序和范围查询是它最大的缺点）</strong></p><p>试想一种情况：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> tb1 <span class="token keyword">WHERE</span> id <span class="token operator">&lt;</span> <span class="token number">500</span><span class="token punctuation">;</span></code></pre><p>B+ 树是有序的，在这种范围查询中，优势非常大，直接遍历比 500 小的叶子节点就够了。而 Hash 索引是根据 Hash 算法来定位的，难不成还要把 1 - 499 的数据，每个都进行一次 Hash 计算来定位吗？这就是 Hash 索引最大的缺点了。 </p><h3 id="MyISAM-和-InnoDB-实现-B-Tree-索引方式的区别"><a href="#MyISAM-和-InnoDB-实现-B-Tree-索引方式的区别" class="headerlink" title="MyISAM 和 InnoDB 实现 B+Tree 索引方式的区别"></a>MyISAM 和 InnoDB 实现 B+Tree 索引方式的区别</h3><p><strong>MyISAM</strong></p><p>B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“<strong>非聚簇索引</strong>”。</p><p><strong>InnoDB</strong></p><p>其数据文件本身就是索引文件。相比 MyISAM ，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“<strong>聚簇索引</strong>（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。<strong>在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</strong>PS：整理自《 Java 工程师修炼之道》</p><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><h4 id="主键索引（Primary-Key）"><a href="#主键索引（Primary-Key）" class="headerlink" title="主键索引（Primary Key）"></a>主键索引（Primary Key）</h4><ul><li><p>数据表的主键列使用的就是主键索引。</p></li><li><p>一张数据表有且只能有一个主键，并且主键不能为 null ，不能重复。</p></li><li><p>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6 Byte 的自增主键。</p></li></ul><h4 id="二级索引（辅助索引）"><a href="#二级索引（辅助索引）" class="headerlink" title="二级索引（辅助索引）"></a>二级索引（辅助索引）</h4><p><strong>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></p><p><img src="https://s1.ax1x.com/2020/04/21/JYp0y9.png" alt="二级索引"></p><p>唯一索引，普通索引，前缀索引等索引属于二级索引。</p><p><strong>PS：不懂的同学可以暂存疑，慢慢往下看，后面会有答案的，也可以自行搜索。</strong></p><ol><li><strong>唯一索引（Unique Key）：</strong>唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 <code>NULL</code> ，一张表允许创建多个唯一索引。</strong>建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li><li><strong>普通索引（Index）：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 <code>NULL</code> 。</strong></li><li><strong>前缀索引（Prefix）：</strong>前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符。</li><li><strong>全文索引（FullText）：</strong>全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。MySQL 5.6 之前只有 MYISAM 引擎支持全文索引，5.6之后 InnoDB 也支持了全文索引。 </li></ol><h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p><strong>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</strong></p><p>在 Mysql 中，InnoDB 引擎的表的 <code>.ibd</code> 文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引（ B+ 树）的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p><p><strong>聚集索引的优点：</strong></p><p>聚集索引的<strong>查询速度非常的快</strong>，因为整个 B+ 树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据，避免了<strong>回表</strong>的操作。</p><p><strong>聚集索引的缺点：</strong></p><ol><li><strong>依赖于有序的数据：</strong>因为 B+ 树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li><li><strong>更新代价大：</strong>如果对索引列的数据被修改时，那么对应的索引也将会被修改，何况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</li></ol><h4 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h4><p><strong>非聚集索引即索引结构和数据分开存放的索引。</strong></p><p><strong>二级索引属于非聚集索引。</strong></p><p><img src="https://s1.ax1x.com/2020/04/21/JJzAld.png" alt="MySQL 索引文件截图"></p><blockquote><p>MYISAM 引擎的表的 <strong><code>.MYI</code></strong> 文件包含了表的索引，该表的索引（B+ 树）的每个非叶子节点存储索引，叶子节点存储索引和索引对应数据的指针，指向 <strong><code>.MYD</code></strong> 文件的数据。</p><p><strong>非聚集索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</strong></p></blockquote><p><strong>非聚集索引的优点：</strong></p><p><strong>更新代价比聚集索引要小</strong> 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的。</p><p><strong>非聚集索引的缺点：</strong></p><ol><li>跟聚集索引一样，非聚集索引也依赖于有序的数据。</li><li><strong>可能会二次查询（回表）。</strong>这应该是非聚集索引最大的缺点了。当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li></ol><p><img src="https://s1.ax1x.com/2020/04/21/JJzLAf.png" alt="聚集索引和非聚集索引"></p><h4 id="非聚集索引一定回表查询吗（覆盖索引）？"><a href="#非聚集索引一定回表查询吗（覆盖索引）？" class="headerlink" title="非聚集索引一定回表查询吗（覆盖索引）？"></a>非聚集索引一定回表查询吗（覆盖索引）？</h4><p><strong>非聚集索引不一定回表查询。</strong></p><blockquote><p>试想一种情况，用户准备使用SQL查询用户名，而用户名字段正好建立了索引。</p></blockquote><pre class=" language-sql"><code class="language-sql"> <span class="token keyword">SELECT</span> name <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> username<span class="token operator">=</span><span class="token string">'guang19'</span><span class="token punctuation">;</span></code></pre><blockquote><p>那么这个索引的 key 本身就是 name ，查到对应的 name 直接返回就行了，无需回表查询。</p></blockquote><p><strong>即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表，因为它的主键索引的叶子节点存放的是指针。但是如果 SQL 查的就是主键呢？</strong></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span></code></pre><p>主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为覆盖索引了。</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是<strong>主键+列值</strong>。最终还是要“回表”，也就是要通过主键再查找一次，这样就会比较慢。<strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p><p><img src="https://s1.ax1x.com/2020/04/21/JYpVdP.png" alt="覆盖索引"></p><blockquote><p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。</p><p>再如普通索引，如果一条 SQL 需要查询 name ，name 字段正好有索引，那么直接根据这个索引就可以查到数据，也无需回表。</p></blockquote><p>现在我创建了索引（username, age），我们执行下面的 SQL 语句：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> username <span class="token punctuation">,</span> age <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> username <span class="token operator">=</span> <span class="token string">'Java'</span> <span class="token operator">and</span> age <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">;</span></code></pre><p>在查询数据的时候，要查询出的列在叶子节点都存在！所以，就不用回表。</p><h3 id="选择索引和编写利用这些索引的查询的-3-个原则"><a href="#选择索引和编写利用这些索引的查询的-3-个原则" class="headerlink" title="选择索引和编写利用这些索引的查询的 3 个原则"></a>选择索引和编写利用这些索引的查询的 3 个原则</h3><ol><li>单行访问是很慢的。特别是在机械硬盘存储中（ SSD 的随机 I/O 要快很多，不过这一点仍然成立）。如果服务器从存储中读取一个数据块只是为了获取其中一行，那么就浪费了很多工作。最好读取的块中能包含尽可能多所需要的行。使用索引可以创建位置索引，用以提升效率。</li><li>按顺序访问范围数据是很快的，这有两个原因。第一，顺序 I/O 不需要多次磁盘寻道，所以比随机 I/O 要快很多（特别是对机械硬盘）。第二，如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且 <strong>GROUP BY</strong> 查询也无须再做排序和将行按组进行聚合计算了。</li><li>覆盖索引查询是很快的。如果一个索引包含了查询需要的所有列，那么存储引擎就不需要再回表查找行。这避免了大量的单行访问，而上面的第 1 点已经写明单行访问是很慢的。</li></ol><h3 id="索引创建原则"><a href="#索引创建原则" class="headerlink" title="索引创建原则"></a>索引创建原则</h3><h4 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h4><p>单列索引即由一列属性组成的索引。</p><h4 id="联合索引（多列索引）"><a href="#联合索引（多列索引）" class="headerlink" title="联合索引（多列索引）"></a>联合索引（多列索引）</h4><p>联合索引即由多列属性组成索引。</p><h4 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h4><p>假设创建的联合索引由三个字段组成：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">table</span> <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> index_name <span class="token punctuation">(</span>num<span class="token punctuation">,</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>那么当查询的条件为：<code>num / (num AND name) / (num AND name AND age)</code> 时，索引才生效。所以在创建联合索引时，尽量把查询最频繁的那个字段作为最左（第一个）字段。查询的时候也尽量以这个字段为第一条件。</p><blockquote><p>但可能由于版本原因（我的 MySQL 版本为 8.0.x )或<strong>索引下推</strong>的缘故，我创建的联合索引，相当于在联合索引的每个字段上都创建了相同的索引。</p></blockquote><p><img src="https://s1.ax1x.com/2020/04/21/JY949U.png" alt="联合索引"></p><p>无论是否符合<strong>最左前缀原则</strong>，每个字段的索引都生效：</p><p><img src="https://s1.ax1x.com/2020/04/21/JYC4at.png" alt="联合索引生效"></p><h3 id="索引创建注意点"><a href="#索引创建注意点" class="headerlink" title="索引创建注意点"></a>索引创建注意点</h3><h4 id="最左前缀原则-1"><a href="#最左前缀原则-1" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h4><p>虽然有时不遵守最左前缀原则，索引也会生效。但是我们仍应遵守最左前缀原则，以免版本更迭带来的麻烦。</p><h4 id="选择合适的字段"><a href="#选择合适的字段" class="headerlink" title="选择合适的字段"></a>选择合适的字段</h4><h5 id="1-不为-NULL-的字段"><a href="#1-不为-NULL-的字段" class="headerlink" title="1.不为 NULL 的字段"></a><strong>1.不为 NULL 的字段</strong></h5><p>索引字段的数据应该尽量不为 NULL ，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL ，建议使用 0, 1, true, false 这样语义较为清晰的短值或短字符作为替代。</p><h5 id="2-被频繁查询的字段"><a href="#2-被频繁查询的字段" class="headerlink" title="2.被频繁查询的字段"></a>2.被频繁查询的字段</h5><p>我们创建索引的字段应该是查询操作非常频繁的字段。</p><h5 id="3-被作为条件查询的字段"><a href="#3-被作为条件查询的字段" class="headerlink" title="3.被作为条件查询的字段"></a>3.被作为条件查询的字段</h5><p>被作为 WHERE 条件查询的字段，应该被考虑建立索引。</p><h5 id="4-被经常频繁用于连接的字段"><a href="#4-被经常频繁用于连接的字段" class="headerlink" title="4.被经常频繁用于连接的字段"></a>4.被经常频繁用于连接的字段</h5><p>经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</p><h4 id="不合适创建索引的字段"><a href="#不合适创建索引的字段" class="headerlink" title="不合适创建索引的字段"></a>不合适创建索引的字段</h4><h5 id="1-被频繁更新的字段应该慎重建立索引"><a href="#1-被频繁更新的字段应该慎重建立索引" class="headerlink" title="1.被频繁更新的字段应该慎重建立索引"></a>1.被频繁更新的字段应该慎重建立索引</h5><p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p><h5 id="2-不被经常查询的字段没有必要建立索引"><a href="#2-不被经常查询的字段没有必要建立索引" class="headerlink" title="2.不被经常查询的字段没有必要建立索引"></a>2.不被经常查询的字段没有必要建立索引</h5><h5 id="3-尽可能的考虑建立联合索引而不是单列索引"><a href="#3-尽可能的考虑建立联合索引而不是单列索引" class="headerlink" title="3.尽可能的考虑建立联合索引而不是单列索引"></a>3.尽可能的考虑建立联合索引而不是单列索引</h5><p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+ 树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p><h5 id="4-注意避免冗余索引"><a href="#4-注意避免冗余索引" class="headerlink" title="4.注意避免冗余索引"></a>4.注意避免冗余索引</h5><p>冗余索引指的是索引的功能相同，能够命中就肯定能命中 ，那么就是冗余索引。如（ name, city ）和（name ）这两个索引就是冗余索引，能够命中后者的查询肯定是能够命中前者的。在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p><blockquote><p>MySQL 5.7 版本后，可以通过查询 sys 库的 <code>schema_redundant_indexes</code> 表来查看冗余索引。  </p></blockquote><h5 id="5-考虑在字符串类型的字段上使用前缀索引代替普通索引"><a href="#5-考虑在字符串类型的字段上使用前缀索引代替普通索引" class="headerlink" title="5.考虑在字符串类型的字段上使用前缀索引代替普通索引"></a>5.考虑在字符串类型的字段上使用前缀索引代替普通索引</h5><p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p><h3 id="使用索引一定能提高查询性能吗？"><a href="#使用索引一定能提高查询性能吗？" class="headerlink" title="使用索引一定能提高查询性能吗？"></a>使用索引一定能提高查询性能吗？</h3><p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p><h3 id="为什么索引能提高查询速度？"><a href="#为什么索引能提高查询速度？" class="headerlink" title="为什么索引能提高查询速度？"></a>为什么索引能提高查询速度？</h3><blockquote><p>以下内容整理自：<br>地址：<a href="https://juejin.im/post/5b55b842f265da0f9e589e79" target="_blank" rel="noopener">数据库两大神器【索引和锁】</a><br>作者 ：Java3y</p></blockquote><h4 id="先从-MySQL-的基本存储结构说起"><a href="#先从-MySQL-的基本存储结构说起" class="headerlink" title="先从 MySQL 的基本存储结构说起"></a>先从 MySQL 的基本存储结构说起</h4><p>MySQL 的基本存储结构是<strong>页</strong>（记录都存在页里边）：</p><p><img src="https://s1.ax1x.com/2020/04/22/JYkdSK.png" alt="MySQL 的基本存储结构"></p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-2/82053134.jpg" alt=""></p><ul><li><strong>各个数据页可以组成一个双向链表。</strong></li><li><strong>每个数据页中的记录又可以组成一个单向链表。</strong><ul><li>每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</li><li>以其他列（非主键）作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。</li></ul></li></ul><p>所以说，如果我们写 <code>select * from user where indexName = &#39;xxx&#39;;</code> 这样没有进行任何优化的 SQL 语句，默认会这样做：</p><ol><li><strong>定位到记录所在的页：需要遍历双向链表，找到所在的页。</strong></li><li><strong>从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表了。</strong></li></ol><p>很明显，在数据量很大的情况下这样查找会很慢！这样的时间复杂度为 O（n）。</p><h4 id="使用索引之后"><a href="#使用索引之后" class="headerlink" title="使用索引之后"></a>使用索引之后</h4><p>索引做了些什么可以让我们查询加快速度呢？其实就是将无序的数据变成有序（相对）：</p><p><img src="https://s1.ax1x.com/2020/04/22/JYA8c8.png" alt="MySQL 索引"></p><p>要找到 id 为 8 的记录简要步骤：</p><p><img src="https://s1.ax1x.com/2020/04/22/JYAsjU.png" alt="寻找步骤示例"></p><p>很明显的是：没有用索引我们是需要遍历双向链表来定位对应的页，现在通过 <strong>“目录”</strong> 就可以很快地定位到对应的页上了！（二分查找，时间复杂度近似为 O(logn) ）</p><p>其实底层结构就是 B+ 树，B+ 树作为树的一种实现，能够让我们很快地查找出对应的记录。</p><h3 id="关于索引其他重要的内容补充"><a href="#关于索引其他重要的内容补充" class="headerlink" title="关于索引其他重要的内容补充"></a>关于索引其他重要的内容补充</h3><blockquote><p>以下内容整理自：《 Java 工程师修炼之道》</p></blockquote><h4 id="最左前缀原则-2"><a href="#最左前缀原则-2" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h4><p>MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如 User 表的 name 和 city 加联合索引就是（name, city），而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。如下：        </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> name<span class="token operator">=</span>xx <span class="token operator">and</span> city<span class="token operator">=</span>xx <span class="token punctuation">;</span> ／／可以命中索引<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> name<span class="token operator">=</span>xx <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 可以命中索引</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> city<span class="token operator">=</span>xx <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 无法命中索引            </span></code></pre><p>这里需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如 <code>city= xx and name ＝xx</code>，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的。</p><p>由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。ORDER BY 子句也遵循此规则。</p><h4 id="注意避免冗余索引"><a href="#注意避免冗余索引" class="headerlink" title="注意避免冗余索引"></a>注意避免冗余索引</h4><p>冗余索引指的是索引的功能相同，能够命中就肯定能命中 ，那么就是冗余索引。如（ name, city ）和（name ）这两个索引就是冗余索引，能够命中后者的查询肯定是能够命中前者的。在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p><blockquote><p>MySQL 5.7 版本后，可以通过查询 sys 库的 <code>schema_redundant_indexes</code> 表来查看冗余索引。             </p></blockquote><h3 id="MySQL-如何为表字段添加索引？"><a href="#MySQL-如何为表字段添加索引？" class="headerlink" title="MySQL 如何为表字段添加索引？"></a>MySQL 如何为表字段添加索引？</h3><p>1.添加 PRIMARY KEY（主键索引）</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>table_name<span class="token punctuation">`</span> <span class="token keyword">ADD</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span> <span class="token punctuation">`</span><span class="token keyword">column</span><span class="token punctuation">`</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span></code></pre><p>2.添加 UNIQUE（唯一索引） </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>table_name<span class="token punctuation">`</span> <span class="token keyword">ADD</span> <span class="token keyword">UNIQUE</span> <span class="token punctuation">(</span> <span class="token punctuation">`</span><span class="token keyword">column</span><span class="token punctuation">`</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span></code></pre><p>3.添加 INDEX（普通索引）</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>table_name<span class="token punctuation">`</span> <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> index_name <span class="token punctuation">(</span> <span class="token punctuation">`</span><span class="token keyword">column</span><span class="token punctuation">`</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>4.添加 FULLTEXT（全文索引）</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>table_name<span class="token punctuation">`</span> <span class="token keyword">ADD</span> FULLTEXT <span class="token punctuation">(</span> <span class="token punctuation">`</span><span class="token keyword">column</span><span class="token punctuation">`</span><span class="token punctuation">)</span> <span class="token punctuation">;</span></code></pre><p>5.添加多列索引</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>table_name<span class="token punctuation">`</span> <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> index_name <span class="token punctuation">(</span> <span class="token punctuation">`</span>column1<span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>column2<span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>column3<span class="token punctuation">`</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《Java工程师修炼之道》</li><li>《MySQL高性能书籍_第3版》</li><li><a href="https://juejin.im/post/5b55b842f265da0f9e589e79" target="_blank" rel="noopener">https://juejin.im/post/5b55b842f265da0f9e589e79</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL常见问题总结</title>
      <link href="/2020/04/21/shu-ju-ku/mysql-chang-jian-wen-ti-zong-jie/"/>
      <url>/2020/04/21/shu-ju-ku/mysql-chang-jian-wen-ti-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL-常见问题总结"><a href="#MySQL-常见问题总结" class="headerlink" title="MySQL 常见问题总结"></a>MySQL 常见问题总结</h2><h3 id="什么是-MySQL-？"><a href="#什么是-MySQL-？" class="headerlink" title="什么是 MySQL ？"></a>什么是 MySQL ？</h3><p>MySQL 是一种关系型数据库，在 Java 企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。阿里巴巴数据库系统也大量用到了 MySQL ，因此它的稳定性是有保障的。MySQL 是开放源代码的，因此任何人都可以在 GPL（General Public License）的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是 <strong>3306</strong> 。</p><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><h4 id="一些常用命令"><a href="#一些常用命令" class="headerlink" title="一些常用命令"></a>一些常用命令</h4><p><strong>查看 MySQL 提供的所有存储引擎：</strong></p><pre class=" language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> engines<span class="token punctuation">;</span></code></pre><p><img src="https://s1.ax1x.com/2020/04/21/JG3ws1.png" alt="查看 MySQL 提供的所有存储引擎"></p><p>从上图我们可以查看出 MySQL 当前默认的存储引擎是 InnoDB ，并且在 5.7 版本所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。</p><p><strong>查看 MySQL 当前默认的存储引擎：</strong></p><p>我们也可以通过下面的命令查看默认的存储引擎。</p><pre class=" language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'%storage_engine%'</span><span class="token punctuation">;</span></code></pre><p><strong>查看表的存储引擎：</strong></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">table</span> <span class="token keyword">status</span> <span class="token operator">like</span> <span class="token string">"table_name"</span> <span class="token punctuation">;</span></code></pre><p><img src="https://s1.ax1x.com/2020/04/21/JG3bWQ.png" alt="查看表的存储引擎"></p><h4 id="MyISAM-和-InnoDB-区别"><a href="#MyISAM-和-InnoDB-区别" class="headerlink" title="MyISAM 和 InnoDB 区别"></a>MyISAM 和 InnoDB 区别</h4><p>MyISAM 是 MySQL 的默认数据库引擎（ 5.5 版之前）。虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但 MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。不过，5.5 版本之后，MySQL 引入了 InnoDB（事务性数据库引擎），MySQL 5.5 版本后默认的存储引擎为 InnoDB 。</p><p>大多数时候我们使用的都是 InnoDB 存储引擎，但是在某些情况下使用 MyISAM 也是合适的，比如读密集的情况下（如果你不介意 MyISAM 崩溃恢复问题的话）。</p><p><strong>两者的对比：</strong></p><ol><li><strong>是否支持行级锁：</strong>MyISAM 只有表级锁（table-level locking），而 InnoDB 支持行级锁（row-level locking）和表级锁，默认为行级锁。</li><li><strong>是否支持事务和崩溃后的安全恢复：MyISAM</strong> 强调的是性能，每次查询具有原子性，其执行速度比 InnoDB 类型更快，但是不提供事务支持。但是 <strong>InnoDB</strong> 提供事务，支持事务、外键等高级数据库功能。 具有事务提交（commit）、回滚（rollback）和崩溃修复能力（crash recovery capabilities）的事务安全（transaction-safe (ACID compliant)）型表。</li><li><strong>是否支持外键：</strong>MyISAM 不支持，而 InnoDB 支持。</li><li><strong>是否支持MVCC：</strong>仅 InnoDB 支持。应对高并发事务，MVCC 比单纯的加锁更高效；MVCC 只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作；MVCC 可以使用 <strong>乐观锁</strong> 和 <strong>悲观锁</strong> 来实现；各数据库中 MVCC 实现并不统一。<ul><li>推荐阅读：<a href="https://segmentfault.com/a/1190000012650596" target="_blank" rel="noopener">MySQL-InnoDB-MVCC多版本并发控制</a>、<a href="https://juejin.im/post/5c9b1b7df265da60e21c0b57" target="_blank" rel="noopener">MySQL事务隔离级别和MVCC</a></li></ul></li><li>……</li></ol><p>《高性能MySQL》上面有一句话这样写到:</p><blockquote><p>不要轻易相信“ MyISAM 比 InnoDB 快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB 的速度都可以让 MyISAM 望尘莫及，尤其是用到了聚簇索引或者需要访问的数据都可以放入内存的应用。</p></blockquote><p>一般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择 MyISAM 也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。</p><h3 id="字符集及校对规则"><a href="#字符集及校对规则" class="headerlink" title="字符集及校对规则"></a>字符集及校对规则</h3><p>字符集指的是一种从二进制编码到某类字符符号的映射。校对规则则是指某种字符集下的排序规则。MySQL 中每一种字符集都会对应一系列的校对规则。</p><p>MySQL 采用的是类似继承的方式指定字符集的默认值，每个数据库以及每张数据表都有自己的默认值，他们逐层继承。比如：某个库中所有表的默认字符集将是该数据库所指定的字符集（这些表在没有指定字符集的情况下，才会采用默认字符集） PS：整理自《 Java 工程师修炼之道》</p><p>详细内容可以参考：<a href="https://www.cnblogs.com/geaozhang/p/6724393.html#MySQLyuzifuji" target="_blank" rel="noopener">MySQL字符集及校对规则的理解</a></p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>MySQL 索引使用的数据结构主要有 <strong>BTree索引</strong> 和 <strong>哈希索引</strong> 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择 BTree 索引。</p><p>MySQL 的 BTree 索引使用的是 B 树中的 B+Tree，但对于主要的两种存储引擎的实现方式是不同的。</p><ul><li><strong>MyISAM：</strong>B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“<strong>非聚簇索引</strong>”。</li><li><strong>InnoDB：</strong>其数据文件本身就是索引文件。相比 MyISAM ，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“<strong>聚簇索引</strong>（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。<strong>在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</strong>PS：整理自《 Java 工程师修炼之道》</li></ul><h3 id="查询缓存的使用"><a href="#查询缓存的使用" class="headerlink" title="查询缓存的使用"></a>查询缓存的使用</h3><blockquote><p>执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用。</p></blockquote><p>my.cnf 加入以下配置，重启 MySQL 开启查询缓存。</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">query_cache_type</span><span class="token punctuation">=</span><span class="token attr-value">1</span><span class="token attr-name">query_cache_size</span><span class="token punctuation">=</span><span class="token attr-value">600000</span></code></pre><p>MySQL 执行以下命令也可以开启查询缓存。</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">set</span> <span class="token attr-value">global  query_cache_type=1;</span><span class="token attr-name">set</span> <span class="token attr-value">global  query_cache_size=600000;</span></code></pre><p>如上，<strong>开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果</strong>。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。因此任何两个查询在任何字符上的不同都会导致缓存不命中。此外，如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。</p><p>缓存建立之后，MySQL的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。</p><p><strong>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。</strong>因此，开启缓存查询要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十MB比较合适。此外，<strong>还可以通过 sql_cache 和 sql_no_cache 来控制某个查询语句是否需要缓存：</strong></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> sql_no_cache <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> usr<span class="token punctuation">;</span></code></pre><h3 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h3><p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p><p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作就是：将小明的余额减少 1000 元，将小红的余额增加 1000 元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p><h3 id="事物的四大特性（ACID）"><a href="#事物的四大特性（ACID）" class="headerlink" title="事物的四大特性（ACID）"></a>事物的四大特性（ACID）</h3><p><img src="https://s1.ax1x.com/2020/04/21/JG3Xyn.png" alt="事物的特性"></p><ol><li><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用。</li><li><strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的。</li><li><strong>隔离性（Isolation）：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。</li><li><strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><h3 id="并发事务带来哪些问题？"><a href="#并发事务带来哪些问题？" class="headerlink" title="并发事务带来哪些问题？"></a>并发事务带来哪些问题？</h3><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p><ul><li><strong>脏读（Dirty read）：</strong>当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li><li><strong>丢失修改（Lost to modify）：</strong>指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务 1 读取某表中的数据 A=20 ，事务 2 也读取 A=20 ，事务 1 修改 A=A-1 ，事务 2 也修改 A=A-1 ，最终结果 A=19 ，事务 1 的修改被丢失。</li><li><strong>不可重复读（Unrepeatable read）：</strong>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li><li><strong>幻读（Phantom read）：</strong>幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li></ul><p><strong>不可重复读和幻读区别：</strong></p><p>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。</p><h3 id="事务隔离级别有哪些？MySQL-的默认隔离级别是？"><a href="#事务隔离级别有哪些？MySQL-的默认隔离级别是？" class="headerlink" title="事务隔离级别有哪些？MySQL 的默认隔离级别是？"></a>事务隔离级别有哪些？MySQL 的默认隔离级别是？</h3><p><strong>SQL 标准定义了四个隔离级别：</strong></p><ul><li><strong>READ-UNCOMMITTED（读取未提交）：</strong>最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li><li><strong>READ-COMMITTED（读取已提交）：</strong>允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li><li><strong>REPEATABLE-READ（可重复读）：</strong>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li><li><strong>SERIALIZABLE（可串行化）：</strong>最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li></ul><hr><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻影读</th></tr></thead><tbody><tr><td align="center">READ-UNCOMMITTED</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">READ-COMMITTED</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">REPEATABLE-READ</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重复读）</strong>。我们可以通过 <code>SELECT @@tx_isolation;</code> 命令来查看</p><pre class=" language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SELECT</span> @<span class="token variable">@tx_isolation</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment" spellcheck="true">-----------------+</span><span class="token operator">|</span> @<span class="token variable">@tx_isolation</span>  <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">-----------------+</span><span class="token operator">|</span> <span class="token keyword">REPEATABLE</span><span class="token operator">-</span><span class="token keyword">READ</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">-----------------+</span></code></pre><blockquote><p>这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 <strong>REPEATABLE-READ（可重复读）</strong>事务隔离级别下使用的是 Next-Key Lock 锁算法，因此<strong>可以避免幻读的产生</strong>，这与其他数据库系统（如 SQL Server）是不同的。所以说 InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重复读）</strong> 已经可以完全保证事务的隔离性要求，即达到了 SQL 标准的 <strong>SERIALIZABLE（可串行化）</strong>隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong>READ-COMMITTED（读取提交内容）</strong> ，但是你要知道的是 InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重复读）</strong> 并不会有任何性能损失。</p></blockquote><p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到 <strong>SERIALIZABLE（可串行化）</strong> 隔离级别。</p><h3 id="锁机制与-InnoDB-锁算法"><a href="#锁机制与-InnoDB-锁算法" class="headerlink" title="锁机制与 InnoDB 锁算法"></a>锁机制与 InnoDB 锁算法</h3><p><strong>MyISAM 和 InnoDB 存储引擎使用的锁：</strong></p><ul><li>MyISAM 采用表级锁（table-level locking）。</li><li>InnoDB 支持行级锁（row-level locking）和表级锁，<strong>默认为行级锁</strong>。</li></ul><p><strong>表级锁和行级锁对比：</strong></p><ul><li><strong>表级锁：</strong>MySQL中锁定 <strong>粒度最大</strong> 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li><li><strong>行级锁：</strong>MySQL 中锁定 <strong>粒度最小</strong> 的一种锁，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。 </li></ul><p>详细内容可以参考：<a href="https://blog.csdn.net/qq_34337272/article/details/80611486" target="_blank" rel="noopener">MySQL锁机制简单了解一下</a></p><p><strong>InnoDB 存储引擎的锁的算法有三种：</strong></p><ul><li>Record lock：单个行记录上的锁。</li><li>Gap lock：间隙锁，锁定一个范围，不包括记录本身。</li><li>Next-key lock：Record + Gap 锁定一个范围，包含记录本身。</li></ul><p><strong>相关知识点：</strong></p><ol><li>InnoDB 对于行的查询使用 Next-key lock 。</li><li>Next-key lock 为了解决 Phantom Problem 幻读问题。</li><li>当查询的索引含有唯一属性时，将 Next-key lock 降级为 Record key 。</li><li>Gap 锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生。</li><li>有两种方式显式关闭 Gap 锁：（除了外键约束和唯一性检查外，其余情况仅使用 Record lock 。） <ul><li>将事务隔离级别设置为RC 。</li><li>将参数 <code>innodb_locks_unsafe_for_binlog</code> 设置为 1 。</li></ul></li></ol><h3 id="MySQL-主从同步原理？"><a href="#MySQL-主从同步原理？" class="headerlink" title="MySQL 主从同步原理？"></a>MySQL 主从同步原理？</h3><p><img src="https://s1.ax1x.com/2020/04/28/J5ba8K.jpg" alt="MySQL 主从同步原理"></p><blockquote><p>前提是作为主服务器角色的数据库服务器必须开启二进制日志。</p></blockquote><p><strong>步骤：</strong></p><ul><li>主服务器上面的任何修改都会通过自己的 I/O Tread（ I/O 线程）保存在二进制日志 <code>Binary log</code> 里面。</li><li>从服务器上面也启动一个 I/O Thread ，通过配置好的用户名和密码, 连接到主服务器上面请求读取二进制日志，然后把读取到的二进制日志写到本地的一个 <code>Realy log</code>（中继日志）里面。</li><li>从服务器上面同时开启一个 SQL Thread 定时检查 <code>Realy log</code>（这个文件也是二进制的），如果发现有更新则立即把更新的内容在本机的数据库上面执行一遍。</li></ul><blockquote><ul><li><p>每个从服务器都会收到主服务器二进制日志的全部内容的副本。</p></li><li><p>从服务器设备负责决定应该执行二进制日志中的哪些语句。</p></li><li><p>除非另行指定，否则主从二进制日志中的所有事件都在从站上执行。</p></li><li><p>如果需要，您可以将从服务器配置为仅处理一些特定数据库或表的事件，但您无法将主服务器配置为仅记录特定事件。</p></li><li><p>每个从站（从服务器）都会记录二进制日志坐标：文件名、文件中它已经从主站读取和处理的位置。</p></li><li><p>由于每个从服务器都分别记录了自己当前处理二进制日志中的位置，因此可以断开从服务器的连接，重新连接然后恢复继续处理。</p></li></ul></blockquote><p><strong>一主多从：</strong></p><p>如果一主多从的话，这时主库既要负责写又要负责为几个从库提供二进制日志。此时可以稍做调整，将二进制日志只给某一从，这一从再开启二进制日志并将自己的二进制日志再发给其它从。或者是干脆这个从不记录，只负责将二进制日志转发给其它从，这样架构起来性能可能要好得多，而且数据之间的延时应该也稍微要好一些。工作原理图如下：</p><p><img src="https://s1.ax1x.com/2020/04/28/J5q9aR.png" alt="一主多从"></p><h3 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a>大表优化</h3><p>当 MySQL 单表记录数过大时，数据库的 CRUD 性能会明显下降，一些常见的优化措施如下：</p><h4 id="1-限定数据的范围"><a href="#1-限定数据的范围" class="headerlink" title="1. 限定数据的范围"></a>1. 限定数据的范围</h4><p>务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。</p><h4 id="2-读-写分离"><a href="#2-读-写分离" class="headerlink" title="2. 读/写分离"></a>2. 读/写分离</h4><p>经典的数据库拆分方案，主库负责写，从库负责读。</p><h4 id="3-垂直分区"><a href="#3-垂直分区" class="headerlink" title="3. 垂直分区"></a>3. 垂直分区</h4><p> <strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p><p> <strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大家应该就更容易理解了。<br> <img src="https://s1.ax1x.com/2020/04/21/JGjmb8.jpg" alt="数据库垂直分区"></p><ul><li><strong>垂直拆分的优点：</strong>可以使得列数据变小，在查询时减少读取的 <strong>Block</strong> 数，减少 I/O 次数。此外，垂直分区可以简化表的结构，易于维护。</li><li><strong>垂直拆分的缺点：</strong>主键会出现冗余，需要管理冗余列，并会引起 <strong>Join</strong> 操作，可以通过在<strong>应用层</strong>进行 Join 来解决。此外，垂直分区会让事务变得更加复杂。</li></ul><h4 id="4-水平分区"><a href="#4-水平分区" class="headerlink" title="4. 水平分区"></a>4. 水平分区</h4><p><strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong> </p><p> 水平拆分是指数据表行的拆分，表的行数超过 200 万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p><p><img src="https://s1.ax1x.com/2020/04/21/JGj4Gd.jpg" alt="数据库水平分区"></p><p>水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升 MySQL 并发能力没有什么意义，所以 <strong>水平拆分最好分库</strong> 。</p><p>水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少</strong>，但 <strong>分片事务难以解决</strong>  ，跨节点 <strong>Join</strong> 性能较差，逻辑复杂。《 Java 工程师修炼之道》的作者推荐 <strong>尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度</strong> ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络 I/O 。</p><p><strong>下面补充一下数据库分片的两种常见方案：</strong></p><ul><li><strong>客户端代理：分片逻辑在应用端，封装在 jar 包中，通过修改或者封装 JDBC 层来实现。</strong>当当网的 <strong>Sharding-JDBC</strong> 、阿里的 <strong>TDDL</strong> 是两种比较常用的实现。</li><li><strong>中间件代理：在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong>我们现在谈的 <strong>Mycat</strong> 、360 的 <strong>Atlas</strong> 、网易的 <strong>DDB</strong> 等等都是这种架构的实现。</li></ul><p>详细内容可以参考：<a href="https://segmentfault.com/a/1190000006158186" target="_blank" rel="noopener">MySQL大表优化方案</a></p><h3 id="解释一下什么是池化设计思想。什么是数据库连接池？为什么需要数据库连接池？"><a href="#解释一下什么是池化设计思想。什么是数据库连接池？为什么需要数据库连接池？" class="headerlink" title="解释一下什么是池化设计思想。什么是数据库连接池？为什么需要数据库连接池？"></a>解释一下什么是池化设计思想。什么是数据库连接池？为什么需要数据库连接池？</h3><p>池化设计应该不是一个新名词。我们常见的如 Java 线程池、JDBC 连接池、Redis 连接池等就是这类设计的代表实现。这种设计会初始预设资源，解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销等。就好比你去食堂打饭，打饭的大妈会先把饭盛好几份放那里，你来了就直接拿着饭盒加菜即可，不用再临时又盛饭又打菜，效率就高了。除了初始化资源，池化设计还包括如下这些特征：池子的初始值、池子的活跃值、池子的最大值等，这些特征可以直接映射到 Java 线程池和数据库连接池的成员属性中。这篇文章对<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485679&idx=1&sn=57dbca8c9ad49e1f3968ecff04a4f735&chksm=cea24724f9d5ce3212292fac291234a760c99c0960b5430d714269efe33554730b5f71208582&token=1141994790&lang=zh_CN#rd" target="_blank" rel="noopener">池化设计思想</a>介绍的还不错，直接复制过来，避免重复造轮子了。</p><p>数据库连接本质就是一个 socket 的连接。数据库服务端还要维护一些缓存和用户权限信息之类的，所以占用了一些内存。我们可以把数据库连接池是看做是维护的数据库连接的缓存，以便将来需要对数据库的请求时可以重用这些连接。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序的请求，既昂贵又浪费资源。<strong>在连接池中，创建连接后，将其放置在池中，并再次使用它，因此不必建立新的连接。如果使用了所有连接，则会建立一个新连接并将其添加到池中</strong>。 连接池还减少了用户必须等待建立与数据库的连接的时间。</p><h3 id="分库分表之后，id-主键如何处理？"><a href="#分库分表之后，id-主键如何处理？" class="headerlink" title="分库分表之后，id 主键如何处理？"></a>分库分表之后，id 主键如何处理？</h3><p>因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来支持。</p><p>生成全局 id 有下面这几种方式：</p><ul><li><strong>UUID：</strong>不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字。</li><li><strong>数据库自增 id ：</strong>两台数据库分别设置不同步长，生成不重复 ID 的策略来实现高可用。这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。</li><li><strong>利用 redis 生成 id ：</strong>性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。</li><li><strong>Twitter 的 SnowFlake 算法：</strong>Github 地址：<a href="https://github.com/twitter-archive/snowflake。" target="_blank" rel="noopener">https://github.com/twitter-archive/snowflake。</a></li><li><strong>美团的 <a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" target="_blank" rel="noopener">Leaf</a> 分布式 ID 生成系统：</strong>Leaf 是美团开源的分布式 ID 生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper 等中间件。感觉还不错。美团技术团队的一篇文章：<a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" target="_blank" rel="noopener">Leaf——美团点评分布式ID生成系统</a>。</li><li>……</li></ul><h3 id="一条SQL语句在MySQL中如何执行的？"><a href="#一条SQL语句在MySQL中如何执行的？" class="headerlink" title="一条SQL语句在MySQL中如何执行的？"></a>一条SQL语句在MySQL中如何执行的？</h3><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN#rd" target="_blank" rel="noopener">一条SQL语句在MySQL中如何执行的？</a></p><h3 id="MySQL高性能优化规范建议"><a href="#MySQL高性能优化规范建议" class="headerlink" title="MySQL高性能优化规范建议"></a>MySQL高性能优化规范建议</h3><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485117&idx=1&sn=92361755b7c3de488b415ec4c5f46d73&chksm=cea24976f9d5c060babe50c3747616cce63df5d50947903a262704988143c2eeb4069ae45420&token=79317275&lang=zh_CN#rd" target="_blank" rel="noopener">MySQL高性能优化规范建议</a></p><h3 id="一条SQL语句执行得很慢的原因有哪些？"><a href="#一条SQL语句执行得很慢的原因有哪些？" class="headerlink" title="一条SQL语句执行得很慢的原因有哪些？"></a>一条SQL语句执行得很慢的原因有哪些？</h3><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485185&idx=1&sn=66ef08b4ab6af5757792223a83fc0d45&chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&token=79317275&lang=zh_CN#rd" target="_blank" rel="noopener">腾讯面试：一条SQL语句执行得很慢的原因有哪些？—不看后悔系列</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大白话带你认识JVM</title>
      <link href="/2020/04/20/hou-duan/jvm/da-bai-hua-dai-ni-ren-shi-jvm/"/>
      <url>/2020/04/20/hou-duan/jvm/da-bai-hua-dai-ni-ren-shi-jvm/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>如果在文中用词或者理解方面出现问题，欢迎指出。此文旨在提及和而不深究，但会尽量效率地把知识点都抛出来。</p></blockquote><h2 id="一、JVM-的基本介绍"><a href="#一、JVM-的基本介绍" class="headerlink" title="一、JVM 的基本介绍"></a>一、JVM 的基本介绍</h2><p>JVM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，一种规范。通过在实际的计算机上仿真模拟各类计算机功能实现···</p><p>好，其实抛开这么专业的句子不说，就知道 JVM 其实就类似于一台小电脑运行在 Windows 或者 Linux 这些操作系统环境下即可。它直接和操作系统进行交互，与硬件不直接交互，可操作系统可以帮我们完成和硬件进行交互的工作。<br><img src="https://s1.ax1x.com/2020/04/20/JQKv5t.png" alt=""></p><h3 id="1-1-Java-文件是如何被运行的"><a href="#1-1-Java-文件是如何被运行的" class="headerlink" title="1.1 Java 文件是如何被运行的"></a>1.1 Java 文件是如何被运行的</h3><p>比如我们现在写了一个 HelloWorld.java 好了，那这个 HelloWorld.java 抛开所有东西不谈，那是不是就类似于一个文本文件，只是这个文本文件它写的都是英文，而且有一定的缩进而已。</p><p>那我们的 <strong>JVM</strong> 是不认识文本文件的，所以它需要一个 <strong>编译</strong> ，让其成为一个它会读二进制文件的 <strong>HelloWorld.class</strong> 。</p><h4 id="①-类加载器"><a href="#①-类加载器" class="headerlink" title="① 类加载器"></a>① 类加载器</h4><p>如果 <strong>JVM</strong> 想要执行这个 <strong>.class</strong> 文件，我们需要将其装进一个 <strong>类加载器</strong> 中，它就像一个搬运工一样，会把所有的 <strong>.class</strong> 文件全部搬进JVM里面来。<br><img src="https://s1.ax1x.com/2020/04/20/JQQ9F1.png" alt=""></p><h4 id="②-方法区"><a href="#②-方法区" class="headerlink" title="② 方法区"></a>② 方法区</h4><p><strong>方法区</strong> 是用于存放类似于元数据信息方面的数据的，比如类信息，常量，静态变量，编译后代码···等，类加载器将 <strong>.class</strong> 文件搬过来就是先丢到这一块上。</p><h4 id="③-堆"><a href="#③-堆" class="headerlink" title="③ 堆"></a>③ 堆</h4><p><strong>堆</strong> 主要放了一些存储的数据，比如对象实例，数组···等，它和方法区都同属于 <strong>线程共享区域</strong> 。也就是说它们都是 <strong>线程不安全</strong> 的。</p><h4 id="④-栈"><a href="#④-栈" class="headerlink" title="④ 栈"></a>④ 栈</h4><p><strong>栈</strong> 这是我们的代码运行空间。我们编写的每一个方法都会放到 <strong>栈</strong> 里面运行。</p><p>我们会听说过 <strong>本地方法栈</strong> 或者 <strong>本地方法接口</strong> 这两个名词，不过我们基本不会涉及这两块的内容，它俩底层是使用 C 来进行工作的，和 Java 没有太大的关系。</p><h4 id="⑤-程序计数器"><a href="#⑤-程序计数器" class="headerlink" title="⑤ 程序计数器"></a>⑤ 程序计数器</h4><p>主要就是完成一个加载工作，类似于一个指针一样的，指向下一行我们需要执行的代码。和栈一样，都是 <strong>线程独享</strong> 的，就是说每一个线程都会有自己对应的一块区域而不会存在并发和多线程的问题。<br><img src="https://s1.ax1x.com/2020/04/20/JQQBlT.png" alt=""></p><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><ol><li>Java文件经过编译后变成 <code>.class</code> 字节码文件。</li><li>字节码文件通过类加载器被搬运到 JVM 虚拟机中。</li><li>虚拟机主要的 5 大块：方法区、堆都为线程共享区域，有线程安全问题，栈、本地方法栈和计数器都是独享区域，不存在线程安全问题，而 JVM 的调优主要就是围绕堆，栈两大块进行。</li></ol><h3 id="1-2-简单的代码例子"><a href="#1-2-简单的代码例子" class="headerlink" title="1.2 简单的代码例子"></a>1.2 简单的代码例子</h3><p>一个简单的 <code>Student</code> 类：<br><img src="https://s1.ax1x.com/2020/04/20/JQQj9P.png" alt="Student 类"></p><p>一个 <code>main()</code> 方法：<br><img src="https://s1.ax1x.com/2020/04/20/JQ1PKO.png" alt="main() 方法"></p><p>执行 <code>main()</code> 方法的步骤如下：</p><ol><li>编译好 App.java 后得到 App.class ，执行 App.class，系统会启动一个 JVM 进程，从 classpath 路径中找到一个名为 App.class 的二进制文件，将 App 的类信息加载到运行时数据区的方法区内，这个过程叫做 App 类的加载。</li><li>JVM 找到 App 的主程序入口，执行 <code>main()</code> 方法。</li><li>这个 <code>main()</code> 中的第一条语句为 <code>Student student = new Student(&quot;tellUrDream&quot;);</code> ，就是让 JVM 创建一个 Student 对象，但是这个时候方法区中是没有 Student 类的信息的，所以 JVM 马上加载 Student 类，把 Student 类的信息放到方法区中</li><li>加载完 Student 类后，JVM 在堆中为一个新的 Student 实例分配内存，然后调用构造函数初始化 Student 实例，这个 Student 实例持有 <strong>指向方法区中的 Student 类的类型信息</strong> 的引用。</li><li>执行 <code>student.sayName();</code> 时，JVM 根据 student 的引用找到 student 对象，然后根据 student 对象持有的引用定位到方法区中 student 类的类型信息的方法表，获得 <code>sayName()</code> 的字节码地址。</li><li>执行 <code>sayName()</code> 。</li></ol><p>其实也不用管太多，只需要知道对象实例初始化时会去方法区中找类信息，完成后再到栈那里去运行方法。找方法就在方法表中找。</p><h2 id="二、类加载器的介绍"><a href="#二、类加载器的介绍" class="headerlink" title="二、类加载器的介绍"></a>二、类加载器的介绍</h2><p>之前也提到了它是负责加载 <code>.class</code> 文件的，它们在文件开头会有特定的文件标示，将 <code>.class</code> 文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构，并且 ClassLoader 只负责 <code>.class</code> 文件的加载，而是否能够运行则由 Execution Engine 来决定。</p><h3 id="2-1-类加载器的流程"><a href="#2-1-类加载器的流程" class="headerlink" title="2.1 类加载器的流程"></a>2.1 类加载器的流程</h3><p>从类被加载到虚拟机内存中开始，到释放内存总共有7个步骤：加载，验证，准备，解析，初始化，使用，卸载。其中<strong>验证，准备，解析三个部分统称为连接</strong>。</p><h4 id="2-1-1-加载"><a href="#2-1-1-加载" class="headerlink" title="2.1.1 加载"></a>2.1.1 加载</h4><ol><li>将class文件加载到内存；</li><li>将静态数据结构转化成方法区中运行时的数据结构；</li><li>在堆中生成一个代表这个类的 <strong>java.lang.Class</strong> 对象作为数据访问的入口。</li></ol><h4 id="2-1-2-链接"><a href="#2-1-2-链接" class="headerlink" title="2.1.2 链接"></a>2.1.2 链接</h4><ol><li>验证：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查。</li><li>准备：为 <code>static</code> 变量在方法区中分配内存空间，设置变量的初始值，例如 <code>static int a = 3;</code> （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）。</li><li>解析：虚拟机将常量池内的符号引用替换为直接引用的过程（比如我现在 <code>import java.util.ArrayList;</code> 这就算符号引用，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行）。</li></ol><h4 id="2-1-3-初始化"><a href="#2-1-3-初始化" class="headerlink" title="2.1.3 初始化"></a>2.1.3 初始化</h4><p>初始化其实就是一个赋值的操作，它会执行一个类构造器的 <code>&lt;clinit&gt;()</code> 方法。由编译器自动收集类中所有变量的赋值动作，此时准备阶段时的那个 <code>static int a = 3;</code> 的例子，在这个时候就正式赋值为 3 。</p><h4 id="2-1-4-卸载"><a href="#2-1-4-卸载" class="headerlink" title="2.1.4 卸载"></a>2.1.4 卸载</h4><p>GC 将无用对象从内存中卸载。</p><h3 id="2-2-类加载器的加载顺序"><a href="#2-2-类加载器的加载顺序" class="headerlink" title="2.2 类加载器的加载顺序"></a>2.2 类加载器的加载顺序</h3><p>加载一个 Class 类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的：</p><ol><li>BootStrap ClassLoader：rt.jar</li><li>Extention ClassLoader：加载扩展的jar包</li><li>App ClassLoader：指定的 classpath 下面的jar包</li><li>Custom ClassLoader：自定义的类加载器</li></ol><h3 id="2-3-双亲委派机制"><a href="#2-3-双亲委派机制" class="headerlink" title="2.3 双亲委派机制"></a>2.3 双亲委派机制</h3><p>当一个类收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父类去完成，比如我现在要 <strong>new</strong> 一个 Person ，这个 Person 是我们自定义的类，如果我们要加载它，就会先委派 App ClassLoader ，只有当父类加载器都反馈自己无法完成这个请求（也就是父类加载器都没有找到加载所需的 Class ）时，子类加载器才会自行尝试加载。</p><p>这样做的好处是，加载位于 rt.jar 包中的类时不管是哪个加载器加载，最终都会委托到 BootStrap ClassLoader 进行加载，这样保证了使用不同的类加载器得到的都是同一个结果。</p><p>其实这个也是一个隔离的作用，避免了我们的代码影响了JDK的代码，比如我现在要来一个：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>sout<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这种时候，我们的代码肯定会报错，因为在加载的时候其实是找到了 rt.jar 中的 String.class ，然后发现这也没有 <code>main()</code> 方法。</p><h2 id="三、运行时数据区"><a href="#三、运行时数据区" class="headerlink" title="三、运行时数据区"></a>三、运行时数据区</h2><h3 id="3-1-本地方法栈和程序计数器"><a href="#3-1-本地方法栈和程序计数器" class="headerlink" title="3.1 本地方法栈和程序计数器"></a>3.1 本地方法栈和程序计数器</h3><p>比如说我们现在点开 Thread 类的源码，会看到它的 <code>start0()</code> 方法带有一个 <strong>native</strong> 关键字修饰，而且不存在方法体，这种用 native 修饰的方法就是<strong>本地方法</strong>，这是使用 C 来实现的，然后一般这些方法都会放到一个叫做本地方法栈的区域。</p><p>程序计数器其实就是一个指针，它指向了我们程序中下一句需要执行的指令，它也是内存区域中唯一一个不会出现 <strong>OutOfMemoryError</strong> 的区域，而且占用内存空间小到基本可以忽略不计。这个内存仅代表当前线程所执行的字节码的行号指示器，字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令。</p><p>如果执行的是 Native 方法，那这个指针就不工作了。</p><h3 id="3-2-方法区"><a href="#3-2-方法区" class="headerlink" title="3.2 方法区"></a>3.2 方法区</h3><p>方法区主要的作用技术存放类的元数据信息，常量和静态变量···等。当它存储的信息过大时，会在无法满足内存分配时报错。</p><h3 id="3-3-虚拟机栈和虚拟机堆"><a href="#3-3-虚拟机栈和虚拟机堆" class="headerlink" title="3.3 虚拟机栈和虚拟机堆"></a>3.3 虚拟机栈和虚拟机堆</h3><p>一句话便是：栈管运行，堆管存储。则虚拟机栈负责运行代码，而虚拟机堆负责存储数据。</p><h4 id="3-3-1-虚拟机栈的概念"><a href="#3-3-1-虚拟机栈的概念" class="headerlink" title="3.3.1 虚拟机栈的概念"></a>3.3.1 虚拟机栈的概念</h4><p>它是 Java 方法执行的内存模型。里面会对局部变量，动态链表，方法出口，栈的操作（入栈和出栈）进行存储，且线程独享。同时如果我们听到局部变量表，那也是在说虚拟机栈。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="3-3-2-虚拟机栈存在的异常"><a href="#3-3-2-虚拟机栈存在的异常" class="headerlink" title="3.3.2 虚拟机栈存在的异常"></a>3.3.2 虚拟机栈存在的异常</h4><p>如果线程请求的栈的深度大于虚拟机栈的最大深度，就会报 <strong>StackOverflowError</strong> （这种错误经常出现在递归中）。Java虚拟机也可以动态扩展，但随着扩展会不断地申请内存，当无法申请足够内存时就会报错 *<em>OutOfMemoryError *</em>。</p><h4 id="3-3-3-虚拟机栈的生命周期"><a href="#3-3-3-虚拟机栈的生命周期" class="headerlink" title="3.3.3 虚拟机栈的生命周期"></a>3.3.3 虚拟机栈的生命周期</h4><p>对于栈来说，不存在垃圾回收。只要程序运行结束，栈的空间自然就会释放了。栈的生命周期和所处的线程是一致的。</p><p>这里补充一句：<strong>8 种基本类型的变量+对象的引用变量+实例方法</strong>都是在栈里面分配内存。</p><h4 id="3-3-4-虚拟机栈的执行"><a href="#3-3-4-虚拟机栈的执行" class="headerlink" title="3.3.4 虚拟机栈的执行"></a>3.3.4 虚拟机栈的执行</h4><p>我们经常说的栈帧数据，说白了在 JVM 中叫栈帧，放到 Java 中其实就是方法，它也是存放在栈中的。</p><blockquote><p>栈中的数据都是以栈帧的格式存在，它是一个关于方法和运行期数据的数据集。比如我们执行一个方法 a ，就会对应产生一个栈帧 A1 ，然后 A1 会被压入栈中。同理方法 b 会有一个 B1 ，方法 c 会有一个 C1 ，等到这个线程执行完毕后，栈会先弹出 C1 ，后 B1 ，A1 。它是一个先进后出，后进先出原则。</p></blockquote><h4 id="3-3-5-局部变量的复用"><a href="#3-3-5-局部变量的复用" class="headerlink" title="3.3.5 局部变量的复用"></a>3.3.5 局部变量的复用</h4><p>局部变量表用于存放方法参数和方法内部所定义的局部变量。它的容量是以 <strong>Slot</strong> 为最小单位，一个 Slot 可以存放 32 位以内的数据类型。</p><blockquote><p>虚拟机通过索引定位的方式使用局部变量表，范围为 [0，局部变量表的 Slot 的数量] 。方法中的参数就会按一定顺序排列在这个局部变量表中，至于怎么排的我们可以先不关心。而为了节省栈帧空间，这些 Slot 是可以复用的，当方法执行位置超过了某个变量，那么这个变量的 Slot 可以被其它变量复用。当然如果需要复用，那我们的垃圾回收自然就不会去动这些内存。</p></blockquote><h4 id="3-3-6-虚拟机堆的概念"><a href="#3-3-6-虚拟机堆的概念" class="headerlink" title="3.3.6 虚拟机堆的概念"></a>3.3.6 虚拟机堆的概念</h4><p>JVM 内存会划分为堆内存和非堆内存，堆内存中也会划分为<strong>年轻代</strong>和<strong>老年代</strong>，而非堆内存则为<strong>永久代</strong>。年轻代又会分为 <strong>Eden</strong> 和 <strong>Survivor</strong> 区。Survivor 也会分为 <strong>FromSurvivor</strong> 和 <strong>ToSurvivor</strong> ，toSurvivor 的 Survivor 区域是空的。Eden，FromSurvivor 和 ToSurvivor 的默认占比为 <strong>8:1:1</strong> 。当然这个东西其实也可以通过一个 <code>-XX:+UsePSAdaptiveSurvivorSizePolicy</code> 参数来根据生成对象的速率动态调整。</p><p>堆内存中存放的是对象，垃圾收集就是收集这些对象然后交给 GC 算法进行回收。非堆内存其实我们已经说过了，就是方法区。在 1.8 中已经移除永久代，替代品是一个元空间（MetaSpace），最大区别是 MetaSpace 是不存在于 JVM 中的，它使用的是本地内存。并有两个参数：</p><pre class=" language-java"><code class="language-java">MetaspaceSize：初始化元空间大小，控制发生GCMaxMetaspaceSize：限制元空间大小上限，防止占用过多物理内存。</code></pre><p>移除的原因可以大致了解一下：融合 HotSpot JVM 和 JRockit VM 而做出的改变，因为 JRockit 是没有永久代的，不过这也间接性地解决了永久代的 OOM 问题。</p><h4 id="3-3-7-Eden-年轻代的介绍"><a href="#3-3-7-Eden-年轻代的介绍" class="headerlink" title="3.3.7 Eden 年轻代的介绍"></a>3.3.7 Eden 年轻代的介绍</h4><p>当我们 <strong>new</strong> 一个对象后，会先放到 <strong>Eden</strong> 划分出来的一块作为存储空间的内存，但是我们知道对堆内存是线程共享的，所以有可能会出现两个对象共用一个内存的情况。这里 JVM 的处理是每个线程都会预先申请好一块连续的内存空间并规定了对象存放的位置，而如果空间不足会再申请多块内存空间。这个操作我们会称作 <strong>TLAB</strong> ，有兴趣可以了解一下。</p><p>当 Eden 空间满了之后，会触发一个叫做 Minor GC（就是一个发生在年轻代的 GC ）的操作，存活下来的对象移动到 Survivor0 区。Survivor0 区满后触发 Minor GC ，就会将存活对象移动到 Survivor1 区，此时还会把 From 和 To 两个指针交换，这样保证了一段时间内总有一个 Survivor 区为空且 To 所指向的 Survivor 区为空。经过多次的 Minor GC 后仍然存活的对象（*<em>这里的存活判断是 15 次，对应到虚拟机参数为 <code>-XX:MaxTenuringThreshold</code> 。为什么是 15 ，因为 HotSpot 会在对象投中的标记字段里记录年龄，分配到的空间仅有 4 位，所以最多只能记录到 15 *</em>）会移动到老年代。老年代是存储长期存活的对象的，占满时就会触发我们最常听说的 Full GC ，期间会停止所有线程等待 GC 的完成。所以对于响应要求高的应用应该尽量去减少发生 Full GC 从而避免响应超时的问题。</p><p>而且当老年区执行了 Full GC 之后仍然无法进行对象保存的操作，就会产生 OOM ，这时候就是虚拟机中的堆内存不足，原因可能会是堆内存设置的大小过小，这个可以通过参数 -Xms、-Xmx 来调整。也可能是代码中创建的对象大且多，而且它们一直在被引用从而长时间垃圾收集无法收集它们。</p><p><img src="https://s1.ax1x.com/2020/04/20/JQbFX9.png" alt="新生代"></p><blockquote><p>补充说明：关于 <code>-XX:TargetSurvivorRatio</code> 参数的问题。其实也不一定是要满足 <code>-XX:MaxTenuringThreshold</code> 才移动到老年代。可以举个例子：如对象年龄 5 的占 30% ，年龄 6 的占 36% ，年龄 7 的占 34% ，加入某个年龄段（如例子中的年龄 6 ）后，总占用超过 Survivor 空间 * TargetSurvivorRatio 的时候，从该年龄段开始及大于的年龄对象就要进入老年代（即例子中的年龄 6 对象，就是年龄 6 和年龄 7 晋升到老年代），这时候无需等到 <code>MaxTenuringThreshold</code> 中要求的15 。</p></blockquote><h4 id="3-3-8-如何判断一个对象需要被干掉"><a href="#3-3-8-如何判断一个对象需要被干掉" class="headerlink" title="3.3.8 如何判断一个对象需要被干掉"></a>3.3.8 如何判断一个对象需要被干掉</h4><p><img src="https://s1.ax1x.com/2020/04/20/JQbb4K.png" alt=""></p><p>图中程序计数器、虚拟机栈、本地方法栈，3 个区域随着线程的生存而生存的。内存分配和回收都是确定的。随着线程的结束内存自然就被回收了，因此不需要考虑垃圾回收的问题。而 Java 堆和方法区则不一样，各线程共享，内存的分配和回收都是动态的。因此垃圾收集器所关注的都是堆和方法这部分内存。</p><p>在进行回收前就要判断哪些对象还存活，哪些已经死去。下面介绍两个基础的计算方法：</p><p>1.<strong>引用计数器</strong>计算：给对象添加一个引用计数器，每次引用这个对象时计数器加一，引用失效时减一，计数器等于 0 时就是不会再次使用的。不过这个方法有一种情况就是出现对象的循环引用时 GC 没法回收。</p><p>2.<strong>可达性分析</strong>计算：这是一种类似于二叉树的实现，将一系列的 GC ROOTS 作为起始的存活对象集，从这个节点往下搜索，搜索所走过的路径成为引用链，把能被该集合引用到的对象加入到集合中。搜索当一个对象到 GC Roots 没有使用任何引用链时，则说明该对象是不可用的。主流的商用程序语言，例如 Java ，C# 等都是靠这招去判定对象是否存活的。</p><p>（了解一下即可）在 Java 语言汇总能作为 GC Roots 的对象分为以下几种：</p><ul><li><p>虚拟机栈（栈帧中的本地方法表）中引用的对象（局部变量）。</p></li><li><p>方法区中静态变量所引用的对象（静态变量）。</p></li><li><p>方法区中常量引用的对象。</p></li><li><p>本地方法栈（即 Native 修饰的方法）中 JNI 引用的对象（ JNI 是 Java 虚拟机调用对应的 C 函数的方式，通过 JNI 函数也可以创建新的 Java 对象。且 JNI 对于对象的局部引用或者全局引用都会把它们指向的对象都标记为不可回收）。</p></li><li><p>已启动的且未终止的 Java 线程。</p></li></ul><p>这种方法的优点是能够解决循环引用的问题，可它的实现需要耗费大量资源和时间，也需要 GC（它的分析过程引用关系不能发生变化，所以需要停止所有进程）。</p><h4 id="3-3-9-如何宣告一个对象的真正死亡"><a href="#3-3-9-如何宣告一个对象的真正死亡" class="headerlink" title="3.3.9 如何宣告一个对象的真正死亡"></a>3.3.9 如何宣告一个对象的真正死亡</h4><p>首先必须要提到的是一个名叫 <strong><code>finalize()</code></strong> 的方法。</p><p><code>finalize()</code> 是 <strong>Object</strong> 类的一个方法、一个对象的 <code>finalize()</code> 方法只会被系统自动调用一次，经过 <code>finalize()</code> 方法逃脱死亡的对象，第二次不会再调用。</p><blockquote><p>补充一句：并不提倡在程序中调用 <code>finalize()</code> 来进行自救。建议忘掉 Java 程序中该方法的存在。因为它执行的时间不确定，甚至是否被执行也不确定（ Java 程序的不正常退出），而且运行代价高昂，无法保证各个对象的调用顺序（甚至有不同线程中调用）。在 Java 9 中已经被标记为 <strong>deprecated</strong> ，且 java.lang.ref.Cleaner（也就是强、软、弱、幻象引用的那一套）中已经逐步替换掉它，会比 <code>finalize()</code> 来的更加的轻量及可靠。</p></blockquote><p>判断一个对象的死亡至少需要两次标记：</p><ol><li>如果对象进行可达性分析之后没发现与 GC Roots 相连的引用链，那它将会第一次标记并且进行一次筛选。判断的条件是决定这个对象是否有必要执行 <code>finalize()</code> 方法。如果对象有必要执行 <code>finalize()</code> 方法，则被放入 <strong>F-Queue</strong> 队列中。</li><li>GC 对 <strong>F-Queue</strong> 队列中的对象进行二次标记。如果对象在 <code>finalize()</code> 方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。</li></ol><p>如果确定对象已经死亡，我们又该如何回收这些垃圾呢？</p><h3 id="3-4-垃圾回收算法"><a href="#3-4-垃圾回收算法" class="headerlink" title="3.4 垃圾回收算法"></a>3.4 垃圾回收算法</h3><p>不会非常详细的展开，常用的有标记清除，复制，标记整理和分代收集算法。</p><h4 id="3-4-1-标记-清除算法"><a href="#3-4-1-标记-清除算法" class="headerlink" title="3.4.1 标记-清除算法"></a>3.4.1 标记-清除算法</h4><p>标记清除算法就是分为“标记”和“清除”两个阶段。标记出所有需要回收的对象，标记结束后统一回收。这个套路很简单，也存在不足，后续的算法都是根据这个基础来加以改进的。</p><p>其实它就是把已死亡的对象标记为空闲内存，然后记录在一个空闲列表中，当我们需要 new 一个对象时，内存管理模块会从空闲列表中寻找空闲的内存来分给新的对象。</p><p>不足的方面就是标记和清除的效率比较低下。且这种做法会让内存中的碎片非常多。这个导致了如果我们需要使用到较大的内存块时，无法分配到足够的连续内存。比如下图：</p><p><img src="https://s1.ax1x.com/2020/04/20/JQq4G8.png" alt="标记-清除算法"></p><p>此时可使用的内存块都是零零散散的，导致了刚刚提到的大内存对象问题。</p><h4 id="3-4-2-复制算法"><a href="#3-4-2-复制算法" class="headerlink" title="3.4.2 复制算法"></a>3.4.2 复制算法</h4><p>为了解决效率问题，复制算法就出现了。它将可用内存按容量划分成两等分，每次只使用其中的一块。和 Survivor 一样也是用 From 和 To 两个指针这样的玩法。FomSurvivor 存满了，就把存活的对象 Copy 到另一块 ToSurvivor 上，然后交换指针的内容。这样就解决了碎片的问题。</p><p>这个算法的代价就是把内存缩水了，这样堆内存的使用效率就会变得十分低下了。</p><p><img src="https://s1.ax1x.com/2020/04/20/JQLBoq.png" alt="复制算法"></p><p>不过它们分配的时候也不是按照 1:1 这样进行分配的，就类似于 Eden 和 Survivor 也不是等价分配是一个道理。</p><h4 id="3-4-3-标记-整理算法"><a href="#3-4-3-标记-整理算法" class="headerlink" title="3.4.3 标记-整理算法"></a>3.4.3 标记-整理算法</h4><p>复制算法在对象存活率高的时候会有一定的效率问题，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。</p><p><img src="https://s1.ax1x.com/2020/04/20/JQOE0s.png" alt="标记-整理算法"></p><h4 id="3-4-4-分代收集算法"><a href="#3-4-4-分代收集算法" class="headerlink" title="3.4.4 分代收集算法"></a>3.4.4 分代收集算法</h4><p>这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。</p><p>说白了就是八仙过海各显神通，具体问题具体分析了而已。</p><h3 id="3-5-各种各样的垃圾回收器（了解）"><a href="#3-5-各种各样的垃圾回收器（了解）" class="headerlink" title="3.5 各种各样的垃圾回收器（了解）"></a>3.5 各种各样的垃圾回收器（了解）</h3><p>HotSpot VM 中的垃圾回收器，以及适用场景：<br><img src="https://s1.ax1x.com/2020/04/20/JQOO3T.png" alt="垃圾回收器"></p><p>到 jdk 1.8 为止，默认的垃圾收集器是 Parallel Scavenge 和 Parallel Old 。</p><p>从 jdk 1.9 开始，G1 收集器成为默认的垃圾收集器。</p><p>目前来看，G1 回收器停顿时间最短而且没有明显缺点，非常适合 Web 应用。在 jdk 1.8 中测试 Web 应用，堆内存 6G ，新生代 4.5G 的情况下，Parallel Scavenge 回收新生代停顿长达 1.5 秒。G1 回收器回收同样大小的新生代只停顿 0.2 秒。</p><h3 id="3-6-JVM-的常用参数（了解）"><a href="#3-6-JVM-的常用参数（了解）" class="headerlink" title="3.6 JVM 的常用参数（了解）"></a>3.6 JVM 的常用参数（了解）</h3><p>JVM的参数非常之多，这里只列举比较重要的几个，通过各种各样的搜索引擎也可以得知这些信息。</p><table><thead><tr><th>参数名称</th><th>含义</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆大小</td><td>物理内存的1/64(&lt;1GB)</td><td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制。</td></tr><tr><td>-Xmx</td><td>最大堆大小</td><td>物理内存的1/4(&lt;1GB)</td><td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。</td></tr><tr><td>-Xmn</td><td>年轻代大小(1.4or lator)</td><td></td><td>注意：此处的大小是（eden+ 2 survivor space)。与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 老年代大小 + 持久代（永久代）大小。增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</td></tr><tr><td>-XX:NewSize</td><td>设置年轻代大小(for 1.3/1.4)</td><td></td><td></td></tr><tr><td>-XX:MaxNewSize</td><td>年轻代最大值(for 1.3/1.4)</td><td></td><td></td></tr><tr><td>-XX:PermSize</td><td>设置持久代(perm gen)初始值</td><td>物理内存的1/64</td><td></td></tr><tr><td>-XX:MaxPermSize</td><td>设置持久代最大值</td><td>物理内存的1/4</td><td></td></tr><tr><td>-Xss</td><td>每个线程的堆栈大小</td><td></td><td>JDK 1.5 以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似，官方文档似乎没有解释，在论坛中有这样一句话:-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了。</td></tr><tr><td>-XX:NewRatio</td><td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td><td></td><td>-XX:NewRatio=4表示年轻代与年老代所占比值为1:4，年轻代占整个堆栈的1/5Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</td></tr><tr><td>-XX:SurvivorRatio</td><td>Eden区与Survivor区的大小比值</td><td></td><td>设置为8，则两个Survivor区与一个Eden区的比值为2:8，一个Survivor区占整个年轻代的1/10。</td></tr><tr><td>-XX:+DisableExplicitGC</td><td>关闭System.gc()</td><td></td><td>这个参数需要严格的测试。</td></tr><tr><td>-XX:PretenureSizeThreshold</td><td>对象超过多大是直接在旧生代分配</td><td>0</td><td>单位字节新生代采用Parallel ScavengeGC时无效，另一种直接在旧生代分配的情况是大的数组对象，且数组中无外部引用对象。</td></tr><tr><td>-XX:ParallelGCThreads</td><td>并行收集器的线程数</td><td></td><td>此值最好配置与处理器数目相等，同样适用于 CMS 。</td></tr><tr><td>-XX:MaxGCPauseMillis</td><td>每次年轻代垃圾回收的最长时间(最大暂停时间)</td><td></td><td>如果无法满足此时间，JVM 会自动调整年轻代大小，以满足此值。</td></tr></tbody></table><p>其实还有一些打印及 CMS 方面的参数，这里就不以一一列举了。</p><h2 id="四、关于JVM调优的一些方面"><a href="#四、关于JVM调优的一些方面" class="headerlink" title="四、关于JVM调优的一些方面"></a>四、关于JVM调优的一些方面</h2><p>根据刚刚涉及的 JVM 的知识点，我们可以尝试对 JVM 进行调优，主要就是堆内存那块。</p><p>所有线程共享数据区大小 = 新生代大小 + 年老代大小 + 永久代大小。永久代一般固定大小为 64m 。所以 Java 堆中增大年轻代后，将会减小年老代大小（因为老年代的清理是使用 Full GC ，所以老年代过小的话反而是会增多 Full GC 的次数）。此值对系统性能影响较大，Sun 官方推荐配置为 Java 堆的 3/8 。</p><h3 id="4-1-调整最大堆内存和最小堆内存"><a href="#4-1-调整最大堆内存和最小堆内存" class="headerlink" title="4.1 调整最大堆内存和最小堆内存"></a>4.1 调整最大堆内存和最小堆内存</h3><p>-Xmx –Xms ：指定 Java 堆最大值（默认值是物理内存的1/4 (&lt;1GB)）和初始 Java 堆最小值（默认值是物理内存的1/64 (&lt;1GB)) 。</p><p>默认（ MinHeapFreeRatio 参数可以调整）空余堆内存小于 40% 时，JVM 就会增大堆直到 -Xmx 的最大限制，默认（ MaxHeapFreeRatio 参数可以调整）空余堆内存大于 70% 时，JVM 会减少堆直到 -Xms 的最小限制。简单点来说，你不停地往堆内存里面丢数据，等它剩余大小小于 40% 了，JVM就会动态申请内存空间不过会小于 -Xmx ，如果剩余大小大于 70% ，又会动态缩小不过不会小于 –Xms 。就这么简单。</p><p>开发过程中，通常会将 -Xms 与 -Xmx 两个参数的配置相同的值，其目的是为了能够在 Java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。</p><p>我们执行下面的代码：</p><pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Xmx="</span> <span class="token operator">+</span> Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">maxMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024.0</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//系统的最大空间</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"free mem="</span> <span class="token operator">+</span> Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">freeMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024.0</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//系统的空闲空间</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"total mem="</span> <span class="token operator">+</span> Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">totalMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024.0</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//当前可用的总空间</span></code></pre><p>注意：此处设置的是 Java 堆大小，也就是新生代大小 + 老年代大小。<br><img src="https://s1.ax1x.com/2020/04/20/JQva90.png" alt=""></p><p>设置一个 <strong>VM options</strong> 的参数：</p><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>Xmx20m <span class="token operator">-</span>Xms5m <span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>PrintGCDetails</code></pre><p><img src="https://s1.ax1x.com/2020/04/20/JQvcNR.png" alt=""></p><p>再次启动 <code>main()</code> 方法：</p><p><img src="https://s1.ax1x.com/2020/04/20/JQvoHH.png" alt=""><br>这里 GC 弹出了一个 Allocation Failure 分配失败，这个事情发生在 PSYoungGen ，也就是年轻代中。</p><p>这时候申请到的内存为 18M ，空闲内存为 4.214195251464844M 。</p><p>我们此时创建一个字节数组看看，执行下面的代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"分配了1M空间给数组"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Xmx="</span> <span class="token operator">+</span> Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">maxMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024.0</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//系统的最大空间</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"free mem="</span> <span class="token operator">+</span> Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">freeMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024.0</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//系统的空闲空间</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"total mem="</span> <span class="token operator">+</span> Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">totalMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024.0</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="https://s1.ax1x.com/2020/04/20/JQvXgf.png" alt=""></p><p>此时 free memory 就又缩水了，不过 total memory 是没有变化的。Java 会尽可能将 total memory 的值维持在最小堆内存大小。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"分配了10M空间给数组"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Xmx="</span> <span class="token operator">+</span> Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">maxMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024.0</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//系统的最大空间</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"free mem="</span> <span class="token operator">+</span> Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">freeMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024.0</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//系统的空闲空间</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"total mem="</span> <span class="token operator">+</span> Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">totalMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024.0</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//当前可用的总空间</span></code></pre><p><img src="https://s1.ax1x.com/2020/04/20/JQxyM8.png" alt=""></p><p>这时候我们创建了一个 10M 的字节数据，这时候最小堆内存是顶不住的。我们会发现现在的 total memory 已经变成了 15M ，这就是已经申请了一次内存的结果。</p><p>此时我们再跑一下这个代码：</p><pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Xmx="</span> <span class="token operator">+</span> Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">maxMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024.0</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//系统的最大空间</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"free mem="</span> <span class="token operator">+</span> Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">freeMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024.0</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//系统的空闲空间</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"total mem="</span> <span class="token operator">+</span> Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">totalMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024.0</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//当前可用的总空间</span></code></pre><p><img src="https://s1.ax1x.com/2020/04/20/JQxHLF.png" alt=""></p><p>此时我们手动执行了一次 Full GC ，此时 total memory 的内存空间又变回 5.5M 了，此时又是把申请的内存释放掉的结果。</p><h3 id="4-2-调整新生代和老年代的比值"><a href="#4-2-调整新生代和老年代的比值" class="headerlink" title="4.2 调整新生代和老年代的比值"></a>4.2 调整新生代和老年代的比值</h3><p>-XX:NewRatio — 新生代（eden+2*Survivor）和老年代（不包含永久区）的比值</p><p>例如：-XX:NewRatio=4，表示新生代 : 老年代=1 : 4，即新生代占整个堆的 1/5 。在 Xms=Xmx 并且设置了 Xmn 的情况下，该参数不需要进行设置。</p><h3 id="4-3-调整-Survivor-区和-Eden-区的比值"><a href="#4-3-调整-Survivor-区和-Eden-区的比值" class="headerlink" title="4.3 调整 Survivor 区和 Eden 区的比值"></a>4.3 调整 Survivor 区和 Eden 区的比值</h3><p>-XX:SurvivorRatio（幸存代）— 设置两个 Survivor 区和 Eden 的比值</p><p>例如：8，表示两个 Survivor : Eden=2 : 8，即一个 Survivor 占年轻代的 1/10 。</p><h3 id="4-4-设置年轻代和老年代的大小"><a href="#4-4-设置年轻代和老年代的大小" class="headerlink" title="4.4 设置年轻代和老年代的大小"></a>4.4 设置年轻代和老年代的大小</h3><p>-XX:NewSize — 设置年轻代大小</p><p>-XX:MaxNewSize — 设置年轻代最大值</p><p>可以通过设置不同参数来测试不同的情况，反正最优解当然就是官方的 Eden 和 Survivor 的占比为 8 : 1 : 1 ，然后在刚刚介绍这些参数的时候都已经附带了一些说明，感兴趣的也可以看看。反正最大堆内存和最小堆内存如果数值不同会导致多次的 GC ，需要注意。</p><h3 id="4-5-小总结"><a href="#4-5-小总结" class="headerlink" title="4.5 小总结"></a>4.5 小总结</h3><p>根据实际事情调整新生代和幸存代的大小，官方推荐新生代占 Java 堆的 3/8 ，幸存代占新生代的 1/10 。</p><p>在 OOM 时，记得 Dump 出堆，确保可以排查现场问题，通过下面命令你可以输出一个 <code>.dump</code> 文件，这个文件可以使用 VisualVM 或者 Java 自带的 Java VisualVM 工具查看。</p><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>Xmx20m <span class="token operator">-</span>Xms5m <span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>HeapDumpOnOutOfMemoryError <span class="token operator">-</span>XX<span class="token operator">:</span>HeapDumpPath<span class="token operator">=</span>你要输出的日志路径</code></pre><p>一般我们也可以通过编写脚本的方式来让 OOM 出现时给我们报个信，可以通过发送邮件或者重启程序等来解决。</p><h3 id="4-6-永久区的设置"><a href="#4-6-永久区的设置" class="headerlink" title="4.6 永久区的设置"></a>4.6 永久区的设置</h3><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XX<span class="token operator">:</span>PermSize <span class="token operator">-</span>XX<span class="token operator">:</span>MaxPermSize</code></pre><p>初始空间（默认为物理内存的 1/64 ）和最大空间（默认为物理内存的 1/4 ）。也就是说，JVM 启动时，永久区一开始就占用了 PermSize 大小的空间，如果空间还不够，可以继续扩展，但是不能超过 MaxPermSize ，否则会 OOM 。</p><blockquote><p>Tips：如果堆空间没有用完也抛出了 OOM ，有可能是永久区导致的。堆空间实际占用非常少，但是永久区溢出 一样抛出 OOM 。</p></blockquote><h3 id="4-7-JVM-的栈参数调优"><a href="#4-7-JVM-的栈参数调优" class="headerlink" title="4.7 JVM 的栈参数调优"></a>4.7 JVM 的栈参数调优</h3><h4 id="4-7-1-调整每个线程栈空间的大小"><a href="#4-7-1-调整每个线程栈空间的大小" class="headerlink" title="4.7.1 调整每个线程栈空间的大小"></a>4.7.1 调整每个线程栈空间的大小</h4><p>可以通过 -Xss ：调整每个线程栈空间的大小</p><p>JDK 1.5 以后每个线程堆栈大小为 1M ，以前每个线程堆栈大小为 256K 。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在 3000~5000 左右。</p><h4 id="4-7-2-设置线程栈的大小"><a href="#4-7-2-设置线程栈的大小" class="headerlink" title="4.7.2 设置线程栈的大小"></a>4.7.2 设置线程栈的大小</h4><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XXThreadStackSize：    设置线程栈的大小<span class="token punctuation">(</span><span class="token number">0</span> means use <span class="token keyword">default</span> stack size<span class="token punctuation">)</span></code></pre><p>这些参数都是可以通过自己编写程序去简单测试的，这里碍于篇幅问题就不再提供 demo 了。</p><h3 id="4-8-JVM-其他参数介绍（可以直接跳过）"><a href="#4-8-JVM-其他参数介绍（可以直接跳过）" class="headerlink" title="4.8 JVM 其他参数介绍（可以直接跳过）"></a>4.8 JVM 其他参数介绍（可以直接跳过）</h3><p>形形色色的参数很多，就不会说把所有都扯个遍了，因为大家其实也不会说一定要去深究到底。</p><h4 id="4-8-1-设置内存页的大小"><a href="#4-8-1-设置内存页的大小" class="headerlink" title="4.8.1 设置内存页的大小"></a>4.8.1 设置内存页的大小</h4><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XXThreadStackSize：    设置内存页的大小，不可设置过大，会影响Perm的大小</code></pre><h4 id="4-8-2-设置原始类型的快速优化"><a href="#4-8-2-设置原始类型的快速优化" class="headerlink" title="4.8.2 设置原始类型的快速优化"></a>4.8.2 设置原始类型的快速优化</h4><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>UseFastAccessorMethods：    设置原始类型的快速优化</code></pre><h4 id="4-8-3-设置关闭手动-GC"><a href="#4-8-3-设置关闭手动-GC" class="headerlink" title="4.8.3 设置关闭手动 GC"></a>4.8.3 设置关闭手动 GC</h4><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>DisableExplicitGC：    设置关闭System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>这个参数需要严格的测试<span class="token punctuation">)</span></code></pre><h4 id="4-8-4-设置垃圾最大年龄"><a href="#4-8-4-设置垃圾最大年龄" class="headerlink" title="4.8.4 设置垃圾最大年龄"></a>4.8.4 设置垃圾最大年龄</h4><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XX<span class="token operator">:</span>MaxTenuringThreshold    设置垃圾最大年龄。如果设置为<span class="token number">0</span>的话<span class="token punctuation">,</span>则年轻代对象不经过Survivor区<span class="token punctuation">,</span>直接进入年老代<span class="token punctuation">.</span>    对于年老代比较多的应用<span class="token punctuation">,</span>可以提高效率。如果将此值设置为一个较大值<span class="token punctuation">,</span>    则年轻代对象会在Survivor区进行多次复制<span class="token punctuation">,</span>这样可以增加对象再年轻代的存活时间<span class="token punctuation">,</span>    增加在年轻代即被回收的概率。该参数只有在串行GC时才有效<span class="token punctuation">.</span></code></pre><h4 id="4-8-5-加快编译速度"><a href="#4-8-5-加快编译速度" class="headerlink" title="4.8.5 加快编译速度"></a>4.8.5 加快编译速度</h4><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>AggressiveOpts</code></pre><h4 id="4-8-6-改善锁机制性能"><a href="#4-8-6-改善锁机制性能" class="headerlink" title="4.8.6 改善锁机制性能"></a>4.8.6 改善锁机制性能</h4><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>UseBiasedLocking</code></pre><h4 id="4-8-7-禁用垃圾回收"><a href="#4-8-7-禁用垃圾回收" class="headerlink" title="4.8.7 禁用垃圾回收"></a>4.8.7 禁用垃圾回收</h4><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>Xnoclassgc</code></pre><h4 id="4-8-8-设置堆空间存活时间"><a href="#4-8-8-设置堆空间存活时间" class="headerlink" title="4.8.8 设置堆空间存活时间"></a>4.8.8 设置堆空间存活时间</h4><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XX<span class="token operator">:</span>SoftRefLRUPolicyMSPerMB    设置每兆堆空闲空间中SoftReference的存活时间，默认值是1s。</code></pre><h4 id="4-8-9-设置对象直接分配在老年代"><a href="#4-8-9-设置对象直接分配在老年代" class="headerlink" title="4.8.9 设置对象直接分配在老年代"></a>4.8.9 设置对象直接分配在老年代</h4><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XX<span class="token operator">:</span>PretenureSizeThreshold    设置对象超过多大时直接在老年代分配，默认值是<span class="token number">0</span>。</code></pre><h4 id="4-8-10-设置-TLAB-占-Eden-区的比例"><a href="#4-8-10-设置-TLAB-占-Eden-区的比例" class="headerlink" title="4.8.10 设置 TLAB 占 Eden 区的比例"></a>4.8.10 设置 TLAB 占 Eden 区的比例</h4><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XX<span class="token operator">:</span>TLABWasteTargetPercent    设置TLAB占eden区的百分比，默认值是<span class="token number">1</span><span class="token operator">%</span> 。 </code></pre><h4 id="4-8-11-设置是否优先-YGC"><a href="#4-8-11-设置是否优先-YGC" class="headerlink" title="4.8.11 设置是否优先 YGC"></a>4.8.11 设置是否优先 YGC</h4><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>CollectGen0First    设置FullGC时是否先YGC，默认值是<span class="token boolean">false</span>。</code></pre><h2 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h2><p>真的扯了很久这东西，参考了多方的资料，有极客时间的《深入拆解虚拟机》和《Java核心技术面试精讲》，也有百度，也有自己在学习的一些线上课程的总结。希望对你有所帮助，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文带你认识类</title>
      <link href="/2020/04/20/hou-duan/jvm/yi-wen-dai-ni-ren-shi-lei/"/>
      <url>/2020/04/20/hou-duan/jvm/yi-wen-dai-ni-ren-shi-lei/</url>
      
        <content type="html"><![CDATA[<h1 id="一文带你认识类"><a href="#一文带你认识类" class="headerlink" title="一文带你认识类"></a>一文带你认识类</h1><p>本文将从类文件结构、类的生命周期、类加载器三个部分带你认识 Java 类。</p><h2 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h2><h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p>在 Java 中，JVM 可以理解的代码就叫做 <code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p><p>Clojure（ Lisp 语言的一种方言）、Groovy、Scala 等语言都是运行在 Java 虚拟机之上。下图展示了不同的语言被不同的编译器编译成 <code>.class</code> 文件最终运行在 Java 虚拟机之上。<code>.class</code> 文件的二进制格式可以使用 <a href="https://www.x-ways.net/winhex/" target="_blank" rel="noopener">WinHex</a> 查看。</p><p><img src="https://s1.ax1x.com/2020/04/19/JMlGWV.png" alt="java虚拟机"></p><p><strong>可以说 <code>.class</code> 文件是不同的语言在 Java 虚拟机之间的重要桥梁，同时也是支持 Java 跨平台很重要的一个原因。</strong></p><h2 id="二-Class-文件结构总结"><a href="#二-Class-文件结构总结" class="headerlink" title="二 Class 文件结构总结"></a>二 Class 文件结构总结</h2><p>根据 Java 虚拟机规范，类文件由单个 ClassFile 结构组成：</p><pre class=" language-java"><code class="language-java">ClassFile <span class="token punctuation">{</span>    u4             magic<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//Class 文件的标志</span>    u2             minor_version<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Class 的小版本号</span>    u2             major_version<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Class 的大版本号</span>    u2             constant_pool_count<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//常量池的数量</span>    cp_info        constant_pool<span class="token punctuation">[</span>constant_pool_count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//常量池</span>    u2             access_flags<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Class 的访问标记</span>    u2             this_class<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当前类</span>    u2             super_class<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//父类</span>    u2             interfaces_count<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//接口</span>    u2             interfaces<span class="token punctuation">[</span>interfaces_count<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//一个类可以实现多个接口</span>    u2             fields_count<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Class 文件的字段属性</span>    field_info     fields<span class="token punctuation">[</span>fields_count<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//一个类会可以有个字段</span>    u2             methods_count<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Class 文件的方法数量</span>    method_info    methods<span class="token punctuation">[</span>methods_count<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//一个类可以有个多个方法</span>    u2             attributes_count<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//此类的属性表中的属性数</span>    attribute_info attributes<span class="token punctuation">[</span>attributes_count<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//属性表集合</span><span class="token punctuation">}</span></code></pre><p>下面详细介绍一下 Class 文件结构涉及到的一些组件。</p><p><strong>Class 文件字节码结构组织示意图：</strong></p><p><img src="https://s1.ax1x.com/2020/04/19/JMltQU.png" alt="类文件字节码结构组织示意图"></p><h3 id="2-1-魔数"><a href="#2-1-魔数" class="headerlink" title="2.1 魔数"></a>2.1 魔数</h3><pre class=" language-java"><code class="language-java">    u4             magic<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//Class 文件的标志</span></code></pre><p>每个 Class 文件的头四个字节称为魔数（Magic Number）,它的唯一作用是<strong>确定这个文件是否为一个能被虚拟机接收的 Class 文件</strong>。 </p><p>程序设计者很多时候都喜欢用一些特殊的数字表示固定的文件类型或者其它特殊的含义。</p><h3 id="2-2-Class-文件版本"><a href="#2-2-Class-文件版本" class="headerlink" title="2.2 Class 文件版本"></a>2.2 Class 文件版本</h3><pre class=" language-java"><code class="language-java">    u2             minor_version<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Class 的小版本号</span>    u2             major_version<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Class 的大版本号</span></code></pre><p>紧接着魔数的四个字节存储的是 Class 文件的版本号：第五和第六是<strong>次版本号</strong>，第七和第八是<strong>主版本号</strong>。</p><p>高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。</p><h3 id="2-3-常量池"><a href="#2-3-常量池" class="headerlink" title="2.3 常量池"></a>2.3 常量池</h3><pre class=" language-java"><code class="language-java">    u2             constant_pool_count<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//常量池的数量</span>    cp_info        constant_pool<span class="token punctuation">[</span>constant_pool_count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//常量池</span></code></pre><p>紧接着主次版本号之后的是常量池，常量池的数量是 constant_pool_count-1（<strong>常量池计数器是从1开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项”</strong>）。</p><p>常量池主要存放两大常量：字面量和符号引用。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量： </p><ul><li>类和接口的全限定名 </li><li>字段的名称和描述符 </li><li>方法的名称和描述符</li></ul><p>常量池中每一项常量都是一个表，这14种表有一个共同的特点：<strong>开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型。</strong></p><table><thead><tr><th align="center">类型</th><th align="center">标志（tag）</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">CONSTANT_utf8_info</td><td align="center">1</td><td align="center">UTF-8编码的字符串</td></tr><tr><td align="center">CONSTANT_Integer_info</td><td align="center">3</td><td align="center">整形字面量</td></tr><tr><td align="center">CONSTANT_Float_info</td><td align="center">4</td><td align="center">浮点型字面量</td></tr><tr><td align="center">CONSTANT_Long_info</td><td align="center">５</td><td align="center">长整型字面量</td></tr><tr><td align="center">CONSTANT_Double_info</td><td align="center">６</td><td align="center">双精度浮点型字面量</td></tr><tr><td align="center">CONSTANT_Class_info</td><td align="center">７</td><td align="center">类或接口的符号引用</td></tr><tr><td align="center">CONSTANT_String_info</td><td align="center">８</td><td align="center">字符串类型字面量</td></tr><tr><td align="center">CONSTANT_Fieldref_info</td><td align="center">９</td><td align="center">字段的符号引用</td></tr><tr><td align="center">CONSTANT_Methodref_info</td><td align="center">10</td><td align="center">类中方法的符号引用</td></tr><tr><td align="center">CONSTANT_InterfaceMethodref_info</td><td align="center">11</td><td align="center">接口中方法的符号引用</td></tr><tr><td align="center">CONSTANT_NameAndType_info</td><td align="center">12</td><td align="center">字段或方法的符号引用</td></tr><tr><td align="center">CONSTANT_MothodType_info</td><td align="center">16</td><td align="center">标志方法类型</td></tr><tr><td align="center">CONSTANT_MethodHandle_info</td><td align="center">15</td><td align="center">表示方法句柄</td></tr><tr><td align="center">CONSTANT_InvokeDynamic_info</td><td align="center">18</td><td align="center">表示一个动态方法调用点</td></tr></tbody></table><p><code>.class</code> 文件可以通过 <code>javap -v class类名</code> 指令来看一下其常量池中的信息（ <code>javap -v  class类名-&gt; temp.txt</code> ：将结果输出到 temp.txt 文件）。</p><h3 id="2-4-访问标志"><a href="#2-4-访问标志" class="headerlink" title="2.4 访问标志"></a>2.4 访问标志</h3><p>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等。</p><p>类访问和属性修饰符：</p><p><img src="https://s1.ax1x.com/2020/04/19/JMlsW6.png" alt="类访问和属性修饰符"></p><p>我们定义了一个 Employee 类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> top<span class="token punctuation">.</span>snailclimb<span class="token punctuation">.</span>bean<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>通过 <code>javap -v class类名</code> 指令来看一下类的访问标志：</p><p><img src="https://s1.ax1x.com/2020/04/19/JM1ClT.png" alt="查看类的访问标志"></p><h3 id="2-5-当前类索引，父类索引与接口索引集合"><a href="#2-5-当前类索引，父类索引与接口索引集合" class="headerlink" title="2.5 当前类索引，父类索引与接口索引集合"></a>2.5 当前类索引，父类索引与接口索引集合</h3><pre class=" language-java"><code class="language-java">    u2             this_class<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当前类</span>    u2             super_class<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//父类</span>    u2             interfaces_count<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//接口</span>    u2             interfaces<span class="token punctuation">[</span>interfaces_count<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//一个类可以实现多个接口</span></code></pre><p><strong>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0 。</strong></p><p><strong>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 <code>implements</code>（如果这个类本身是接口的话则是 <code>extends</code> ）后的接口顺序从左到右排列在接口索引集合中。</strong></p><h3 id="2-6-字段表集合"><a href="#2-6-字段表集合" class="headerlink" title="2.6 字段表集合"></a>2.6 字段表集合</h3><pre class=" language-java"><code class="language-java">    u2             fields_count<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Class 文件的字段的个数</span>    field_info     fields<span class="token punctuation">[</span>fields_count<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//一个类会可以有个字段</span></code></pre><p>字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</p><p><strong>field info（字段表）的结构：</strong></p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="字段表的结构 "></p><ul><li><strong>access_flags：</strong>字段的作用域（ <code>public</code> ，<code>private</code> ，<code>protected</code> 修饰符），是实例变量还是类变量（ <code>static</code> 修饰符），可否被序列化（ <code>transient</code> 修饰符），可变性（ <code>final</code> ），可见性（ <code>volatile</code> 修饰符，是否强制从主内存读写）。</li><li><strong>name_index：</strong>对常量池的引用，表示的字段的名称。</li><li><strong>descriptor_index：</strong>对常量池的引用，表示字段和方法的描述符。</li><li><strong>attributes_count：</strong>一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数。</li><li><strong>attributes[attributes_count]：</strong>存放具体属性具体内容。</li></ul><p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。</p><p><strong>字段的 access_flags 的取值：</strong></p><p><img src="https://s1.ax1x.com/2020/04/19/JM1OgK.png" alt="字段的 access_flags 的取值"></p><h3 id="2-7-方法表集合"><a href="#2-7-方法表集合" class="headerlink" title="2.7 方法表集合"></a>2.7 方法表集合</h3><pre class=" language-java"><code class="language-java">    u2             methods_count<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Class 文件的方法的数量</span>    method_info    methods<span class="token punctuation">[</span>methods_count<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//一个类可以有个多个方法</span></code></pre><p>methods_count 表示方法的数量，而 method_info 表示的方法表。</p><p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。 </p><p><strong>method_info（方法表）的结构：</strong></p><p><img src="https://s1.ax1x.com/2020/04/19/JM3kgf.png" alt="方法表的结构"></p><p><strong>方法表的 access_flag 取值：</strong></p><p><img src="https://s1.ax1x.com/2020/04/19/JM3Yb4.png" alt="方法表的 access_flag 取值"></p><p>注意：因为 <code>volatile</code> 修饰符和 <code>transient</code> 修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了 <code>synchronized</code> 、<code>native</code> 、<code>abstract</code> 等关键字修饰方法，所以也就多了这些关键字对应的标志。</p><h3 id="2-8-属性表集合"><a href="#2-8-属性表集合" class="headerlink" title="2.8 属性表集合"></a>2.8 属性表集合</h3><pre class=" language-java"><code class="language-java">   u2             attributes_count<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//此类的属性表中的属性数</span>   attribute_info attributes<span class="token punctuation">[</span>attributes_count<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//属性表集合</span></code></pre><p>在 Class 文件、字段表、方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p>一个类的完整生命周期如下：</p><p><img src="https://s1.ax1x.com/2020/04/19/JM8wwQ.png" alt="类的生命周期"></p><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？</p><p>系统加载 Class 类型的文件主要三步：<strong>加载 -&gt; 连接 -&gt; 初始化</strong>。连接过程又可分为三步：<strong>验证 -&gt; 准备 -&gt; 解析</strong>。</p><p><img src="https://s1.ax1x.com/2020/04/19/JM8fw4.png" alt="类加载过程"></p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>类加载过程的第一步，主要完成下面3件事情：</p><ol><li>通过全类名获取定义此类的二进制字节流；</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构；</li><li>在内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口。</li></ol><blockquote><p>虚拟机规范上面这 3 点并不具体，因此是非常灵活的。比如：”通过全类名获取定义此类的二进制字节流” 并没有指明具体从哪里获取、怎样获取。比如：比较常见的就是从 ZIP 包中读取（日后出现的 JAR、EAR、WAR格式的基础）、其他文件生成（典型应用就是 JSP ）等。</p></blockquote><p><strong>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</strong></p><p>类加载器、双亲委派模型也是非常重要的知识点，这部分内容会在后面的文章中单独介绍到。</p><p>加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p><img src="https://s1.ax1x.com/2020/04/19/JMGOg0.png" alt="验证阶段"></p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><ol><li>这时候进行内存分配的仅包括类变量（ <code>static</code> ），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li><li>这里所设置的初始值”通常情况”下是数据类型默认的零值（如 0、0L、null、false 等），比如我们定义了 <code>public static int value = 111;</code> ，那么 value 变量在准备阶段的初始值就是 0 而不是 111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 fianl 关键字 <code>public static final int value = 111;</code> ，那么准备阶段 value 的值就被赋值为 111 。</li></ol><p><strong>基本数据类型的零值：</strong></p><p><img src="https://s1.ax1x.com/2020/04/19/JMJa5j.png" alt="基本数据类型的零值"></p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机<strong>将常量池内的符号引用替换为直接引用</strong>的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。</p><p><strong>符号引用</strong>就是一组符号来描述目标，可以是任何字面量。<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方发表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p><p>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码（字节码），初始化阶段是执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程。</p><p>对于 <code>&lt;clinit&gt;()</code> 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <code>&lt;clinit&gt;()</code> 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起死锁，并且这种死锁很难被发现。</p><p>对于初始化阶段，虚拟机严格规范了有且只有 5 种情况下，必须对类进行初始化（只有主动去使用类才会初始化类）：</p><ol><li>当遇到 <strong>new 、 getstatic、putstatic 或 invokestatic</strong> 这4条直接码指令时，比如 new 一个类，读取一个静态字段（未被 final 修饰）或调用一个类的静态方法时。<ul><li>当 jvm 执行 new 指令时会初始化类。即当程序创建一个类的实例对象。</li><li>当 jvm 执行 getstatic 指令时会初始化类。即程序访问类的静态变量（不是静态常量，常量会被加载到运行时常量池）。</li><li>当 jvm 执行 putstatic 指令时会初始化类。即程序给类的静态变量赋值。</li><li>当 jvm 执行 invokestatic 指令时会初始化类。即程序调用类的静态方法。</li></ul></li><li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时如 <code>Class.forname(&quot;...&quot;)</code> ，<code>newInstance()</code> 等。 如果类没初始化，需要触发其初始化。</li><li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li><li>当虚拟机启动时，用户需要定义一个要执行的主类（包含 <code>main()</code> 方法的那个类），虚拟机会先初始化这个类。</li><li><strong>MethodHandle</strong> 和 <strong>VarHandle</strong> 可以看作是轻量级的反射调用机制，而要想使用这2个调用，就必须先使用 <strong>findStaticVarHandle</strong> 来初始化要调用的类。</li></ol><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>卸载类即该类的Class对象被 GC 。</p><p>卸载类需要满足 3 个要求：</p><ol><li>该类的所有的实例对象都已被 GC ，也就是说堆不存在该类的实例对象。</li><li>该类没有在其他任何地方被引用。</li><li>该类的类加载器的实例已被 GC 。</li></ol><p>所以，在 JVM 生命周期类，由 JVM 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p><blockquote><p>只要想通一点就好了，jdk 自带的 BootstrapClassLoader ，PlatformClassLoader ，AppClassLoader 负责加载 jdk 提供的类，所以它们（类加载器的实例）肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p></blockquote><h2 id="类加载器总结"><a href="#类加载器总结" class="headerlink" title="类加载器总结"></a>类加载器总结</h2><p>JVM 中内置了三个重要的 ClassLoader ，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自 <code>java.lang.ClassLoader</code> ：</p><ol><li><strong>BootstrapClassLoader（启动类加载器）：</strong>最顶层的加载类，由 C++ 实现，负责加载 <code>%JAVA_HOME%/lib</code> 目录下的 jar 包和类或者或被 <code>-Xbootclasspath</code> 参数指定的路径中的所有类。</li><li><strong>ExtensionClassLoader（扩展类加载器）：</strong>主要负责加载目录 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的 jar 包。</li><li><strong>AppClassLoader（应用程序类加载器）：</strong>面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li></ol><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><h3 id="双亲委派模型介绍"><a href="#双亲委派模型介绍" class="headerlink" title="双亲委派模型介绍"></a>双亲委派模型介绍</h3><p>每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 <strong>双亲委派模型</strong> 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的 <code>loadClass()</code> 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器。</p><p><img src="https://s1.ax1x.com/2020/04/19/JMYOmT.png" alt="双亲委派模型"></p><p>每个类加载都有一个父类加载器，我们通过下面的程序来验证。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassLoaderDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ClassLodarDemo's ClassLoader is "</span> <span class="token operator">+</span> ClassLoaderDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The Parent of ClassLodarDemo's ClassLoader is "</span> <span class="token operator">+</span> ClassLoaderDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The GrandParent of ClassLodarDemo's ClassLoader is "</span> <span class="token operator">+</span> ClassLoaderDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Output：</p><pre class=" language-java"><code class="language-java">ClassLodarDemo's ClassLoader is sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Launcher$AppClassLoader<span class="token annotation punctuation">@18b4aac2</span>The Parent of ClassLodarDemo's ClassLoader is sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Launcher$ExtClassLoader<span class="token annotation punctuation">@1b6d3586</span>The GrandParent of ClassLodarDemo's ClassLoader is null</code></pre><p><strong><code>AppClassLoader</code></strong> 的父类加载器为 <strong><code>ExtClassLoader</code></strong> 。<br><strong><code>ExtClassLoader</code></strong> 的父类加载器为 <strong>null</strong> ，<strong>null 并不代表 <code>ExtClassLoader</code> 没有父类加载器，而是 <code>BootstrapClassLoader</code></strong> 。</p><p>其实这个双亲翻译得容易让别人误解，我们一般理解的双亲都是父母，这里的双亲更多地表达的是“父母这一辈”的人而已，并不是说真的有一个 Mother ClassLoader 和一个 Father ClassLoader 。另外，类加载器之间的“父子”关系也不是通过继承来体现的，是由“优先级”来决定。官方API文档对这部分的描述如下:</p><blockquote><p>The Java platform uses a delegation model for loading classes. <strong>The basic idea is that every class loader has a “parent” class loader.</strong> When loading a class, a class loader first “delegates” the search for the class to its parent class loader before attempting to find the class itself.</p></blockquote><h3 id="双亲委派模型实现源码分析"><a href="#双亲委派模型实现源码分析" class="headerlink" title="双亲委派模型实现源码分析"></a>双亲委派模型实现源码分析</h3><p>双亲委派模型的实现代码非常简单，逻辑非常清晰，都集中在 <code>java.lang.ClassLoader</code> 的 <code>loadClass()</code> 中，相关代码如下所示。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> ClassLoader parent<span class="token punctuation">;</span> <span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span>        <span class="token keyword">throws</span> ClassNotFoundException    <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 首先，检查请求的类是否已经被加载过</span>            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">long</span> t0 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//父加载器不为空，调用父加载器loadClass()方法处理</span>                        c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//父加载器为空，使用启动类加载器 BootstrapClassLoader 加载</span>                        c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token comment" spellcheck="true">//抛出异常说明父类加载器无法完成加载请求</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">long</span> t1 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//自己尝试加载</span>                    c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// this is the defining class loader; record the stats</span>                    sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>PerfCounter<span class="token punctuation">.</span><span class="token function">getParentDelegationTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addTime</span><span class="token punctuation">(</span>t1 <span class="token operator">-</span> t0<span class="token punctuation">)</span><span class="token punctuation">;</span>                    sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>PerfCounter<span class="token punctuation">.</span><span class="token function">getFindClassTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addElapsedTimeFrom</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>                    sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>PerfCounter<span class="token punctuation">.</span><span class="token function">getFindClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> c<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h3 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="双亲委派模型的好处"></a>双亲委派模型的好处</h3><p>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（ JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>Object</code> 类。</p><h3 id="如果我们不想用双亲委派模型怎么办？"><a href="#如果我们不想用双亲委派模型怎么办？" class="headerlink" title="如果我们不想用双亲委派模型怎么办？"></a>如果我们不想用双亲委派模型怎么办？</h3><p>为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重写 <code>loadClass()</code> 即可。</p><blockquote><p>双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的 API ，但世事往往没有绝对的完美，如果基础类又要调用回用户的代码，那该怎么办？</p><p>这并非是不可能的事情，一个典型的例子便是 JNDI 服务，JNDI 现在已经是 Java 的标准服务，它的代码由启动类加载器去加载（在 JDK 1.3 时放进去的 rt.jar ），但 JNDl 的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的 ClassPath 下的 JNDI 接口提供者（SPI，Service Provider Interface）的代码，但启动类加载器不可能“认识”这些代码啊！那该怎么办？</p><p>为了解决这个问题，Java 设计团队只好引入了一个不太优雅的设计：<strong>线程上下文类加载器</strong>（Thread Context ClassLoader）。JNDI 服务使用这个线程上下文类加载器去加载所需要的 SPI 代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java 中所有涉及 SPl 的加载动作基本上都采用这种方式，例如 <strong>JNDI、JDBC、JCE、JAXB 和 JBI</strong> 等。</p></blockquote><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>除了 <code>BootstrapClassLoader</code> 其他类加载器均由 Java 实现且全部继承自 <code>java.lang.ClassLoader</code> 。如果我们要自定义自己的类加载器，很明显需要继承 <code>ClassLoader</code> 。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html</a></li><li><a href="https://coolshell.cn/articles/9229.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9229.html</a></li><li><a href="https://blog.csdn.net/luanlouis/article/details/39960815" target="_blank" rel="noopener">https://blog.csdn.net/luanlouis/article/details/39960815</a></li><li><a href="https://blog.csdn.net/xyang81/article/details/7292380" target="_blank" rel="noopener">https://blog.csdn.net/xyang81/article/details/7292380</a></li><li><a href="https://juejin.im/post/5c04892351882516e70dcc9b" target="_blank" rel="noopener">https://juejin.im/post/5c04892351882516e70dcc9b</a></li><li><a href="http://gityuan.com/2016/01/24/java-classloader" target="_blank" rel="noopener">http://gityuan.com/2016/01/24/java-classloader</a></li><li>《深入理解Java虚拟机》</li><li>《实战 Java 虚拟机》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM参数指南</title>
      <link href="/2020/04/19/hou-duan/jvm/jvm-can-shu-zhi-nan/"/>
      <url>/2020/04/19/hou-duan/jvm/jvm-can-shu-zhi-nan/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>在本篇文章中，你将掌握最常用的 JVM 参数配置。</p><h2 id="2-堆内存相关"><a href="#2-堆内存相关" class="headerlink" title="2.堆内存相关"></a>2.堆内存相关</h2><blockquote><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p></blockquote><h3 id="2-1-显式指定堆内存-–Xms-和-Xmx"><a href="#2-1-显式指定堆内存-–Xms-和-Xmx" class="headerlink" title="2.1.显式指定堆内存 –Xms 和 -Xmx"></a>2.1.显式指定堆内存 <code>–Xms</code> 和 <code>-Xmx</code></h3><p>与性能有关的最常见实践之一是根据应用程序要求初始化堆内存。如果我们需要指定最小和最大堆大小（推荐显示指定大小），以下参数可以帮助你实现：</p><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>Xms<span class="token operator">&lt;</span>heap size<span class="token operator">></span><span class="token punctuation">[</span>unit<span class="token punctuation">]</span> <span class="token operator">-</span>Xmx<span class="token operator">&lt;</span>heap size<span class="token operator">></span><span class="token punctuation">[</span>unit<span class="token punctuation">]</span></code></pre><ul><li><strong>heap size</strong> 表示要初始化内存的具体大小。</li><li><strong>unit</strong> 表示要初始化内存的单位。单位为<strong><em>“ g”</em></strong> (GB) 、<strong><em>“ m”</em></strong>（MB）、<strong><em>“ k”</em></strong>（KB）。</li></ul><p>举个栗子🌰，如果我们要为 JVM 分配最小 2 GB 和最大 5 GB 的堆内存大小，我们的参数应该这样来写：</p><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>Xms2G <span class="token operator">-</span>Xmx5G</code></pre><h3 id="2-2-显式新生代内存（Young-Ceneration）"><a href="#2-2-显式新生代内存（Young-Ceneration）" class="headerlink" title="2.2.显式新生代内存（Young Ceneration）"></a>2.2.显式新生代内存（Young Ceneration）</h3><p>根据<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html" target="_blank" rel="noopener">Oracle官方文档</a>，在堆总可用内存配置完成之后，第二大影响因素是为 <code>Young Generation</code> 在堆内存所占的比例。默认情况下，YG 的最小大小为 1310 MB，最大大小为<strong>无限制</strong>。</p><p>一共有两种指定新生代内存（Young Ceneration）大小的方法：</p><p><strong>1.通过 <code>-XX:NewSize</code> 和 <code>-XX:MaxNewSize</code> 指定</strong></p><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XX<span class="token operator">:</span>NewSize<span class="token operator">=</span><span class="token operator">&lt;</span>young size<span class="token operator">></span><span class="token punctuation">[</span>unit<span class="token punctuation">]</span> <span class="token operator">-</span>XX<span class="token operator">:</span>MaxNewSize<span class="token operator">=</span><span class="token operator">&lt;</span>young size<span class="token operator">></span><span class="token punctuation">[</span>unit<span class="token punctuation">]</span></code></pre><p>举个栗子🌰，如果我们要为新生代分配最小 256m 的内存，最大 1024m 的内存我们的参数应该这样来写：</p><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XX<span class="token operator">:</span>NewSize<span class="token operator">=</span>256m<span class="token operator">-</span>XX<span class="token operator">:</span>MaxNewSize<span class="token operator">=</span>1024m</code></pre><p><strong>2.通过 <code>-Xmn&lt;young size&gt;[unit]</code> 指定</strong></p><p>举个栗子🌰，如果我们要为新生代分配 256m 的内存（ NewSize 与 MaxNewSize 设为一致），我们的参数应该这样来写：</p><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>Xmn256m </code></pre><p>GC 调优策略中很重要的一条经验总结是这样说的：</p><blockquote><p>将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC ，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过 “-Xmn” 命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。</p></blockquote><p>另外，你还可以通过 <strong><code>-XX:NewRatio=&lt;int&gt;</code></strong> 来设置新生代和老年代内存的比值。</p><p>比如下面的参数就是设置新生代（包括 Eden 和两个 Survivor 区）与老年代的比值为 1 。也就是说：新生代与老年代所占比值为 1 : 1 ，新生代占整个堆栈的 1/2 。</p><pre><code>-XX:NewRatio=1</code></pre><h3 id="2-3-显示指定永久代-元空间的大小"><a href="#2-3-显示指定永久代-元空间的大小" class="headerlink" title="2.3.显示指定永久代/元空间的大小"></a>2.3.显示指定永久代/元空间的大小</h3><p><strong>从 Java 8 开始，如果我们没有指定 Metaspace 的大小，随着更多类的创建，虚拟机会耗尽所有可用的系统内存（永久代并不会出现这种情况）。</strong></p><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小：</p><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XX<span class="token operator">:</span>PermSize<span class="token operator">=</span>N <span class="token comment" spellcheck="true">//方法区 (永久代) 初始大小</span><span class="token operator">-</span>XX<span class="token operator">:</span>MaxPermSize<span class="token operator">=</span>N <span class="token comment" spellcheck="true">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></code></pre><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p><p><strong>JDK 1.8 的时候，方法区（ HotSpot 的永久代）被彻底移除了（ JDK 1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</strong></p><p>下面是一些常用参数：</p><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XX<span class="token operator">:</span>MetaspaceSize<span class="token operator">=</span>N <span class="token comment" spellcheck="true">//设置 Metaspace 的初始（和最小大小）</span><span class="token operator">-</span>XX<span class="token operator">:</span>MaxMetaspaceSize<span class="token operator">=</span>N <span class="token comment" spellcheck="true">//设置 Metaspace 的最大大小，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</span></code></pre><h2 id="3-垃圾收集相关"><a href="#3-垃圾收集相关" class="headerlink" title="3.垃圾收集相关"></a>3.垃圾收集相关</h2><h3 id="3-1-垃圾回收器"><a href="#3-1-垃圾回收器" class="headerlink" title="3.1.垃圾回收器"></a>3.1.垃圾回收器</h3><p>为了提高应用程序的稳定性，选择正确的<a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" target="_blank" rel="noopener">垃圾收集</a>算法至关重要。</p><p>JVM 具有四种类型的 <strong>GC</strong> 实现：</p><ul><li>串行垃圾收集器</li><li>并行垃圾收集器</li><li>CMS垃圾收集器</li><li>G1垃圾收集器</li></ul><p>可以使用以下参数声明这些实现：</p><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>UseSerialGC<span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>UseParallelGC<span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>USeParNewGC<span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>UseG1GC</code></pre><p>有关<strong>垃圾回收</strong>实施的更多详细信息，请参见<a href="https://www.niewenjun.com/2020/04/19/hou-duan/jvm/jvm-la-ji-hui-shou">此处</a>。</p><h3 id="3-2-GC-记录"><a href="#3-2-GC-记录" class="headerlink" title="3.2. GC 记录"></a>3.2. GC 记录</h3><p>为了严格监控应用程序的运行状况，我们应该始终检查 JVM 的垃圾回收性能。最简单的方法是以人类可读的格式记录 GC 活动。</p><p>使用以下参数，我们可以记录 GC 活动：</p><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>UseGCLogFileRotation <span class="token operator">-</span>XX<span class="token operator">:</span>NumberOfGCLogFiles<span class="token operator">=</span><span class="token operator">&lt;</span> number of log files <span class="token operator">></span> <span class="token operator">-</span>XX<span class="token operator">:</span>GCLogFileSize<span class="token operator">=</span><span class="token operator">&lt;</span> file size <span class="token operator">></span><span class="token punctuation">[</span> unit <span class="token punctuation">]</span><span class="token operator">-</span>Xloggc<span class="token operator">:</span><span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token operator">/</span>gc<span class="token punctuation">.</span>log</code></pre><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.jianshu.com/p/832fc4d4cb53" target="_blank" rel="noopener">CMS GC 默认新生代是多大？</a></li><li><a href="https://www.cnblogs.com/hongdada/p/10277782.html" target="_blank" rel="noopener">CMS GC启动参数优化配置</a></li><li><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html" target="_blank" rel="noopener">从实际案例聊聊Java应用的GC优化-美团技术团队</a></li><li><a href="https://www.choupangxia.com/2019/11/11/interview-jvm-gc-08/" target="_blank" rel="noopener">JVM性能调优详解</a> （2019-11-11）</li><li><a href="https://segmentfault.com/a/1190000010603813" target="_blank" rel="noopener">JVM参数使用手册</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾回收</title>
      <link href="/2020/04/19/hou-duan/jvm/jvm-la-ji-hui-shou/"/>
      <url>/2020/04/19/hou-duan/jvm/jvm-la-ji-hui-shou/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM-垃圾回收"><a href="#JVM-垃圾回收" class="headerlink" title="JVM 垃圾回收"></a>JVM 垃圾回收</h1><h3 id="本文导火索"><a href="#本文导火索" class="headerlink" title="本文导火索"></a>本文导火索</h3><p><img src="https://s1.ax1x.com/2020/04/19/JKCqoj.png" alt="导火索"></p><p>当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p><h2 id="1-揭开-JVM-内存分配与回收的神秘面纱"><a href="#1-揭开-JVM-内存分配与回收的神秘面纱" class="headerlink" title="1  揭开 JVM 内存分配与回收的神秘面纱"></a>1  揭开 JVM 内存分配与回收的神秘面纱</h2><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代，再细致一点有：<strong>Eden 空间、From Survivor、To Survivor 空间</strong>等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><p><strong>堆空间的基本结构：</strong></p><p><img src="https://s1.ax1x.com/2020/04/19/JKNWAe.png" alt="堆空间的基本结构"></p><p><strong>上图所示的 eden 区、s0（”From”）区、s1（”To”）区都属于新生代，tentired 区属于老年代。</strong></p><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加  1（ Eden 区 -&gt; Survivor 区后对象的初始年龄变为 1），当它的年龄增加到一定程度（默认为 <strong>15</strong> 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><p>经过这次GC后，Eden 区和 “From” 区已经被清空。这个时候，”From” 和 “To” 会交换他们的角色，也就是新的 “To” 就是上次 GC 前的 “From” ，新的 “From” 就是上次 GC 前的 “To” 。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到 “To” 区被填满，”To” 区被填满之后，会将所有对象移动到老年代中。</p><p><img src="https://s1.ax1x.com/2020/04/19/JKiPjf.png" alt="堆内存常见分配策略"></p><h3 id="1-1-对象优先在-Eden-区分配"><a href="#1-1-对象优先在-Eden-区分配" class="headerlink" title="1.1 对象优先在 Eden 区分配"></a>1.1 对象优先在 Eden 区分配</h3><p>目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。下面我们来进行实际测试一下。</p><p>在测试之前我们先来看看 <strong>Minor GC 和 Full GC 有什么不同呢？</strong></p><ul><li><strong>新生代 GC（Minor GC）：</strong>指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</li><li><strong>老年代 GC（Major GC/Full GC）：</strong>指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</li></ul><blockquote><p><a href="https://github.com/Snailclimb/JavaGuide/issues/664" target="_blank" rel="noopener">issue#664 </a> : <strong><a href="https://github.com/guang19" target="_blank" rel="noopener">guang19</a></strong> 补充：个人在网上查阅相关资料的时候发现如题所说的观点。有的文章说 Full GC与Major GC一样是属于对老年代的GC，也有的文章说 Full GC 是对整个堆区的GC，所以这点需要各位同学自行分辨Full GC语义。见：<a href="https://www.zhihu.com/question/41922036" target="_blank" rel="noopener">知乎讨论</a></p></blockquote><p><strong>测试：</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GCTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation1<span class="token punctuation">,</span> allocation2<span class="token punctuation">;</span>        allocation1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">30900</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//allocation2 = new byte[900*1024];</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>通过以下方式运行：<br><img src="https://s1.ax1x.com/2020/04/19/JKiBDO.png" alt="运行方式"></p><p>添加的参数：<code>-XX:+PrintGCDetails</code><br><img src="https://s1.ax1x.com/2020/04/19/JKi4r8.png" alt="添加参数"></p><p>运行结果（红色字体描述有误，应该是对应于 JDK 1.7 的永久代）：</p><p><img src="https://s1.ax1x.com/2020/04/19/JKijMV.png" alt="运行结果"></p><p>从上图我们可以看出 Eden 区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用 2000 多 k 内存）。假如我们再为 allocation2 分配内存会出现什么情况呢？</p><pre class=" language-java"><code class="language-java">allocation2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">900</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p><img src="https://s1.ax1x.com/2020/04/19/JKFFR1.png" alt="运行结果"></p><p><strong>简单解释一下为什么会出现这种情况：</strong> 因为给 allocation2 分配内存的时候 Eden 区内存几乎已经被分配完了，我们刚刚讲了当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 <strong>分配担保机制</strong> 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 Eden 区的话，还是会在 Eden 区分配内存。可以执行如下代码验证：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GCTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation1<span class="token punctuation">,</span> allocation2<span class="token punctuation">,</span>allocation3<span class="token punctuation">,</span>allocation4<span class="token punctuation">,</span>allocation5<span class="token punctuation">;</span>        allocation1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">32000</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        allocation2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        allocation3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        allocation4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        allocation5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>空间分配担保：</strong>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。如果不成立的话虚拟机会查看 <strong>HandlePromotionFailure</strong> 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 <strong>Minor GC</strong> ；如果小于，或者 <strong>HandlePromotionFailure</strong> 的值不允许冒险，那么就要进行一次 <strong>Full GC</strong> 。</p></blockquote><h3 id="1-2-大对象直接进入老年代"><a href="#1-2-大对象直接进入老年代" class="headerlink" title="1.2 大对象直接进入老年代"></a>1.2 大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p><p><strong>为什么要这样呢？</strong></p><p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p><h3 id="1-3-长期存活的对象将进入老年代"><a href="#1-3-长期存活的对象将进入老年代" class="headerlink" title="1.3 长期存活的对象将进入老年代"></a>1.3 长期存活的对象将进入老年代</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1。对象在 Survivor 中每熬过一次 MinorGC ，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><h3 id="1-4-动态对象年龄判定"><a href="#1-4-动态对象年龄判定" class="headerlink" title="1.4 动态对象年龄判定"></a>1.4 动态对象年龄判定</h3><p>虚拟机并不是永远要求对象的年龄必须达到 <strong>MaxTenuringThreshold</strong> 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 <strong>MaxTenuringThreshold</strong> 中要求的年龄。</p><blockquote><p><strong>动态年龄计算的代码如下</strong></p><pre class=" language-c++"><code class="language-c++">uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) {    //survivor_capacity是survivor空间的大小size_t desired_survivor_size = (size_t)((((double) survivor_capacity)*TargetSurvivorRatio)/100);size_t total = 0;uint age = 1;while (age < table_size) {total += sizes[age];//sizes数组是每个年龄段对象大小if (total > desired_survivor_size) break; age++; } uint result = age < MaxTenuringThreshold ? age : MaxTenuringThreshold;    ...}</code></pre><p>额外补充说明(<a href="https://github.com/Snailclimb/JavaGuide/issues/672" target="_blank" rel="noopener">issue672</a>)：<strong>关于默认的晋升年龄是15，这个说法的来源大部分都是《深入理解Java虚拟机》这本书。</strong><br>如果你去Oracle的官网阅读<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener">相关的虚拟机参数</a>，你会发现 <code>-XX:MaxTenuringThreshold=threshold</code> 这里有个说明</p><p><strong>Sets the maximum tenuring threshold for use in adaptive GC sizing. The largest value is 15. The default value is 15 for the parallel (throughput) collector, and 6 for the CMS collector. 默认晋升年龄并不都是15，这个是要区分垃圾收集器的，CMS就是6。</strong></p></blockquote><h2 id="2-对象已经死亡？"><a href="#2-对象已经死亡？" class="headerlink" title="2 对象已经死亡？"></a>2 对象已经死亡？</h2><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。</p><p><img src="https://s1.ax1x.com/2020/04/19/JKAR2R.png" alt="对象已经死亡？"></p><h3 id="2-1-引用计数法"><a href="#2-1-引用计数法" class="headerlink" title="2.1 引用计数法"></a>2.1 引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p><p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong> 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReferenceCountingGc</span> <span class="token punctuation">{</span>    Object instance <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ReferenceCountingGc objA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountingGc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ReferenceCountingGc objB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountingGc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        objA<span class="token punctuation">.</span>instance <span class="token operator">=</span> objB<span class="token punctuation">;</span>        objB<span class="token punctuation">.</span>instance <span class="token operator">=</span> objA<span class="token punctuation">;</span>        objA <span class="token operator">=</span> null<span class="token punctuation">;</span>        objB <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="2-2-可达性分析算法"><a href="#2-2-可达性分析算法" class="headerlink" title="2.2 可达性分析算法"></a>2.2 可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p><p><img src="https://s1.ax1x.com/2020/04/19/JKAqGd.jpg" alt="可达性分析算法"></p><p>在 Java 中，可作为 <strong>GC Roots</strong> 的对象有：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li><li>方法区中的类静态属性引用的对象；</li><li>方法区中常量引用的对象；</li><li>本地方法栈中 JNI（即一般说的Native方法）中引用的对象。</li></ul><h3 id="2-3-再谈引用"><a href="#2-3-再谈引用" class="headerlink" title="2.3 再谈引用"></a>2.3 再谈引用</h3><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p><p>JDK 1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p><p>JDK 1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）。</p><p><strong>1．强引用（StrongReference）</strong></p><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 <strong>OutOfMemoryError</strong> 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><p><strong>2．软引用（SoftReference）</strong></p><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p><strong>3．弱引用（WeakReference）</strong></p><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 </p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p><strong>4．虚引用（PhantomReference）</strong></p><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动。</strong></p><blockquote><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 </p></blockquote><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（ OutOfMemory ）等问题的产生</strong>。</p><h3 id="2-4-不可达的对象并非“非死不可”"><a href="#2-4-不可达的对象并非“非死不可”" class="headerlink" title="2.4 不可达的对象并非“非死不可”"></a>2.4 不可达的对象并非“非死不可”</h3><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize()</code> 方法。当对象没有覆盖 <code>finalize()</code> 方法，或 <code>finalize()</code> 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p><p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><h3 id="2-5-如何判断一个常量是废弃常量"><a href="#2-5-如何判断一个常量是废弃常量" class="headerlink" title="2.5 如何判断一个常量是废弃常量"></a>2.5 如何判断一个常量是废弃常量</h3><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p><p>假如在常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。</p><p>注意：我们在 <a href="https://www.niewenjun.com/2020/04/19/hou-duan/jvm/java-nei-cun-qu-yu-xiang-jie">《可能是把 Java 内存区域讲的最清楚的一篇文章》</a> 也讲了 JDK 1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</p><h3 id="2-6-如何判断一个类是无用的类"><a href="#2-6-如何判断一个类是无用的类" class="headerlink" title="2.6 如何判断一个类是无用的类"></a>2.6 如何判断一个类是无用的类</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h2 id="3-垃圾收集算法"><a href="#3-垃圾收集算法" class="headerlink" title="3 垃圾收集算法"></a>3 垃圾收集算法</h2><p><img src="https://s1.ax1x.com/2020/04/19/JKZAbV.png" alt="垃圾收集算法分类"></p><h3 id="3-1-标记-清除算法"><a href="#3-1-标记-清除算法" class="headerlink" title="3.1 标记-清除算法"></a>3.1 标记-清除算法</h3><p>该算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p><ol><li><strong>效率问题</strong></li><li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></li></ol><p><img src="https://s1.ax1x.com/2020/04/19/JKZGVK.jpg" alt="标记-清除算法"></p><h3 id="3-2-标记-整理算法"><a href="#3-2-标记-整理算法" class="headerlink" title="3.2 标记-整理算法"></a>3.2 标记-整理算法</h3><p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="https://s1.ax1x.com/2020/04/19/JKZoZV.jpg" alt="标记-整理算法"></p><h3 id="3-3-复制算法"><a href="#3-3-复制算法" class="headerlink" title="3.3 复制算法"></a>3.3 复制算法</h3><p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p><img src="https://s1.ax1x.com/2020/04/19/JKe9IO.jpg" alt="复制算法"></p><h3 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="3.4 分代收集算法"></a>3.4 分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p><p><strong>延伸面试问题：</strong> HotSpot 为什么要分为新生代和老年代？</p><p>根据上面的对分代收集算法的介绍回答。</p><h2 id="4-垃圾收集器"><a href="#4-垃圾收集器" class="headerlink" title="4 垃圾收集器"></a>4 垃圾收集器</h2><p><img src="https://s1.ax1x.com/2020/04/19/JKnoZt.png" alt="垃圾收集器分类"></p><p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p><p>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。</p><h3 id="4-1-Serial-收集器"><a href="#4-1-Serial-收集器" class="headerlink" title="4.1 Serial 收集器"></a>4.1 Serial 收集器</h3><p>Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p><p> <strong>新生代采用复制算法，老年代采用标记-整理算法。</strong><br><img src="https://s1.ax1x.com/2020/04/19/JKuFWF.jpg" alt="Serial 收集器"></p><p>虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p><p>但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他单线程的收集器相比）</strong>。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p><h3 id="4-2-ParNew-收集器"><a href="#4-2-ParNew-收集器" class="headerlink" title="4.2 ParNew 收集器"></a>4.2 ParNew 收集器</h3><p><strong>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</strong></p><p> <strong>新生代采用复制算法，老年代采用标记-整理算法。</strong><br><img src="https://s1.ax1x.com/2020/04/19/JKuwY8.jpg" alt="ParNew 收集器"></p><p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p><p><strong>并行和并发概念补充：</strong></p><ul><li><p><strong>并行（Parallel）：</strong>指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p></li><li><p><strong>并发（Concurrent）：</strong>指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</p></li></ul><h3 id="4-3-Parallel-Scavenge-收集器"><a href="#4-3-Parallel-Scavenge-收集器" class="headerlink" title="4.3 Parallel Scavenge 收集器"></a>4.3 Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器也是使用复制算法的多线程收集器，它看上去几乎和ParNew都一样。 <strong>那么它有什么特别之处呢？</strong></p><pre><code>-XX:+UseParallelGC     使用 Parallel 收集器+ 老年代串行-XX:+UseParallelOldGC    使用 Parallel 收集器+ 老年代并行</code></pre><p><strong>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong> Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在困难的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><p> <strong>新生代采用复制算法，老年代采用标记-整理算法。</strong><br><img src="https://s1.ax1x.com/2020/04/19/JKuwY8.jpg" alt="Parallel Scavenge 收集器"></p><h3 id="4-4-Serial-Old-收集器"><a href="#4-4-Serial-Old-收集器" class="headerlink" title="4.4.Serial Old 收集器"></a>4.4.Serial Old 收集器</h3><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK 1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p><h3 id="4-5-Parallel-Old-收集器"><a href="#4-5-Parallel-Old-收集器" class="headerlink" title="4.5 Parallel Old 收集器"></a>4.5 Parallel Old 收集器</h3><p> <strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><h3 id="4-6-CMS-收集器"><a href="#4-6-CMS-收集器" class="headerlink" title="4.6 CMS 收集器"></a>4.6 CMS 收集器</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p><p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>从名字中的 <strong>Mark Sweep</strong> 这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 GC Roots 相连的对象，速度很快 ；</li><li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对为标记的区域做清扫。</li></ul><p><img src="https://s1.ax1x.com/2020/04/19/JKMFKJ.jpg" alt="CMS 垃圾收集器"></p><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾（并发清除阶段用户线程产生的新的垃圾）；</strong></li><li><strong>它使用的回收算法——“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><h3 id="4-7-G1-收集器"><a href="#4-7-G1-收集器" class="headerlink" title="4.7 G1 收集器"></a>4.7 G1 收集器</h3><p><strong>G1（Garbage-First）是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征。</strong></p><p>被视为 JDK 1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记–清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region（这也就是它的名字 Garbage-First 的由来）</strong>。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><h3 id="4-8-Java-默认垃圾收集器"><a href="#4-8-Java-默认垃圾收集器" class="headerlink" title="4.8 Java 默认垃圾收集器"></a>4.8 Java 默认垃圾收集器</h3><ul><li>jdk 1.7 默认垃圾收集器 Parallel Scavenge（新生代）+ Parallel Old（老年代）。</li><li>jdk 1.8 默认垃圾收集器 Parallel Scavenge（新生代）+ Parallel Old（老年代）。</li><li>jdk 1.9 默认垃圾收集器 G1 。</li></ul><h3 id="4-9-为什么要-stop-the-world-？"><a href="#4-9-为什么要-stop-the-world-？" class="headerlink" title="4.9 为什么要 stop the world ？"></a>4.9 为什么要 stop the world ？</h3><p>我们知道垃圾回收首先是要经过标记的。对象被标记后就会根据不同的区域采用不同的收集方法。看上去很完美的一件事情，其实并不然。</p><p>大家有没有想过一件事情，当虚拟机完成两次标记后，便确认了可以回收的对象。但是，垃圾回收并不会阻塞我们程序的线程，它是与当前程序并发执行的。所以问题就出在这里，当 GC 线程标记好了一个对象的时候，此时我们程序的线程又将该对象重新加入了“关系网”中，当执行二次标记的时候，该对象也没有重写 <code>finalize()</code> 方法，因此回收的时候就会回收这个不该回收的对象。 </p><p>虚拟机的解决方法就是在一些特定指令位置设置一些“安全点”，当程序运行到这些“安全点”的时候就会暂停所有当前运行的线程（ Stop The World 所以叫 STW ），暂停后再找到“GC Roots”进行关系的组建，进而执行标记和清除。 </p><p>这些特定的指令位置主要在：</p><ul><li>循环的末尾。</li><li>方法临返回前/调用方法的 call 指令后。</li><li>可能抛异常的位置。</li></ul><blockquote><p><strong>如何找到 GC Roots ？</strong>通过采用一个 <strong>OopMap</strong> 的数据结构来记录系统中存活的 <strong>GC Roots</strong> ，在类加载完成的时候，虚拟机就把对象内什么偏移量上是什么类型的数据计算出来保存在 <strong>OopMap</strong> ，通过解释 <strong>OopMap</strong> 就可以找到堆中的对象，这些对象就是 <strong>GC Roots</strong> 。而不需要一个一个的去判断某个内存位置的值是不是引用。这种方式也叫<strong>准确式 GC</strong> 。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版）》</li><li><a href="https://my.oschina.net/hosee/blog/644618" target="_blank" rel="noopener">https://my.oschina.net/hosee/blog/644618</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存区域详解</title>
      <link href="/2020/04/19/hou-duan/jvm/java-nei-cun-qu-yu-xiang-jie/"/>
      <url>/2020/04/19/hou-duan/jvm/java-nei-cun-qu-yu-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-内存区域详解"><a href="#Java-内存区域详解" class="headerlink" title="Java 内存区域详解"></a>Java 内存区域详解</h1><p>如果没有特殊说明，都是针对的是 HotSpot 虚拟机。</p><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++ 程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。</p><h2 id="二-运行时数据区域"><a href="#二-运行时数据区域" class="headerlink" title="二 运行时数据区域"></a>二 运行时数据区域</h2><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK 1.8 和之前的版本略有不同，下面会介绍到。</p><p><strong>JDK 1.8 之前：</strong></p><p><img src="https://s1.ax1x.com/2020/04/19/JuYRyT.png" alt="Java 内存区域（1.8之前）"></p><p><strong>JDK 1.8 ：</strong></p><p><img src="https://s1.ax1x.com/2020/04/19/JuYv0e.png" alt="Java 内存区域（1.8）"></p><p><strong>线程私有的：</strong></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p><strong>线程共享的：</strong></p><ul><li>堆</li><li>方法区</li><li>直接内存 (非运行时数据区的一部分)</li></ul><h3 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="2.1 程序计数器"></a>2.1 程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong></p><p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p><p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p><strong>注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p><h3 id="2-2-Java-虚拟机栈"><a href="#2-2-Java-虚拟机栈" class="headerlink" title="2.2 Java 虚拟机栈"></a>2.2 Java 虚拟机栈</h3><p><strong>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</strong></p><p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack)，其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong>（实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口等信息。）</p><p><strong>局部变量表主要存放了编译器可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p><p><strong>Java 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError 。</strong></p><ul><li><strong>StackOverFlowError ：</strong>若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</li><li><strong>OutOfMemoryError ：</strong>若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 错误。</li></ul><p>Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">StackOverFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">StackOverFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">OutOfMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p><strong>扩展：那么方法/函数如何调用？</strong></p><p>Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p><p>Java 方法有两种返回方式：</p><ol><li>return 语句。</li><li>抛出异常。</li></ol><p>不管哪种返回方式都会导致栈帧被弹出。</p><h3 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h3><p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、方法出口等信息。</p><p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。</p><h3 id="2-4-堆"><a href="#2-4-堆" class="headerlink" title="2.4 堆"></a>2.4 堆</h3><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：<strong>新生代和老年代</strong>，再细致一点有：<strong>Eden 空间、From Survivor、To Survivor 空间</strong>等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><p>在 JDK 1.7 版本及 JDK 1.7 版本之前，堆内存被通常被分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永久代(Permanent Generation)</li></ol><p><img src="https://s1.ax1x.com/2020/04/19/JuUeWn.jpg" alt="JVM堆内存结构-JDK 1.7"></p><p>JDK 1.8 版本之后方法区（ HotSpot 的永久代）被彻底移除了（ JDK 1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p><p><img src="https://s1.ax1x.com/2020/04/19/JuU3o4.jpg" alt="JVM堆内存结构-JDK 1.8"></p><p><strong>上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 From Survivor 和 To Survivor ），中间一层属于老年代。</strong></p><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加  1（ Eden 区 -&gt; Survivor 区后对象的初始年龄变为 1），当它的年龄增加到一定程度（默认为 <strong>15</strong> 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><blockquote><p>修正（<a href="https://github.com/Snailclimb/JavaGuide/issues/552" target="_blank" rel="noopener">issue552</a>）：“Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 Survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</p><p><strong>动态年龄计算的代码如下</strong></p><pre class=" language-c++"><code class="language-c++">uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) {    //survivor_capacity是survivor空间的大小  size_t desired_survivor_size = (size_t)((((double) survivor_capacity)*TargetSurvivorRatio)/100);  size_t total = 0;  uint age = 1;  while (age < table_size) {    total += sizes[age];//sizes数组是每个年龄段对象大小    if (total > desired_survivor_size) break;    age++;  }  uint result = age < MaxTenuringThreshold ? age : MaxTenuringThreshold;    ...}</code></pre></blockquote><p>堆这里最容易出现的就是  OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：</p><ol><li><strong><code>OutOfMemoryError: GC Overhead Limit Exceeded</code>：</strong>当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li><li><strong><code>java.lang.OutOfMemoryError: Java heap space</code>：</strong>假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发 <code>java.lang.OutOfMemoryError: Java heap space</code> 错误。(和本机物理内存无关，和你配置的内存大小有关！)</li><li>……</li></ol><h3 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h3><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p><p>方法区也被称为永久代。很多人都会分不清方法区和永久代的关系，为此我也查阅了文献。</p><h4 id="2-5-1-方法区和永久代的关系"><a href="#2-5-1-方法区和永久代的关系" class="headerlink" title="2.5.1 方法区和永久代的关系"></a>2.5.1 方法区和永久代的关系</h4><blockquote><p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。  <strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p></blockquote><h4 id="2-5-2-常用参数"><a href="#2-5-2-常用参数" class="headerlink" title="2.5.2 常用参数"></a>2.5.2 常用参数</h4><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XX<span class="token operator">:</span>PermSize<span class="token operator">=</span>N <span class="token comment" spellcheck="true">//方法区 (永久代) 初始大小</span><span class="token operator">-</span>XX<span class="token operator">:</span>MaxPermSize<span class="token operator">=</span>N <span class="token comment" spellcheck="true">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></code></pre><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p><p>JDK 1.8 的时候，方法区（ HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p><p>下面是一些常用参数：</p><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XX<span class="token operator">:</span>MetaspaceSize<span class="token operator">=</span>N <span class="token comment" spellcheck="true">//设置 Metaspace 的初始（和最小大小）</span><span class="token operator">-</span>XX<span class="token operator">:</span>MaxMetaspaceSize<span class="token operator">=</span>N <span class="token comment" spellcheck="true">//设置 Metaspace 的最大大小</span></code></pre><p>与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p><h4 id="2-5-3-为什么要将永久代（PermGen）替换为元空间（MetaSpace）呢？"><a href="#2-5-3-为什么要将永久代（PermGen）替换为元空间（MetaSpace）呢？" class="headerlink" title="2.5.3 为什么要将永久代（PermGen）替换为元空间（MetaSpace）呢？"></a>2.5.3 为什么要将永久代（PermGen）替换为元空间（MetaSpace）呢？</h4><ol><li>整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。<blockquote><p>当你元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code></p></blockquote></li></ol><p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 <strong>unlimited</strong> ，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。  </p><ol start="2"><li><p>元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。  </p></li><li><p>在 JDK 1.8 ，合并 HotSpot 和 JRockit 的代码时，JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</p></li></ol><h3 id="2-6-运行时常量池"><a href="#2-6-运行时常量池" class="headerlink" title="2.6 运行时常量池"></a>2.6 运行时常量池</h3><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）。</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 <strong>OutOfMemoryError</strong> 错误。</p><p><strong>JDK 1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong> </p><p><img src="https://s1.ax1x.com/2020/04/19/JuantH.png" alt="常量池"><br>——图片来源：<a href="https://blog.csdn.net/wangbiao007/article/details/78545189" target="_blank" rel="noopener">https://blog.csdn.net/wangbiao007/article/details/78545189</a></p><h3 id="2-7-直接内存"><a href="#2-7-直接内存" class="headerlink" title="2.7 直接内存"></a>2.7 直接内存</h3><p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</strong></p><p>JDK 1.4 中新加入的 <strong>NIO（New Input/Output）类</strong>，引入了一种基于<strong>通道（Channel）</strong>与<strong>缓存区（Buffer）</strong> 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p><p>本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p><h2 id="三-HotSpot-虚拟机对象探秘"><a href="#三-HotSpot-虚拟机对象探秘" class="headerlink" title="三 HotSpot 虚拟机对象探秘"></a>三 HotSpot 虚拟机对象探秘</h2><p>通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。</p><h3 id="3-1-对象的创建"><a href="#3-1-对象的创建" class="headerlink" title="3.1 对象的创建"></a>3.1 对象的创建</h3><p>下图便是 Java 对象的创建过程，我建议最好是能默写出来，并且要掌握每一步在做什么。<br><img src="https://s1.ax1x.com/2020/04/19/JuagN4.png" alt="Java 创建对象的过程"></p><h4 id="Step1：类加载检查"><a href="#Step1：类加载检查" class="headerlink" title="Step1：类加载检查"></a>Step1：类加载检查</h4><p> 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><h4 id="Step2：分配内存"><a href="#Step2：分配内存" class="headerlink" title="Step2：分配内存"></a>Step2：分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><p><strong>内存分配的两种方式：（补充内容，需要掌握）</strong></p><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的</p><p><img src="https://s1.ax1x.com/2020/04/19/JuazKP.png" alt="内存分配的两种方式"></p><p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><strong>CAS + 失败重试：</strong>CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong>为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。</li></ul><blockquote><p>TLAB 的全称是 Thread Local Allocation Buffer ，即线程本地分配缓存区，这是一个线程专用的内存分配区域。由于对象一般会分配在堆上，而堆是全局共享的。因此在同一时间，可能会有多个线程在堆上申请空间。因此，每次对象分配都必须要进行同步（虚拟机采用 <strong>CAS + 失败重试</strong>的方式保证更新操作的原子性），而在竞争激烈的场合分配的效率又会进一步下降。JVM 使用TLAB来避免多线程冲突，在给对象分配内存时，每个线程使用自己的TLAB，这样可以避免线程同步，提高了对象分配的效率。TLAB 本身占用 Eden 区空间，在开启 TLAB 的情况下，虚拟机会为<strong>每个 Java 线程分配一块 TLAB 空间</strong>。</p></blockquote><h4 id="Step3：初始化零值"><a href="#Step3：初始化零值" class="headerlink" title="Step3：初始化零值"></a>Step3：初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h4 id="Step4：设置对象头"><a href="#Step4：设置对象头" class="headerlink" title="Step4：设置对象头"></a>Step4：设置对象头</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h4 id="Step5：执行-init-方法"><a href="#Step5：执行-init-方法" class="headerlink" title="Step5：执行 init 方法"></a>Step5：执行 init 方法</h4><p> 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h3 id="3-2-对象的内存布局"><a href="#3-2-对象的内存布局" class="headerlink" title="3.2 对象的内存布局"></a>3.2 对象的内存布局</h3><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h3 id="3-3-对象的访问定位"><a href="#3-3-对象的访问定位" class="headerlink" title="3.3 对象的访问定位"></a>3.3 对象的访问定位</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有<strong>①使用句柄</strong>和<strong>②直接指针</strong>两种：</p><ol><li><p><strong>句柄：</strong> 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p><p><img src="https://s1.ax1x.com/2020/04/19/JuwSzR.png" alt="对象的访问定位-使用句柄"></p></li><li><p><strong>直接指针：</strong>  如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</p></li></ol><p><img src="https://s1.ax1x.com/2020/04/19/JuwkdO.png" alt="对象的访问定位-直接指针"></p><p><strong>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p><h2 id="四-重点补充内容"><a href="#四-重点补充内容" class="headerlink" title="四  重点补充内容"></a>四  重点补充内容</h2><h3 id="4-1-String-类和常量池"><a href="#4-1-String-类和常量池" class="headerlink" title="4.1 String 类和常量池"></a>4.1 String 类和常量池</h3><p><strong>String 对象的两种创建方式：</strong></p><pre class=" language-java"><code class="language-java">String str1 <span class="token operator">=</span> <span class="token string">"abcd"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//先检查字符串常量池中有没有"abcd"，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向"abcd""；</span>String str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abcd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//堆中创建一个新的对象</span>String str3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abcd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//堆中创建一个新的对象</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token operator">==</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str2<span class="token operator">==</span>str3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span></code></pre><p>这两种不同的创建方法是有差别的。</p><ul><li>第一种方式是在常量池中拿对象；</li><li>第二种方式是直接在堆内存空间创建一个新的对象。</li></ul><p>记住一点：<strong>只要使用 new 方法，便需要创建新的对象。</strong></p><p>再给大家一个图应该更容易理解，图片来源：<a href="https://www.journaldev.com/797/what-is-java-string-pool" target="_blank" rel="noopener">https://www.journaldev.com/797/what-is-java-string-pool</a>：</p><p><img src="https://s1.ax1x.com/2020/04/19/JuweWd.png" alt="String-Pool-Java"></p><p><strong>String 类型的常量池比较特殊。它的主要使用方法有两种：</strong></p><ul><li>直接使用双引号声明出来的 String 对象会直接存储在常量池中。</li><li>如果不是用双引号声明的 String 对象，可以使用 String 提供的 <code>intern()</code> 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK 1.7 之前（不包含 1.7 ）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK 1.7 以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用。</li></ul><pre class=" language-java"><code class="language-java">          String s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"计算机"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          String s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          String s3 <span class="token operator">=</span> <span class="token string">"计算机"</span><span class="token punctuation">;</span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//计算机</span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false，因为一个是堆内存中的 String 对象一个是常量池中的 String 对象，</span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true，因为两个都是常量池中的 String 对象</span></code></pre><p><strong>字符串拼接:</strong></p><pre class=" language-java"><code class="language-java">          String str1 <span class="token operator">=</span> <span class="token string">"str"</span><span class="token punctuation">;</span>          String str2 <span class="token operator">=</span> <span class="token string">"ing"</span><span class="token punctuation">;</span>          String str3 <span class="token operator">=</span> <span class="token string">"str"</span> <span class="token operator">+</span> <span class="token string">"ing"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//常量池中的对象</span>          String str4 <span class="token operator">=</span> str1 <span class="token operator">+</span> str2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//在堆上创建的新的对象      </span>          String str5 <span class="token operator">=</span> <span class="token string">"string"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//常量池中的对象</span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str3 <span class="token operator">==</span> str4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str3 <span class="token operator">==</span> str5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str4 <span class="token operator">==</span> str5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span></code></pre><p><img src="https://s1.ax1x.com/2020/04/19/Juw1w8.png" alt="字符串拼接"></p><p>尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 <strong>StringBuilder</strong> 或者 <strong>StringBuffer</strong> 。</p><h3 id="4-2-String-s1-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#4-2-String-s1-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="4.2 String s1 = new String(“abc”); 这句话创建了几个字符串对象？"></a>4.2 String s1 = new String(“abc”); 这句话创建了几个字符串对象？</h3><p><strong>将创建 1 或 2 个字符串。如果池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。如果池中没有字符串常量“abc”，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。</strong></p><p><strong>验证：</strong></p><pre class=" language-java"><code class="language-java">        String s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 堆内存的地址值</span>        String s2 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出 false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出 true</span></code></pre><p><strong>结果：</strong></p><pre class=" language-java"><code class="language-java"><span class="token boolean">false</span><span class="token boolean">true</span></code></pre><h3 id="4-3-8-种基本类型的包装类和常量池"><a href="#4-3-8-种基本类型的包装类和常量池" class="headerlink" title="4.3 8 种基本类型的包装类和常量池"></a>4.3 8 种基本类型的包装类和常量池</h3><p><strong>Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte, Short, Integer, Long, Character, Boolean；前面 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在[0,127]范围的缓存数据，Boolean 直接返回 True or False 。如果超出对应范围仍然会去创建新的对象。</strong> 为啥把缓存设置为 [-128，127] 区间？（<a href="https://github.com/Snailclimb/JavaGuide/issues/461" target="_blank" rel="noopener">参见issue/461</a>）性能和资源之间的权衡。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Boolean <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>b <span class="token operator">?</span> TRUE <span class="token operator">:</span> FALSE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CharacterCache</span> <span class="token punctuation">{</span>             <span class="token keyword">private</span> <span class="token function">CharacterCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Character cache<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Character</span><span class="token punctuation">[</span><span class="token number">127</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>              <span class="token keyword">static</span> <span class="token punctuation">{</span>                     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cache<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                             cache<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Character</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>   <span class="token punctuation">}</span></code></pre><p><strong>两种浮点数类型的包装类 Float，Double 并没有实现常量池技术。</strong></p><pre class=" language-java"><code class="language-java">        Integer i1 <span class="token operator">=</span> <span class="token number">33</span><span class="token punctuation">;</span>        Integer i2 <span class="token operator">=</span> <span class="token number">33</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出 true</span>        Integer i11 <span class="token operator">=</span> <span class="token number">333</span><span class="token punctuation">;</span>        Integer i22 <span class="token operator">=</span> <span class="token number">333</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i11 <span class="token operator">==</span> i22<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出 false</span>        Double i3 <span class="token operator">=</span> <span class="token number">1.2</span><span class="token punctuation">;</span>        Double i4 <span class="token operator">=</span> <span class="token number">1.2</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i3 <span class="token operator">==</span> i4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出 false</span></code></pre><p><strong>Integer 缓存源代码：</strong> </p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/***此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。*/</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> IntegerCache<span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> IntegerCache<span class="token punctuation">.</span>high<span class="token punctuation">)</span>            <span class="token keyword">return</span> IntegerCache<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span>IntegerCache<span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>应用场景：</strong></p><ol><li>Integer i1 = 40；Java 在编译的时候会直接将代码封装成 <code>Integer i1 = Integer.valueOf(40);</code> ，从而使用常量池中的对象。</li><li><code>Integer i1 = new Integer(40);</code> 这种情况下会创建新的对象。</li></ol><pre class=" language-java"><code class="language-java">  Integer i1 <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>  Integer i2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1<span class="token operator">==</span>i2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出 false</span></code></pre><p><strong>Integer 比较更丰富的一个例子:</strong></p><pre class=" language-java"><code class="language-java">  Integer i1 <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>  Integer i2 <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>  Integer i3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  Integer i4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Integer i5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Integer i6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i1=i2   "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i1=i2+i3   "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2 <span class="token operator">+</span> i3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i1=i4   "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i1 <span class="token operator">==</span> i4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i4=i5   "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i4 <span class="token operator">==</span> i5<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i4=i5+i6   "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i4 <span class="token operator">==</span> i5 <span class="token operator">+</span> i6<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"40=i5+i6   "</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">40</span> <span class="token operator">==</span> i5 <span class="token operator">+</span> i6<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     </code></pre><p>结果：</p><pre class=" language-java"><code class="language-java">i1<span class="token operator">=</span>i2   <span class="token boolean">true</span>i1<span class="token operator">=</span>i2<span class="token operator">+</span>i3   <span class="token boolean">true</span>i1<span class="token operator">=</span>i4   <span class="token boolean">false</span>i4<span class="token operator">=</span>i5   <span class="token boolean">false</span>i4<span class="token operator">=</span>i5<span class="token operator">+</span>i6   <span class="token boolean">true</span><span class="token number">40</span><span class="token operator">=</span>i5<span class="token operator">+</span>i6   <span class="token boolean">true</span></code></pre><p>解释：</p><p>语句 i4 == i5 + i6，因为 + 这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40 ，最终这条语句转为 40 == 40 进行数值比较。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》</li><li>《实战 java 虚拟机》</li><li><a href="https://docs.oracle.com/javase/specs/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/index.html</a></li><li><a href="http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/" target="_blank" rel="noopener">http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/</a></li><li><a href="https://dzone.com/articles/jvm-permgen-%E2%80%93-where-art-thou" target="_blank" rel="noopener">https://dzone.com/articles/jvm-permgen-%E2%80%93-where-art-thou</a></li><li><a href="https://stackoverflow.com/questions/9095748/method-area-and-permgen" target="_blank" rel="noopener">https://stackoverflow.com/questions/9095748/method-area-and-permgen</a></li><li>深入解析String#intern<a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发进阶常见面试题</title>
      <link href="/2020/04/18/hou-duan/bing-fa/java-bing-fa-jin-jie-chang-jian-mian-shi-ti/"/>
      <url>/2020/04/18/hou-duan/bing-fa/java-bing-fa-jin-jie-chang-jian-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-并发进阶常见面试题总结"><a href="#Java-并发进阶常见面试题总结" class="headerlink" title="Java 并发进阶常见面试题总结"></a>Java 并发进阶常见面试题总结</h1><h2 id="1-synchronized-关键字"><a href="#1-synchronized-关键字" class="headerlink" title="1. synchronized 关键字"></a>1. synchronized 关键字</h2><h3 id="1-1-说一说自己对于-synchronized-关键字的了解"><a href="#1-1-说一说自己对于-synchronized-关键字的了解" class="headerlink" title="1.1. 说一说自己对于 synchronized 关键字的了解"></a>1.1. 说一说自己对于 synchronized 关键字的了解</h3><p>synchronized 关键字解决的是多个线程之间访问资源的同步性，synchronized 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><blockquote><p>在 Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如<strong>自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁</strong>等技术来减少锁操作的开销。</p></blockquote><h3 id="1-2-说说自己是怎么使用-synchronized-关键字，在项目中用到了吗？"><a href="#1-2-说说自己是怎么使用-synchronized-关键字，在项目中用到了吗？" class="headerlink" title="1.2. 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗？"></a>1.2. 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗？</h3><p><strong>synchronized关键字最主要的三种使用方式：</strong></p><ul><li><strong>修饰实例方法：</strong>作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁。</li><li><strong>修饰静态方法：</strong>也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份）。所以如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。</li><li><strong>修饰代码块：</strong>指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li></ul><p><strong>总结：</strong>synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 <code>synchronized(String a)</code> 因为JVM中，字符串常量池具有缓存功能！</p><p>下面我以一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。</p><blockquote><p>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”</p></blockquote><p><strong>双重校验锁实现对象单例（线程安全）</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> Singleton uniqueInstance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//类对象加锁</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>另外，需要注意 uniqueInstance 采用 <strong>volatile</strong> 关键字修饰也是很有必要。</p><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的，<code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p><ol><li>为 uniqueInstance 分配内存空间；</li><li>初始化 uniqueInstance；</li><li>将 uniqueInstance 指向分配的内存地址。</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance()</code> 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p><p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p><h3 id="1-3-讲一下-synchronized-关键字的底层原理"><a href="#1-3-讲一下-synchronized-关键字的底层原理" class="headerlink" title="1.3. 讲一下 synchronized 关键字的底层原理"></a>1.3. 讲一下 synchronized 关键字的底层原理</h3><p><strong>synchronized 关键字底层原理属于 JVM 层面。</strong></p><p><strong>① synchronized 同步语句块的情况</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"synchronized 代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>通过 JDK 自带的 <strong>javap</strong> 命令查看 SynchronizedDemo 类的相关字节码信息：首先切换到类的对应目录执行 <code>javac SynchronizedDemo.java</code> 命令生成编译后的 .class 文件，然后执行<code>javap -c -s -v -l SynchronizedDemo.class</code> 。</p><p><img src="https://images.gitbook.cn/abc37c80-d21d-11e8-aab3-09d30029e0d5" alt="synchronized 关键字原理"></p><p>从上面我们可以看出：</p><p><strong>synchronized 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong>当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor（monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么 Java 中任意对象可以作为锁的原因）的持有权。当计数器为 0 则可以成功获取，获取后将锁计数器设为 1 也就是加 1 。相应的在执行 monitorexit 指令后，将锁计数器设为 0 ，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><p><strong>② synchronized 修饰方法的的情况</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedDemo2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"synchronized 方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="https://images.gitbook.cn/7d407bf0-d21e-11e8-b2d6-1188c7e0dd7e" alt="synchronized 关键字原理"></p><p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取而代之的却是 <strong>ACC_SYNCHRONIZED</strong> 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><h3 id="1-4-说说-JDK1-6-之后的-synchronized-关键字底层做了哪些优化，可以详细介绍一下这些优化吗？"><a href="#1-4-说说-JDK1-6-之后的-synchronized-关键字底层做了哪些优化，可以详细介绍一下这些优化吗？" class="headerlink" title="1.4. 说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗？"></a>1.4. 说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗？</h3><p>JDK 1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><p>关于这几种优化的详细信息可以查看笔主的这篇文章：<a href="https://www.niewenjun.com/2020/04/17/hou-duan/bing-fa/synchronized">https://www.niewenjun.com/2020/04/17/hou-duan/bing-fa/synchronized</a></p><h3 id="1-5-谈谈-synchronized-和-ReentrantLock-的区别"><a href="#1-5-谈谈-synchronized-和-ReentrantLock-的区别" class="headerlink" title="1.5. 谈谈 synchronized 和 ReentrantLock 的区别"></a>1.5. 谈谈 synchronized 和 ReentrantLock 的区别</h3><p><strong>① 两者都是可重入锁</strong></p><p>两者都是<strong>可重入锁</strong>。“可重入锁”概念是：<strong>自己可以再次获取自己的内部锁</strong>。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1 ，所以要等到锁的计数器下降为 0 时才能释放锁。</p><p><strong>② synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</strong></p><p>synchronized 是依赖于 JVM 实现的，前面我们也讲到了虚拟机团队在 JDK 1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 <code>lock()</code> 和 <code>unlock()</code> 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p><p><strong>③ ReentrantLock 比 synchronized 增加了一些高级功能</strong></p><p>相比 synchronized，ReentrantLock 增加了一些高级功能。主要来说主要有三点：<strong>①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</strong></p><ul><li><strong>ReentrantLock 提供了一种能够中断等待锁的线程的机制</strong>，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>ReentrantLock 可以指定是公平锁还是非公平锁。而 synchronized 只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</strong> ReentrantLock 默认情况是非公平的，可以通过 ReentrantLock 类的<code>ReentrantLock(boolean fair)</code> 构造方法来制定是否是公平的。</li><li>synchronized 关键字与 <code>wait()</code> 和 <code>notify()/notifyAll()</code> 方法相结合可以实现等待/通知机制，ReentrantLock 类当然也可以实现，但是需要借助于 Condition 接口与 <code>newCondition()</code> 方法。Condition 是 JDK 1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能，也就是在一个 Lock 对象中可以创建多个 Condition 实例（即对象监视器），<strong>线程对象可以注册在指定的 Condition 中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用 notify()/notifyAll() 方法进行通知时，被通知的线程是由 JVM 选择的，用 ReentrantLock 类结合 Condition 实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是 Condition 接口默认提供的。而 synchronized 关键字就相当于整个 Lock 对象中只有一个 Condition 实例，所有的线程都注册在它一个身上。如果执行 <code>notifyAll()</code> 方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而 Condition 实例的 <code>signalAll()</code> 方法只会唤醒注册在该 Condition 实例中的所有等待线程。</li></ul><p>如果你想使用上述功能，那么选择 <strong>ReentrantLock</strong> 是一个不错的选择。</p><p><strong>④ 性能已不是选择标准</strong></p><p>在 JDK 1.6 之前，synchronized 的性能是比 ReentrantLock 差很多。具体表示为：synchronized 关键字吞吐量随线程数的增加，下降得非常严重。而 ReentrantLock 基本保持一个比较稳定的水平。我觉得这也侧面反映了， synchronized 关键字还有非常大的优化余地。后续的技术发展也证明了这一点，我们上面也讲了在 JDK 1.6 之后 JVM 团队对 synchronized 关键字做了很多优化。<strong>JDK1.6 之后，synchronized 和 ReentrantLock 的性能基本是持平了。所以网上那些说因为性能才选择 ReentrantLock 的文章都是错的！JDK 1.6之后，性能已经不是选择 synchronized 和 ReentrantLock 的影响因素了！而且虚拟机在未来的性能改进中会更偏向于原生的 synchronized ，所以还是提倡在 synchronized 能满足你的需求的情况下，优先考虑使用 synchronized 关键字来进行同步！优化后的 synchronized 和 ReentrantLock 一样，在很多地方都是用到了 CAS 操作。</strong></p><h2 id="2-volatile关键字"><a href="#2-volatile关键字" class="headerlink" title="2. volatile关键字"></a>2. volatile关键字</h2><h3 id="2-1-讲一下Java内存模型"><a href="#2-1-讲一下Java内存模型" class="headerlink" title="2.1. 讲一下Java内存模型"></a>2.1. 讲一下Java内存模型</h3><p>在 JDK 1.2 之前，Java的内存模型实现总是从<strong>主存</strong>（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成<strong>数据的不一致</strong>。</p><p><img src="https://s1.ax1x.com/2020/04/18/JmsNMn.jpg" alt="数据不一致"></p><p>要解决这个问题，就需要把变量声明为 <strong>volatile</strong> ，这就指示 JVM ，这个变量是不稳定的，每次使用它都到主存中进行读取。</p><p>说白了， <strong>volatile</strong> 关键字的主要作用就是保证变量的可见性然后还有一个作用是防止指令重排序。</p><p><img src="https://s1.ax1x.com/2020/04/18/JmyFLq.jpg" alt="volatile 关键字的可见性"></p><h3 id="2-2-volatile-实现原理"><a href="#2-2-volatile-实现原理" class="headerlink" title="2.2. volatile 实现原理"></a>2.2. volatile 实现原理</h3><p>（1）通过插入内存屏障指令禁止编译器和 CPU 对程序进行重排序。</p><p>（2）当对声明了 volatile 的变量进行写操作时，JVM 就会向处理器发送一条 <strong>Lock</strong> 前缀的指令，这条 Lock 前缀指令产生如下两个作用：</p><ul><li><strong>Lock 前缀指令会引起处理器缓存回写到系统内存，并使用缓存一致性机制来确保回写的原子性。</strong></li><li><strong>一个处理器的缓存回写到系统内存会导致其他处理器的缓存无效。</strong>处理器使用 MESI 控制协议去维护内部缓存和其他处理器缓存的一致性。处理器能嗅探其他处理器访问系统内存和它们的内部缓存。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。</li></ul><h3 id="2-3-并发编程的三个重要特性"><a href="#2-3-并发编程的三个重要特性" class="headerlink" title="2.3. 并发编程的三个重要特性"></a>2.3. 并发编程的三个重要特性</h3><ol><li><strong>原子性：</strong>一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。<code>synchronized</code> 可以保证代码片段的原子性。</li><li><strong>可见性：</strong>当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。<code>volatile</code> 关键字可以保证共享变量的可见性。</li><li><strong>有序性：</strong>代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化。</li></ol><h3 id="2-4-说说-synchronized-关键字和-volatile-关键字的区别"><a href="#2-4-说说-synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="2.4. 说说 synchronized 关键字和 volatile 关键字的区别"></a>2.4. 说说 synchronized 关键字和 volatile 关键字的区别</h3><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在：</p><ul><li><strong>volatile 关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以 <strong>volatile 性能肯定比 synchronized 关键字要好</strong>。但是<strong>volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块</strong>。synchronized 关键字在 JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，<strong>实际开发中使用 synchronized 关键字的场景还是更多一些</strong>。</li><li><strong>多线程访问 volatile 关键字不会发生阻塞，而 synchronized 关键字可能会发生阻塞。</strong></li><li><strong>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</strong></li><li><strong>volatile 关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。</strong></li></ul><h2 id="3-ThreadLocal"><a href="#3-ThreadLocal" class="headerlink" title="3. ThreadLocal"></a>3. ThreadLocal</h2><h3 id="3-1-ThreadLocal-简介"><a href="#3-1-ThreadLocal-简介" class="headerlink" title="3.1. ThreadLocal 简介"></a>3.1. ThreadLocal 简介</h3><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong> JDK中提供的 <code>ThreadLocal</code> 类正是为了解决这样的问题。 <strong><code>ThreadLocal</code> 类主要解决的就是让每个线程绑定自己的值，可以将 <code>ThreadLocal</code> 类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p><p><strong>如果你创建了一个 <code>ThreadLocal</code> 变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是 <code>ThreadLocal</code> 变量名的由来。他们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</strong></p><p>再举个简单的例子： </p><p>比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么 ThreadLocal 就是用来避免这两个线程竞争的。</p><h3 id="3-2-ThreadLocal-示例"><a href="#3-2-ThreadLocal-示例" class="headerlink" title="3.2. ThreadLocal 示例"></a>3.2. ThreadLocal 示例</h3><p>相信看了上面的解释，大家已经搞懂 ThreadLocal 类是个什么东西了。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>text<span class="token punctuation">.</span>SimpleDateFormat<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Random<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalExample</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> ThreadLocal<span class="token operator">&lt;</span>SimpleDateFormat<span class="token operator">></span> formatter <span class="token operator">=</span> ThreadLocal<span class="token punctuation">.</span><span class="token function">withInitial</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyyMMdd HHmm"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        ThreadLocalExample obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">""</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread Name= "</span><span class="token operator">+</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" default Formatter = "</span><span class="token operator">+</span>formatter<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPattern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//formatter pattern is changed here by thread, but it won't reflect to other threads</span>        formatter<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread Name= "</span><span class="token operator">+</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" formatter = "</span><span class="token operator">+</span>formatter<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPattern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Output:</p><pre class=" language-java"><code class="language-java">Thread Name<span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">default</span> Formatter <span class="token operator">=</span> yyyyMMdd HHmmThread Name<span class="token operator">=</span> <span class="token number">0</span> formatter <span class="token operator">=</span> yy<span class="token operator">-</span>M<span class="token operator">-</span>d ah<span class="token operator">:</span>mmThread Name<span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">default</span> Formatter <span class="token operator">=</span> yyyyMMdd HHmmThread Name<span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">default</span> Formatter <span class="token operator">=</span> yyyyMMdd HHmmThread Name<span class="token operator">=</span> <span class="token number">1</span> formatter <span class="token operator">=</span> yy<span class="token operator">-</span>M<span class="token operator">-</span>d ah<span class="token operator">:</span>mmThread Name<span class="token operator">=</span> <span class="token number">3</span> <span class="token keyword">default</span> Formatter <span class="token operator">=</span> yyyyMMdd HHmmThread Name<span class="token operator">=</span> <span class="token number">2</span> formatter <span class="token operator">=</span> yy<span class="token operator">-</span>M<span class="token operator">-</span>d ah<span class="token operator">:</span>mmThread Name<span class="token operator">=</span> <span class="token number">4</span> <span class="token keyword">default</span> Formatter <span class="token operator">=</span> yyyyMMdd HHmmThread Name<span class="token operator">=</span> <span class="token number">3</span> formatter <span class="token operator">=</span> yy<span class="token operator">-</span>M<span class="token operator">-</span>d ah<span class="token operator">:</span>mmThread Name<span class="token operator">=</span> <span class="token number">4</span> formatter <span class="token operator">=</span> yy<span class="token operator">-</span>M<span class="token operator">-</span>d ah<span class="token operator">:</span>mmThread Name<span class="token operator">=</span> <span class="token number">5</span> <span class="token keyword">default</span> Formatter <span class="token operator">=</span> yyyyMMdd HHmmThread Name<span class="token operator">=</span> <span class="token number">5</span> formatter <span class="token operator">=</span> yy<span class="token operator">-</span>M<span class="token operator">-</span>d ah<span class="token operator">:</span>mmThread Name<span class="token operator">=</span> <span class="token number">6</span> <span class="token keyword">default</span> Formatter <span class="token operator">=</span> yyyyMMdd HHmmThread Name<span class="token operator">=</span> <span class="token number">6</span> formatter <span class="token operator">=</span> yy<span class="token operator">-</span>M<span class="token operator">-</span>d ah<span class="token operator">:</span>mmThread Name<span class="token operator">=</span> <span class="token number">7</span> <span class="token keyword">default</span> Formatter <span class="token operator">=</span> yyyyMMdd HHmmThread Name<span class="token operator">=</span> <span class="token number">7</span> formatter <span class="token operator">=</span> yy<span class="token operator">-</span>M<span class="token operator">-</span>d ah<span class="token operator">:</span>mmThread Name<span class="token operator">=</span> <span class="token number">8</span> <span class="token keyword">default</span> Formatter <span class="token operator">=</span> yyyyMMdd HHmmThread Name<span class="token operator">=</span> <span class="token number">9</span> <span class="token keyword">default</span> Formatter <span class="token operator">=</span> yyyyMMdd HHmmThread Name<span class="token operator">=</span> <span class="token number">8</span> formatter <span class="token operator">=</span> yy<span class="token operator">-</span>M<span class="token operator">-</span>d ah<span class="token operator">:</span>mmThread Name<span class="token operator">=</span> <span class="token number">9</span> formatter <span class="token operator">=</span> yy<span class="token operator">-</span>M<span class="token operator">-</span>d ah<span class="token operator">:</span>mm</code></pre><p>从输出中可以看出，Thread-0 已经改变了 formatter 的值，但 thread-2 仍然是默认格式化程序与初始化值相同，其他线程也一样。</p><p>上面有一段代码用到了创建 <code>ThreadLocal</code> 变量的那段代码用到了 Java 8 的知识，它等于下面这段代码，如果你写了下面这段代码的话，IDEA会提示你转换为Java 8的格式。因为 ThreadLocal 类在Java 8中扩展，使用一个新的方法 <code>withInitial()</code> ，将 Supplier 功能接口作为参数。</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> ThreadLocal<span class="token operator">&lt;</span>SimpleDateFormat<span class="token operator">></span> formatter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span>SimpleDateFormat<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> SimpleDateFormat <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyyMMdd HHmm"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h3 id="3-3-ThreadLocal-原理"><a href="#3-3-ThreadLocal-原理" class="headerlink" title="3.3. ThreadLocal 原理"></a>3.3. ThreadLocal 原理</h3><p>从 <code>Thread</code> 类源代码入手。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment" spellcheck="true">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span>ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap threadLocals <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span>ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap inheritableThreadLocals <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>从上面 <code>Thread</code> 类源代码可以看出 <code>Thread</code> 类中有一个 <code>threadLocals</code> 和 一个  <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code>  类型的变量,我们可以把 <code>ThreadLocalMap</code>  理解为 <code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code> 。默认情况下这两个变量都是 null ，只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set()</code> 或 <code>get()</code> 方法时才创建它们，实际上调用这两个方法的时候，我们调用的是 <code>ThreadLocalMap</code> 类对应的 <code>get()</code>、<code>set()</code>方法。</p><p><code>ThreadLocal</code>类的<code>set()</code>方法</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span>            map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ThreadLocalMap <span class="token function">getMap</span><span class="token punctuation">(</span>Thread t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> t<span class="token punctuation">.</span>threadLocals<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>通过上面这些内容，我们足以通过猜测得出结论：<strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是 <code>ThreadLocalMap</code>的封装，传递了变量值。</strong> <code>ThrealLocal</code> 类中可以通过 <code>Thread.currentThread()</code> 获取到当前线程对象后，直接通过 <code>getMap(Thread t)</code> 可以访问到该线程的 <code>ThreadLocalMap</code> 对象。</p><p><strong>每个 <code>Thread</code> 中都具备一个 <code>ThreadLocalMap</code> ，而 <code>ThreadLocalMap</code> 可以存储以 <code>ThreadLocal</code> 为key ，Object 对象为 value 的键值对。</strong> </p><pre class=" language-java"><code class="language-java"><span class="token function">ThreadLocalMap</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> firstKey<span class="token punctuation">,</span> Object firstValue<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>比如我们在同一个线程中声明了两个 <code>ThreadLocal</code> 对象的话，会使用 <code>Thread</code> 内部仅有的那个 <code>ThreadLocalMap</code> 存放数据的，<code>ThreadLocalMap</code> 的 key 就是 <code>ThreadLocal</code> 对象，value 就是 <code>ThreadLocal</code> 对象调用 <code>set</code> 方法设置的值。</p><p><img src="https://s1.ax1x.com/2020/04/18/JmBJ2R.jpg" alt="ThreadLocal 数据结构"></p><p><code>ThreadLocalMap</code> 是 <code>ThreadLocal</code> 的静态内部类。</p><p><img src="https://s1.ax1x.com/2020/04/18/JmyMl9.png" alt="ThreadLocal 内部类"></p><h3 id="3-4-ThreadLocal-内存泄露问题"><a href="#3-4-ThreadLocal-内存泄露问题" class="headerlink" title="3.4. ThreadLocal 内存泄露问题"></a>3.4. ThreadLocal 内存泄露问题</h3><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的<strong>弱引用</strong>，而 value 是<strong>强引用</strong>。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry 。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code> 方法后最好手动调用 <code>remove()</code> 方法。</p><pre class=" language-java"><code class="language-java">      <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/** The value associated with this ThreadLocal. */</span>            Object value<span class="token punctuation">;</span>            <span class="token function">Entry</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> k<span class="token punctuation">,</span> Object v<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">super</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>                value <span class="token operator">=</span> v<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span></code></pre><p><strong>弱引用介绍：</strong></p><blockquote><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p></blockquote><h2 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4. 线程池"></a>4. 线程池</h2><h3 id="4-1-为什么要用线程池？"><a href="#4-1-为什么要用线程池？" class="headerlink" title="4.1. 为什么要用线程池？"></a>4.1. 为什么要用线程池？</h3><blockquote><p><strong>池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</strong></p></blockquote><p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p><p>这里借用《Java 并发编程的艺术》提到的来说一下<strong>使用线程池的好处</strong>：</p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="4-2-实现-Runnable-接口和-Callable-接口的区别"><a href="#4-2-实现-Runnable-接口和-Callable-接口的区别" class="headerlink" title="4.2. 实现 Runnable 接口和 Callable 接口的区别"></a>4.2. 实现 Runnable 接口和 Callable 接口的区别</h3><p><strong><code>Runnable</code></strong> 自Java 1.0 以来一直存在，但 <strong><code>Callable</code></strong> 仅在Java 1.5 中引入，目的就是为了来处理 <strong><code>Runnable</code></strong> 不支持的用例。<strong><code>Runnable</code> 接口</strong>不会返回结果或抛出检查异常，但是 <strong><code>Callable</code> 接口</strong>可以。所以，如果任务不需要返回结果或抛出异常推荐使用 <strong><code>Runnable</code> 接口</strong>，这样代码看起来会更加简洁。</p><p>工具类 <code>Executors</code> 可以实现 <code>Runnable</code> 对象和 <code>Callable</code> 对象之间的相互转换。（<code>Executors.callable(Runnable task)</code> 或 <code>Executors.callable(Runnable task, Object resule)</code>）。</p><p><code>Runnable.java</code></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">/**    * 被线程执行，没有返回值也无法抛出异常    */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>Callable.java</code></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 计算结果，或在无法这样做时抛出异常。     * @return 计算得出的结果     * @throws 如果无法计算结果，则抛出异常     */</span>    V <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="4-3-执行-execute-方法和-submit-方法的区别是什么呢？"><a href="#4-3-执行-execute-方法和-submit-方法的区别是什么呢？" class="headerlink" title="4.3. 执行 execute() 方法和 submit() 方法的区别是什么呢？"></a>4.3. 执行 execute() 方法和 submit() 方法的区别是什么呢？</h3><ol><li><strong><code>execute()</code> 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li><li><strong><code>submit()</code> 方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code> 方法来获取返回值，<code>get()</code> 方法会阻塞当前线程直到任务完成，而使用 <code>get(long timeout, TimeUnit unit)</code> 方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ol><p>我们以 <strong>AbstractExecutorService</strong> 接口中的一个 <code>submit()</code> 方法为例子来看看源代码：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> Future<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        RunnableFuture<span class="token operator">&lt;</span>Void<span class="token operator">></span> ftask <span class="token operator">=</span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">execute</span><span class="token punctuation">(</span>ftask<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ftask<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>上面方法调用的 <code>newTaskFor()</code> 方法返回了一个 <code>FutureTask</code> 对象。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">protected</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> RunnableFuture<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>Runnable runnable<span class="token punctuation">,</span> T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>runnable<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>我们再来看看 <code>execute()</code> 方法：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span></code></pre><h3 id="4-4-如何创建线程池"><a href="#4-4-如何创建线程池" class="headerlink" title="4.4. 如何创建线程池"></a>4.4. 如何创建线程池</h3><p>《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 <strong>ThreadPoolExecutor</strong> 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><blockquote><p>Executors 返回线程池对象的弊端如下：</p><ul><li><strong>FixedThreadPool 和 SingleThreadExecutor：</strong>允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致OOM。</li><li><strong>CachedThreadPool 和 ScheduledThreadPool：</strong>允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</li></ul></blockquote><p><strong>方式一：通过构造方法实现</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL215LWJsb2ctdG8tdXNlLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8xOC00LTE2LzE3ODU4MjMwLmpwZw?x-oss-process=image/format,png" alt="ThreadPoolExecutor 构造方法"><br><strong>方式二：通过 Executor 框架的工具类 Executors 来实现</strong><br>我们可以创建三种类型的 ThreadPoolExecutor ：</p><ul><li><strong>FixedThreadPool：</strong> 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li><strong>SingleThreadExecutor：</strong> 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><strong>CachedThreadPool：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li></ul><p>对应 Executors 工具类中的方法如图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL215LWJsb2ctdG8tdXNlLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8xOC00LTE2LzEzMjk2OTAxLmpwZw?x-oss-process=image/format,png" alt="Executor 框架的工具类"></p><h3 id="4-5-ThreadPoolExecutor-类分析"><a href="#4-5-ThreadPoolExecutor-类分析" class="headerlink" title="4.5 ThreadPoolExecutor 类分析"></a>4.5 ThreadPoolExecutor 类分析</h3><p><code>ThreadPoolExecutor</code> 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么），这里就不贴代码讲了，比较简单。</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 用给定的初始参数创建一个新的ThreadPoolExecutor。     */</span>    <span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                              <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                              <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                              TimeUnit unit<span class="token punctuation">,</span>                              BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>                              ThreadFactory threadFactory<span class="token punctuation">,</span>                              RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>            maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>            maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>            keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> null <span class="token operator">||</span> threadFactory <span class="token operator">==</span> null <span class="token operator">||</span> handler <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><blockquote><p><strong>下面这些对创建线程池非常重要，在后面使用线程池的过程中你一定会用到！所以，务必拿着小本本记清楚。</strong></p></blockquote><h4 id="4-5-1-ThreadPoolExecutor构造函数重要参数分析"><a href="#4-5-1-ThreadPoolExecutor构造函数重要参数分析" class="headerlink" title="4.5.1 ThreadPoolExecutor构造函数重要参数分析"></a>4.5.1 <code>ThreadPoolExecutor</code>构造函数重要参数分析</h4><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code>：</strong>核心线程数线程数定义了最小可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code>：</strong>当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>：</strong>当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code> 其他常见参数：</p><ol><li><strong><code>keepAliveTime</code>：</strong>当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code> 才会被回收销毁。</li><li><strong><code>unit</code>：</strong><code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>threadFactory</code>：</strong>executor 创建新线程的时候会用到。</li><li><strong><code>handler</code>：</strong>饱和策略。关于饱和策略下面单独介绍一下。</li></ol><h4 id="4-5-2-ThreadPoolExecutor-饱和策略"><a href="#4-5-2-ThreadPoolExecutor-饱和策略" class="headerlink" title="4.5.2 ThreadPoolExecutor 饱和策略"></a>4.5.2 <code>ThreadPoolExecutor</code> 饱和策略</h4><p><strong><code>ThreadPoolExecutor</code> 饱和策略定义:</strong></p><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略：</p><ul><li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong>抛出 <code>RejectedExecutionException</code> 来拒绝新任务的处理。</li><li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong>调用执行自己的线程运行任务。您不会任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。</li><li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li><li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li></ul><p>举个例子： </p><blockquote><p>Spring 通过 <code>ThreadPoolTaskExecutor</code> 或者我们直接通过 <code>ThreadPoolExecutor</code> 的构造函数创建线程池的时候，当我们不指定 <code>RejectedExecutionHandler</code> 饱和策略的话来配置线程池的时候默认使用的是 <code>ThreadPoolExecutor.AbortPolicy</code>。在默认情况下，<code>ThreadPoolExecutor</code> 将抛出 <code>RejectedExecutionException</code> 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 <code>ThreadPoolExecutor.CallerRunsPolicy</code> 。当最大池被填满时，此策略为我们提供可伸缩队列。（这个直接查看 <code>ThreadPoolExecutor</code> 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了。）</p></blockquote><h3 id="4-6-一个简单的线程池Demo：Runnable-ThreadPoolExecutor"><a href="#4-6-一个简单的线程池Demo：Runnable-ThreadPoolExecutor" class="headerlink" title="4.6 一个简单的线程池Demo：Runnable+ThreadPoolExecutor"></a>4.6 一个简单的线程池Demo：<code>Runnable</code>+<code>ThreadPoolExecutor</code></h3><p>为了让大家更清楚上面的面试题中的一些概念，我写了一个简单的线程池 Demo。</p><p>首先创建一个 <code>Runnable</code> 接口的实现类（当然也可以是 <code>Callable</code> 接口，我们上面也说了两者的区别。）</p><p><code>MyRunnable.java</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Date<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。 * @author shuang.kou */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String command<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MyRunnable</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>command <span class="token operator">=</span> s<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" Start. Time = "</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">processCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" End. Time = "</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>command<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>编写测试程序，我们这里以阿里巴巴推荐的使用 <code>ThreadPoolExecutor</code> 构造函数自定义参数的方式来创建线程池。</p><p><code>ThreadPoolExecutorDemo.java</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ArrayBlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ThreadPoolExecutor<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolExecutorDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CORE_POOL_SIZE <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_POOL_SIZE <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> QUEUE_CAPACITY <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Long KEEP_ALIVE_TIME <span class="token operator">=</span> 1L<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//使用阿里巴巴推荐的创建线程池的方式</span>        <span class="token comment" spellcheck="true">//通过ThreadPoolExecutor构造函数自定义参数创建</span>        ThreadPoolExecutor executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>                CORE_POOL_SIZE<span class="token punctuation">,</span>                MAX_POOL_SIZE<span class="token punctuation">,</span>                KEEP_ALIVE_TIME<span class="token punctuation">,</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>QUEUE_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>CallerRunsPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span>            Runnable worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token string">""</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//执行Runnable</span>            executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>worker<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//终止线程池</span>        executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>executor<span class="token punctuation">.</span><span class="token function">isTerminated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Finished all threads"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以看到我们上面的代码指定了：</p><ol><li><code>corePoolSize</code>：核心线程数为 5。</li><li><code>maximumPoolSize</code> ：最大线程数 10。</li><li><code>keepAliveTime</code> ：等待时间为 1L。</li><li><code>unit</code>：等待时间的单位为 TimeUnit.SECONDS。</li><li><code>workQueue</code>：任务队列为 <code>ArrayBlockingQueue</code> ，并且容量为 100。</li><li><code>handler</code>：饱和策略为 <code>CallerRunsPolicy</code>。</li></ol><p><strong>Output：</strong></p><pre class=" language-java"><code class="language-java">pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">44</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">44</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">44</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">44</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">44</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">49</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">54</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">54</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">54</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">54</span> CST <span class="token number">2019</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Tue Nov <span class="token number">12</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span><span class="token operator">:</span><span class="token number">54</span> CST <span class="token number">2019</span></code></pre><h3 id="4-7-线程池原理分析"><a href="#4-7-线程池原理分析" class="headerlink" title="4.7 线程池原理分析"></a>4.7 线程池原理分析</h3><p>承接 4.6 节，我们通过代码输出结果可以看出：<strong>线程池每次会同时执行 5 个任务，这 5 个任务执行完之后，剩余的 5 个任务才会被执行。</strong> 大家可以先通过上面讲解的内容，分析一下到底是咋回事？（自己独立思考一会）</p><p>现在，我们就分析上面的输出内容来简单分析一下线程池原理。</p><p><strong>为了搞懂线程池的原理，我们需要首先分析一下 <code>execute</code> 方法。</strong>在 4.6 节中的 Demo 中我们使用 <code>executor.execute(worker)</code> 来提交一个任务到线程池中去，这个方法非常重要，下面我们来看看它的源码：</p><pre class=" language-java"><code class="language-java">   <span class="token comment" spellcheck="true">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span>   <span class="token keyword">private</span> <span class="token keyword">final</span> AtomicInteger ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span>RUNNING<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> c <span class="token operator">&amp;</span> CAPACITY<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果任务为null，则抛出异常。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// ctl 中保存的线程池当前的一些状态信息</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//  下面会涉及到 3 步 操作</span>        <span class="token comment" spellcheck="true">// 1.首先判断当前线程池中之行的任务数量是否小于 corePoolSize</span>        <span class="token comment" spellcheck="true">// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 2.如果当前之行的任务数量大于等于 corePoolSize 的时候就会走到这里</span>        <span class="token comment" spellcheck="true">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态才会被并且队列可以加入任务，该任务才会被加入进去</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 如果当前线程池为空就新创建一个线程并执行。</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span>        <span class="token comment" spellcheck="true">//如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>通过下图可以更好的对上面这 3 步做一个展示，下图是我为了省事直接从网上找到，原地址不明。</p><p><img src="https://s1.ax1x.com/2020/04/16/JkHiF0.png" alt="图解线程池实现原理"></p><p>现在，让我们在回到 4.6 节我们写的 Demo， 现在应该是不是很容易就可以搞懂它的原理了呢？</p><p>没搞懂的话，也没关系，可以看看我的分析：</p><blockquote><p>我们在代码中模拟了 10 个任务，我们配置的核心线程数为 5 、等待队列容量为 100 ，所以每次只可能存在 5 个任务同时执行，剩下的 5 个任务会被放到等待队列中去。当前的 5 个任务之行完成后，才会之行剩下的 5 个任务。</p></blockquote><h2 id="5-Atomic-原子类"><a href="#5-Atomic-原子类" class="headerlink" title="5. Atomic 原子类"></a>5. Atomic 原子类</h2><h3 id="5-1-介绍一下Atomic-原子类"><a href="#5-1-介绍一下Atomic-原子类" class="headerlink" title="5.1. 介绍一下Atomic 原子类"></a>5.1. 介绍一下Atomic 原子类</h3><p>Atomic** 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 <strong>Atomic</strong> 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p><p>所以，所谓原子类说简单点就是具有原子/原子操作特征的类。</p><p>并发包 <code>java.util.concurrent</code> 的原子类都存放在 <code>java.util.concurrent.atomic</code> 下，如下图所示。</p><p><img src="https://s1.ax1x.com/2020/04/17/JZ53CV.png" alt="JUC 原子类概览"></p><h3 id="5-2-JUC-包中的原子类是哪4类"><a href="#5-2-JUC-包中的原子类是哪4类" class="headerlink" title="5.2. JUC 包中的原子类是哪4类?"></a>5.2. JUC 包中的原子类是哪4类?</h3><p><strong>基本类型</strong> </p><p>使用原子的方式更新基本类型</p><ul><li>AtomicInteger：<strong>整型</strong>原子类</li><li>AtomicLong：<strong>长整型</strong>原子类</li><li>AtomicBoolean：<strong>布尔型</strong>原子类</li></ul><p><strong>数组类型</strong></p><p>使用原子的方式更新数组里的某个元素</p><ul><li>AtomicIntegerArray：<strong>整型数组</strong>原子类</li><li>AtomicLongArray：<strong>长整型数组</strong>原子类</li><li>AtomicReferenceArray：<strong>引用类型数组</strong>原子类</li></ul><p><strong>引用类型</strong></p><ul><li>AtomicReference：<strong>引用类型</strong>原子类</li><li>AtomicStampedReference：原子更新<strong>带有版本号的引用类型</strong></li><li>AtomicMarkableReference：原子更新<strong>带有标记位的引用类型</strong></li></ul><p><strong>对象的属性修改类型</strong></p><ul><li>AtomicIntegerFieldUpdater：原子更新<strong>整型</strong>字段的更新器</li><li>AtomicLongFieldUpdater：原子更新<strong>长整型</strong>字段的更新器</li><li>AtomicReferenceFieldUpdater：原子更新<strong>引用类型</strong>里的字段</li></ul><h3 id="5-3-讲讲-AtomicInteger-的使用"><a href="#5-3-讲讲-AtomicInteger-的使用" class="headerlink" title="5.3. 讲讲 AtomicInteger 的使用"></a>5.3. 讲讲 AtomicInteger 的使用</h3><p> <strong>AtomicInteger 类常用方法</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//获取当前的值</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> newValue<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//获取当前的值，并设置新的值</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//获取当前的值，并自增</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//获取当前的值，并自减</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> delta<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//获取当前的值，并加上预期的值</span><span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lazySet</span><span class="token punctuation">(</span><span class="token keyword">int</span> newValue<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></code></pre><p> <strong>AtomicInteger 类的使用示例</strong></p><p>使用 AtomicInteger 之后，不用对 increment() 方法加锁也可以保证线程安全。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">AtomicIntegerTest</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//使用AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  count<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>       <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="5-4-能不能给我简单介绍一下-AtomicInteger-类的原理"><a href="#5-4-能不能给我简单介绍一下-AtomicInteger-类的原理" class="headerlink" title="5.4. 能不能给我简单介绍一下 AtomicInteger 类的原理"></a>5.4. 能不能给我简单介绍一下 AtomicInteger 类的原理</h3><p>AtomicInteger 线程安全原理简单分析。</p><p>AtomicInteger 类的部分源码：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Unsafe unsafe <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> valueOffset<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            valueOffset <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span>                <span class="token punctuation">(</span>AtomicInteger<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span></code></pre><p>AtomicInteger 类主要利用 <strong>CAS (compare and swap) + volatile 和 Native</strong> 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><p>CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 <code>objectFieldOffset()</code> 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p><p>关于 Atomic 原子类这部分更多内容可以查看我的这篇文章：并发编程面试必备：<a href="https://www.niewenjun.com/2020/04/17/hou-duan/bing-fa/atomic-yuan-zi-lei-zong-jie">JUC 中的 Atomic 原子类总结</a></p><h2 id="6-AQS"><a href="#6-AQS" class="headerlink" title="6. AQS"></a>6. AQS</h2><h3 id="6-1-AQS-介绍"><a href="#6-1-AQS-介绍" class="headerlink" title="6.1. AQS 介绍"></a>6.1. AQS 介绍</h3><p>AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。</p><p><img src="https://s1.ax1x.com/2020/04/17/JZHTBD.png" alt="AQS 概览"></p><p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 <strong>ReentrantLock</strong>，<strong>Semaphore</strong>，其他的诸如 <strong>ReentrantReadWriteLock</strong>，<strong>SynchronousQueue</strong>，<strong>FutureTask（jdk 1.7）</strong>等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。</p><h3 id="6-2-AQS-原理分析"><a href="#6-2-AQS-原理分析" class="headerlink" title="6.2. AQS 原理分析"></a>6.2. AQS 原理分析</h3><p>AQS 原理这部分参考了部分博客，在 5.2 节末尾放了链接。</p><blockquote><p>在面试中被问到并发知识的时候，大多都会被问到“请你说一下自己对于AQS原理的理解”。下面给大家一个示例供大家参加，面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来。</p></blockquote><p>下面大部分内容其实在 AQS 类注释上已经给出了，不过是英语看着比较吃力一点，感兴趣的话可以看看源码。</p><h4 id="6-2-1-AQS-原理概览"><a href="#6-2-1-AQS-原理概览" class="headerlink" title="6.2.1. AQS 原理概览"></a>6.2.1. AQS 原理概览</h4><p><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 <code>CLH</code> 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p><blockquote><p>CLH（Craig, Landin, and Hagersten）队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p></blockquote><p>看个 AQS（AbstractQueuedSynchronizer）原理图：</p><p><img src="https://s1.ax1x.com/2020/04/17/JZH7He.png" alt="AQS 原理图"></p><p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 <strong>CAS</strong> 对该同步状态进行原子操作实现对其值的修改。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//共享变量，使用volatile修饰保证线程可见性</span></code></pre><p>状态信息通过 protected 类型的 <code>getState</code>，<code>setState</code>，<code>compareAndSetState</code> 进行操作。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//返回同步状态的当前值</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> state<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 设置同步状态的值</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">int</span> newState<span class="token punctuation">)</span> <span class="token punctuation">{</span>         state <span class="token operator">=</span> newState<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="6-2-2-AQS-对资源的共享方式"><a href="#6-2-2-AQS-对资源的共享方式" class="headerlink" title="6.2.2. AQS 对资源的共享方式"></a>6.2.2. AQS 对资源的共享方式</h4><p><strong>AQS定义两种资源共享方式</strong></p><ul><li><strong>Exclusive</strong>（独占）：只有一个线程能执行，如 <strong>ReentrantLock</strong> 。又可分为公平锁和非公平锁：<ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁。</li><li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的。</li></ul></li><li><strong>Share</strong>（共享）：多个线程可同时执行，如 Semaphore/CountDownLatch 。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</li></ul><p>ReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某一资源进行读。</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。</p><h4 id="6-2-3-AQS底层使用了模板方法模式"><a href="#6-2-3-AQS底层使用了模板方法模式" class="headerlink" title="6.2.3. AQS底层使用了模板方法模式"></a>6.2.3. AQS底层使用了模板方法模式</h4><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p><ol><li>使用者继承 <strong><code>AbstractQueuedSynchronizer</code></strong> 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放。）</li><li>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li></ol><p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p><p><strong>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</strong></p><pre class=" language-java"><code class="language-java"><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span><span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span><span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span><span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></code></pre><p>默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code> 。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p><p>以 <strong>ReentrantLock</strong> 为例，state 初始化为 0，表示未锁定状态。A 线程 <code>lock()</code> 时，会调用 <code>tryAcquire()</code> 独占该锁并将 state+1 。此后，其他线程再 <code>tryAcquire()</code> 时就会失败，直到 A 线程 <code>unlock()</code> 到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的。</p><p>再以 <strong>CountDownLatch</strong> 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 <code>countDown()</code> 一次，state 会 <strong>CAS</strong>（Compare And Swap）减 1。等到所有子线程都执行完后（即 state=0 ），会 <code>unpark()</code> 主调用线程，然后主调用线程就会从 <code>await()</code> 函数返回，继续后余动作。</p><p>一般来说，自定义同步器要么是独占方式，要么是共享方式，他们也只需实现 <code>tryAcquire-tryRelease</code> 、<code>tryAcquireShared-tryReleaseShared</code> 中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如 <code>ReentrantReadWriteLock</code> 。</p><p>推荐两篇 AQS 原理和相关源码分析的文章：</p><ul><li><a href="http://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">http://www.cnblogs.com/waterystone/p/4920797.html</a></li><li><a href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html</a></li></ul><h3 id="6-3-AQS-组件总结"><a href="#6-3-AQS-组件总结" class="headerlink" title="6.3. AQS 组件总结"></a>6.3. AQS 组件总结</h3><p><img src="https://s1.ax1x.com/2020/04/17/JZ5l40.md.png" alt="CyclicBarrier 和 CountDownLatch 的区别"></p><ul><li><strong>Semaphore（信号量）——允许多个线程同时访问：</strong> synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore（信号量）可以指定多个线程同时访问某个资源。</li><li><strong>CountDownLatch（倒计时器）：</strong> CountDownLatch 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li><li><strong>CyclicBarrier（循环栅栏）：</strong> CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 <code>CyclicBarrier(int parties)</code> ，其参数表示屏障拦截的线程数量，每个线程调用 <code>await()</code> 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li></ul><h2 id="7-Reference"><a href="#7-Reference" class="headerlink" title="7 Reference"></a>7 Reference</h2><ul><li>《深入理解 Java 虚拟机》</li><li>《实战 Java 高并发程序设计》</li><li>《Java并发编程的艺术》</li><li><a href="http://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">http://www.cnblogs.com/waterystone/p/4920797.html</a></li><li><a href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html</a></li><li><a href="https://www.journaldev.com/1076/java-threadlocal-example" target="_blank" rel="noopener">https://www.journaldev.com/1076/java-threadlocal-example</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发基础常见面试题</title>
      <link href="/2020/04/18/hou-duan/bing-fa/java-bing-fa-ji-chu-chang-jian-mian-shi-ti/"/>
      <url>/2020/04/18/hou-duan/bing-fa/java-bing-fa-ji-chu-chang-jian-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-并发基础常见面试题总结"><a href="#Java-并发基础常见面试题总结" class="headerlink" title="Java 并发基础常见面试题总结"></a>Java 并发基础常见面试题总结</h1><h2 id="1-什么是线程和进程？"><a href="#1-什么是线程和进程？" class="headerlink" title="1. 什么是线程和进程？"></a>1. 什么是线程和进程？</h2><h3 id="1-1-何为进程？"><a href="#1-1-何为进程？" class="headerlink" title="1.1. 何为进程？"></a>1.1. 何为进程？</h3><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p><p>如下图所示，在 Windows 中通过查看任务管理器的方式，我们就可以清楚看到 Windows 当前运行的进程（.exe 文件的运行）。</p><p><img src="https://s1.ax1x.com/2020/04/18/JeC3Pf.png" alt="进程示例图片 - Windows"></p><h3 id="1-2-何为线程？"><a href="#1-2-何为线程？" class="headerlink" title="1.2. 何为线程？"></a>1.2. 何为线程？</h3><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p>Java 程序天生就是多线程程序，我们可以通过 JMX 来看一下一个普通的 Java 程序有哪些线程，代码如下。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MultiThread</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取 Java 线程管理 MXBean</span>    ThreadMXBean threadMXBean <span class="token operator">=</span> ManagementFactory<span class="token punctuation">.</span><span class="token function">getThreadMXBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息</span>        ThreadInfo<span class="token punctuation">[</span><span class="token punctuation">]</span> threadInfos <span class="token operator">=</span> threadMXBean<span class="token punctuation">.</span><span class="token function">dumpAllThreads</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 遍历线程信息，仅打印线程 ID 和线程名称信息</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>ThreadInfo threadInfo <span class="token operator">:</span> threadInfos<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"["</span> <span class="token operator">+</span> threadInfo<span class="token punctuation">.</span><span class="token function">getThreadId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"] "</span> <span class="token operator">+</span> threadInfo<span class="token punctuation">.</span><span class="token function">getThreadName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上述程序输出如下（输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行 main 方法即可）：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> Attach Listener <span class="token comment" spellcheck="true">//添加事件</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> Signal Dispatcher <span class="token comment" spellcheck="true">// 分发处理给 JVM 信号的线程</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> Finalizer <span class="token comment" spellcheck="true">//调用对象 finalize 方法的线程</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> Reference Handler <span class="token comment" spellcheck="true">//清除 reference 线程</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> main <span class="token comment" spellcheck="true">//main 线程,程序入口</span></code></pre><p>从上面的输出内容可以看出：<strong>一个 Java 程序的运行是 main 线程和多个其他线程同时运行</strong>。</p><h2 id="2-请简要描述线程与进程的关系，区别及优缺点？"><a href="#2-请简要描述线程与进程的关系，区别及优缺点？" class="headerlink" title="2. 请简要描述线程与进程的关系，区别及优缺点？"></a>2. 请简要描述线程与进程的关系，区别及优缺点？</h2><h4 id="从-JVM-角度说进程和线程之间的关系"><a href="#从-JVM-角度说进程和线程之间的关系" class="headerlink" title="从 JVM 角度说进程和线程之间的关系"></a><strong>从 JVM 角度说进程和线程之间的关系</strong></h4><h3 id="2-1-图解进程和线程的关系"><a href="#2-1-图解进程和线程的关系" class="headerlink" title="2.1. 图解进程和线程的关系"></a>2.1. 图解进程和线程的关系</h3><p>下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。如果你对 Java 内存区域 (运行时数据区) 这部分知识不太了解的话可以阅读一下这篇文章：[《可能是把 Java 内存区域讲的最清楚的一篇文章》](<a href="https://www.niewenjun.com/2020/04/19/hou-duan/jvm/java-nei-cun-qu-yu-xiang-jie&quot;《可能是把">https://www.niewenjun.com/2020/04/19/hou-duan/jvm/java-nei-cun-qu-yu-xiang-jie&quot;《可能是把</a> Java 内存区域讲的最清楚的一篇文章》”)</p><p><img src="https://s1.ax1x.com/2020/04/19/JuYRyT.png" alt="Java 内存区域"></p><p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区（JDK 1.8 之后的元空间）</strong>资源，但是每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p><p><strong>总结：</strong> <strong>线程是进程划分成的更小的运行单位。</strong>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><p>下面是该知识点的扩展内容！</p><p>下面来思考这样一个问题：为什么<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>是线程私有的呢？为什么堆和方法区是线程共享的呢？</p><h3 id="2-2-程序计数器为什么是私有的？"><a href="#2-2-程序计数器为什么是私有的？" class="headerlink" title="2.2. 程序计数器为什么是私有的？"></a>2.2. 程序计数器为什么是私有的？</h3><p>程序计数器主要有下面两个作用：</p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p>需要注意的是，如果执行的是 <code>Native</code> 方法，那么程序计数器记录的是 <code>Undefined</code> 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p><p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p><h3 id="2-3-虚拟机栈和本地方法栈为什么是私有的？"><a href="#2-3-虚拟机栈和本地方法栈为什么是私有的？" class="headerlink" title="2.3. 虚拟机栈和本地方法栈为什么是私有的？"></a>2.3. 虚拟机栈和本地方法栈为什么是私有的？</h3><ul><li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li><li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li></ul><p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p><h3 id="2-4-一句话简单了解堆和方法区"><a href="#2-4-一句话简单了解堆和方法区" class="headerlink" title="2.4. 一句话简单了解堆和方法区"></a>2.4. 一句话简单了解堆和方法区</h3><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象（所有对象都在这里分配内存），方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h2 id="3-说说并发与并行的区别？"><a href="#3-说说并发与并行的区别？" class="headerlink" title="3. 说说并发与并行的区别？"></a>3. 说说并发与并行的区别？</h2><ul><li><strong>并发：</strong> 同一时间段，多个任务都在执行（单位时间内不一定同时执行）。</li><li><strong>并行：</strong> 单位时间内，多个任务同时执行。</li></ul><h2 id="4-为什么要使用多线程呢？"><a href="#4-为什么要使用多线程呢？" class="headerlink" title="4. 为什么要使用多线程呢？"></a>4. 为什么要使用多线程呢？</h2><p>先从总体上来说：</p><ul><li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这<strong>减少了线程上下文切换的开销</strong>。</li><li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以<strong>大大提高系统整体的并发能力以及性能</strong>。</li></ul><p>再深入到计算机底层来探讨：</p><ul><li><strong>单核时代：</strong>在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50% 左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100% 了。</li><li><strong>多核时代：</strong>多核时代多线程主要是为了<strong>提高 CPU 利用率</strong>。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。</li></ul><h2 id="5-使用多线程可能带来什么问题？"><a href="#5-使用多线程可能带来什么问题？" class="headerlink" title="5. 使用多线程可能带来什么问题？"></a>5. 使用多线程可能带来什么问题？</h2><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：<strong>内存泄漏、死锁、线程不安全</strong>等等。</p><h2 id="6-说说线程的生命周期和状态？"><a href="#6-说说线程的生命周期和状态？" class="headerlink" title="6. 说说线程的生命周期和状态？"></a>6. 说说线程的生命周期和状态？</h2><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。</p><p><img src="https://s1.ax1x.com/2020/04/18/JmDWlR.png" alt="Java 线程的状态 "></p><p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：</p><p><img src="https://s1.ax1x.com/2020/04/18/JmD7kD.png" alt="Java 线程状态变迁 "></p><p>由上图可以看出：线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><blockquote><p>操作系统隐藏 Java 虚拟机（JVM）中的 RUNNABLE 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：<a href="https://howtodoinjava.com/" target="_blank" rel="noopener" title="HowToDoInJava">HowToDoInJava</a>：<a href="https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/" target="_blank" rel="noopener" title="Java Thread Life Cycle and Thread States">Java Thread Life Cycle and Thread States</a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p></blockquote><p><img src="https://s1.ax1x.com/2020/04/18/JmrPhQ.png" alt="RUNNABLE-VS-RUNNING"></p><p>当线程执行 <code>wait()</code> 方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME_WAITING（超时等待）</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep(long millis)</code> 方法或 <code>wait(long millis)</code> 方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 <strong>RUNNABLE</strong> 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的 <code>run()</code> 方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p><h2 id="7-什么是上下文切换"><a href="#7-什么是上下文切换" class="headerlink" title="7. 什么是上下文切换?"></a>7. 什么是上下文切换?</h2><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</p><p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p><p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p><p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p><h2 id="8-什么是线程死锁？如何避免死锁？"><a href="#8-什么是线程死锁？如何避免死锁？" class="headerlink" title="8. 什么是线程死锁？如何避免死锁？"></a>8. 什么是线程死锁？如何避免死锁？</h2><h3 id="8-1-认识线程死锁"><a href="#8-1-认识线程死锁" class="headerlink" title="8.1. 认识线程死锁"></a>8.1. 认识线程死锁</h3><p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p><p><img src="https://s1.ax1x.com/2020/04/18/JmrZn0.png" alt="线程死锁示意图"></p><p>下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeadLockDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Object resource1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//资源 1</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Object resource2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//资源 2</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"waiting get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"线程 1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"waiting get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"线程 2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Output：</p><pre class=" language-java"><code class="language-java">Thread<span class="token punctuation">[</span>线程 <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>get resource1Thread<span class="token punctuation">[</span>线程 <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>get resource2Thread<span class="token punctuation">[</span>线程 <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>waiting get resource2Thread<span class="token punctuation">[</span>线程 <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>waiting get resource1</code></pre><p>线程 A 通过 <code>synchronized (resource1)</code> 获得 resource1 的监视器锁，然后通过 <code>Thread.sleep(1000);</code> 让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。</p><p>学过操作系统的朋友都知道产生死锁必须具备以下四个条件：</p><ol><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol><h3 id="8-2-如何避免线程死锁？"><a href="#8-2-如何避免线程死锁？" class="headerlink" title="8.2. 如何避免线程死锁？"></a>8.2. 如何避免线程死锁？</h3><p>我上面说了产生死锁的四个必要条件，为了避免死锁，我们只要破坏产生死锁的四个条件中的其中一个就可以了。现在我们来挨个分析一下：</p><ol><li><strong>破坏互斥条件</strong> ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</li><li><strong>破坏请求与保持条件</strong>  ：一次性申请所有的资源。</li><li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ol><p>我们对线程 2 的代码修改成下面这样就不会产生死锁了。</p><pre class=" language-java"><code class="language-java">        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"waiting get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"线程 2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Output：</p><pre class=" language-java"><code class="language-java">Thread<span class="token punctuation">[</span>线程 <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>get resource1Thread<span class="token punctuation">[</span>线程 <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>waiting get resource2Thread<span class="token punctuation">[</span>线程 <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>get resource2Thread<span class="token punctuation">[</span>线程 <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>get resource1Thread<span class="token punctuation">[</span>线程 <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>waiting get resource2Thread<span class="token punctuation">[</span>线程 <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>get resource2Process finished with exit code <span class="token number">0</span></code></pre><p>我们分析一下上面的代码为什么避免了死锁的发生?</p><p>线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。</p><h2 id="9-说说-sleep-方法和-wait-方法区别和共同点？"><a href="#9-说说-sleep-方法和-wait-方法区别和共同点？" class="headerlink" title="9. 说说 sleep() 方法和 wait() 方法区别和共同点？"></a>9. 说说 sleep() 方法和 wait() 方法区别和共同点？</h2><ul><li>两者最主要的区别在于：<strong>sleep 方法没有释放锁，而 wait 方法释放了锁</strong> 。</li><li>两者都可以暂停线程的执行。</li><li><code>wait()</code> 通常被用于线程间交互/通信，<code>sleep()</code> 通常被用于暂停执行。</li><li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code> 或者 <code>notifyAll()</code> 方法。<code>sleep()</code> 方法执行完成后，线程会自动苏醒。或者可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li></ul><h2 id="10-为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#10-为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="10. 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>10. 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h2><p>这是另一个非常经典的 java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p><p>new 一个 Thread，线程进入了新建状态，调用 <code>start()</code> 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 而<strong>直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它</strong>，所以这并不是多线程工作。</p><p><strong>总结： 调用 start() 方法方可启动线程并使线程进入就绪状态，而 run() 方法只是 Thread 的一个普通方法调用，还是在主线程里执行。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS总结</title>
      <link href="/2020/04/17/hou-duan/bing-fa/aqs-zong-jie/"/>
      <url>/2020/04/17/hou-duan/bing-fa/aqs-zong-jie/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/04/18/Jmw9zt.png" alt="AQS 原理以及 AQS 同步组件总结"></p><blockquote><p>常见问题：AQS 原理？CountDownLatch 和 CyclicBarrier 了解吗，两者的区别是什么？用过 Semaphore 吗？</p></blockquote><h3 id="1-AQS-简单介绍"><a href="#1-AQS-简单介绍" class="headerlink" title="1 AQS 简单介绍"></a>1 AQS 简单介绍</h3><p>AQS 的全称为（AbstractQueuedSynchronizer），这个类在 java.util.concurrent.locks 包下面。</p><p><img src="https://s1.ax1x.com/2020/04/17/JZHTBD.png" alt="AQS 概览"></p><p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 <strong>ReentrantLock</strong>，<strong>Semaphore</strong>，其他的诸如 <strong>ReentrantReadWriteLock</strong>，<strong>SynchronousQueue</strong>，<strong>FutureTask（jdk 1.7）</strong>等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。</p><h3 id="2-AQS-原理"><a href="#2-AQS-原理" class="headerlink" title="2 AQS 原理"></a>2 AQS 原理</h3><blockquote><p>在面试中被问到并发知识的时候，大多都会被问到“请你说一下自己对于 AQS 原理的理解”。下面给大家一个示例供大家参考，面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来。</p></blockquote><p>下面大部分内容其实在 AQS 类注释上已经给出了，不过是英语看着比较吃力一点，感兴趣的话可以看看源码。</p><h4 id="2-1-AQS-原理概览"><a href="#2-1-AQS-原理概览" class="headerlink" title="2.1 AQS 原理概览"></a>2.1 AQS 原理概览</h4><p><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 <code>CLH</code> 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p><blockquote><p>CLH（Craig, Landin, and Hagersten）队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p></blockquote><p>看个 AQS（AbstractQueuedSynchronizer）原理图：</p><p><img src="https://s1.ax1x.com/2020/04/17/JZH7He.png" alt="AQS 原理图"></p><p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 <strong>CAS</strong> 对该同步状态进行原子操作实现对其值的修改。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//共享变量，使用volatile修饰保证线程可见性</span></code></pre><p>状态信息通过 protected 类型的 <code>getState</code>，<code>setState</code>，<code>compareAndSetState</code> 进行操作。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//返回同步状态的当前值</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> state<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 设置同步状态的值</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">int</span> newState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        state <span class="token operator">=</span> newState<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="2-2-AQS-对资源的共享方式"><a href="#2-2-AQS-对资源的共享方式" class="headerlink" title="2.2 AQS 对资源的共享方式"></a>2.2 AQS 对资源的共享方式</h4><p><strong>AQS 定义两种资源共享方式</strong></p><p><strong>1) Exclusive</strong>（独占）</p><p>只有一个线程能执行，如 <strong>ReentrantLock</strong> 。又可分为公平锁和非公平锁，ReentrantLock 同时支持两种锁，下面以 ReentrantLock 对这两种锁的定义做介绍：</p><ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁。</li><li>非公平锁：当线程要获取锁时，先通过两次 CAS 操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。</li></ul><blockquote><p>说明：下面这部分关于 <code>ReentrantLock</code> 源代码内容节选自：<a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2" target="_blank" rel="noopener">https://www.javadoop.com/post/AbstractQueuedSynchronizer-2</a> ，这是一篇很不错文章，推荐阅读。</p></blockquote><p><strong>下面来看 ReentrantLock 中相关的源代码：</strong></p><p>ReentrantLock 默认采用<strong>非公平锁</strong>，因为考虑获得更好的性能，通过 boolean 来决定是否用公平锁（传入 true 用公平锁）。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** Synchronizer providing all implementation mechanics */</span><span class="token keyword">private</span> <span class="token keyword">final</span> Sync sync<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token function">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 默认非公平锁</span>    sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>    sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>ReentrantLock 中公平锁的 <code>lock()</code> 方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">FairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// AbstractQueuedSynchronizer.acquire(int arg)</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 1. 和非公平锁相比，这里多了一个判断：是否有线程在等待</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>非公平锁的 <code>lock()</code> 方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">NonfairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// AbstractQueuedSynchronizer.acquire(int arg)</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span>acquires<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * Performs non-fair tryLock.  tryAcquire is implemented in * subclasses, but both need nonfair try for trylock method. */</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 这里没有对阻塞队列进行判断</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// overflow</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>总结：公平锁和非公平锁只有两处不同：</p><ol><li>非公平锁在调用 <code>lock()</code> 后，首先就会调用 <strong>CAS</strong> 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li><li>非公平锁在 <strong>CAS</strong> 失败后，和公平锁一样都会进入到 <code>tryAcquire()</code> 方法，在 <code>tryAcquire()</code> 方法中，如果发现锁这个时候被释放了（<strong>state == 0</strong>），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li></ol><p>公平锁和非公平锁就这两点区别，如果这两次 <strong>CAS</strong> 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p><p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p><p><strong>2) Share</strong>（共享）</p><p>多个线程可同时执行，如 Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</p><p>ReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某一资源进行读。</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在上层已经帮我们实现好了。</p><h4 id="2-3-AQS-底层使用了模板方法模式"><a href="#2-3-AQS-底层使用了模板方法模式" class="headerlink" title="2.3 AQS 底层使用了模板方法模式"></a>2.3 AQS 底层使用了模板方法模式</h4><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p><ol><li>使用者继承 <strong><code>AbstractQueuedSynchronizer</code></strong> 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放。）</li><li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li></ol><p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用，下面简单的给大家介绍一下模板方法模式，模板方法模式是一个很容易理解的设计模式之一。</p><blockquote><p>模板方法模式是基于”继承“的，主要是为了在不改变模板结构的前提下在子类中重新定义模板中的内容以实现复用代码。举个很简单的例子，假如我们要去一个地方的步骤是：购票 <code>buyTicket()</code> -&gt; 安检 <code>securityCheck()</code> -&gt; 乘坐某某工具回家 <code>ride()</code> -&gt;到达目的地 <code>arrive()</code> 。我们可能乘坐不同的交通工具回家比如飞机或者火车，所以除了 <code>ride()</code> 方法，其他方法的实现几乎相同。我们可以定义一个包含了这些方法的抽象类，然后用户根据自己的需要继承该抽象类然后修改 <code>ride()</code> 方法。</p></blockquote><p><strong>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：</strong></p><pre class=" language-java"><code class="language-java"><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span><span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span><span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span><span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></code></pre><p>默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code> 。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p><p>以 <strong>ReentrantLock</strong> 为例，state 初始化为 0，表示未锁定状态。A 线程 <code>lock()</code> 时，会调用 <code>tryAcquire()</code> 独占该锁并将 state+1 。此后，其他线程再 <code>tryAcquire()</code> 时就会失败，直到 A 线程 <code>unlock()</code> 到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的。</p><p>再以 <strong>CountDownLatch</strong> 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 <code>countDown()</code> 一次，state 会 <strong>CAS</strong>（Compare And Swap）减 1。等到所有子线程都执行完后（即 state=0 ），会 <code>unpark()</code> 主调用线程，然后主调用线程就会从 <code>await()</code> 函数返回，继续后余动作。</p><p>一般来说，自定义同步器要么是独占方式，要么是共享方式，他们也只需实现 <code>tryAcquire-tryRelease</code> 、<code>tryAcquireShared-tryReleaseShared</code> 中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如 <code>ReentrantReadWriteLock</code> 。</p><p>推荐两篇 AQS 原理和相关源码分析的文章：</p><ul><li><a href="http://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">http://www.cnblogs.com/waterystone/p/4920797.html</a></li><li><a href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html</a></li></ul><h3 id="3-Semaphore（信号量）——允许多个线程同时访问"><a href="#3-Semaphore（信号量）——允许多个线程同时访问" class="headerlink" title="3 Semaphore（信号量）——允许多个线程同时访问"></a>3 Semaphore（信号量）——允许多个线程同时访问</h3><p><strong>synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</strong> </p><p>示例代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SemaphoreExample1</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 请求的数量</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> threadCount <span class="token operator">=</span> <span class="token number">550</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span>    ExecutorService threadPool <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 一次只能允许执行的线程数量。</span>    <span class="token keyword">final</span> Semaphore semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">final</span> <span class="token keyword">int</span> threadnum <span class="token operator">=</span> i<span class="token punctuation">;</span>      threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// Lambda 表达式的运用</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>          semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获取一个许可，所以可运行线程数量为20/1=20</span>          <span class="token function">test</span><span class="token punctuation">(</span>threadnum<span class="token punctuation">)</span><span class="token punctuation">;</span>          semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 释放一个许可</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// TODO Auto-generated catch block</span>          e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    threadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"finish"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> threadnum<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 模拟请求的耗时操作</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"threadnum:"</span> <span class="token operator">+</span> threadnum<span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 模拟请求的耗时操作</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>执行 <code>acquire()</code> 方法阻塞，直到有一个许可证可以获得，然后拿走一个许可证；每个 <code>release()</code> 方法增加一个许可证，这可能会释放一个阻塞的 <code>acquire()</code> 方法。然而，其实并没有实际的许可证这个对象，Semaphore 只是维持了一个可获得许可证的数量。 Semaphore 经常用于限制获取某种资源的线程数量。</p><p>当然一次也可以一次拿取和释放多个许可，不过一般没有必要这样做。</p><pre class=" language-java"><code class="language-java">semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获取5个许可，所以可运行线程数量为20/5=4</span><span class="token function">test</span><span class="token punctuation">(</span>threadnum<span class="token punctuation">)</span><span class="token punctuation">;</span>semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获取5个许可，所以可运行线程数量为20/5=4</span></code></pre><p>除了 <code>acquire()</code> 方法之外，另一个比较常用的与之对应的方法是 <code>tryAcquire()</code> 方法，该方法如果获取不到许可就立即返回 false。</p><p>Semaphore 有两种模式，公平模式和非公平模式。</p><ul><li><strong>公平模式：</strong> 调用 <code>acquire()</code> 的顺序就是获取许可证的顺序，遵循 FIFO；</li><li><strong>非公平模式：</strong> 抢占式的。</li></ul><p><strong>Semaphore 对应的两个构造方法如下：</strong></p><pre class=" language-java"><code class="language-java">   <span class="token keyword">public</span> <span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token keyword">int</span> permits<span class="token punctuation">)</span> <span class="token punctuation">{</span>        sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span>permits<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token keyword">int</span> permits<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>        sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span>permits<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span>permits<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。</strong></p><blockquote><p><a href="https://github.com/Snailclimb/JavaGuide/issues/645" target="_blank" rel="noopener">issue645补充内容</a> ：Semaphore 与 CountDownLatch 一样，也是<strong>共享锁</strong>的一种实现。它默认构造 AQS 的 state 为 permits 。当执行任务的线程数量超出 permits ，那么多余的线程将会被放入阻塞队列 Park ，并自旋判断 state 是否大于 0 。只有当 state 大于 0 的时候，阻塞的线程才能继续执行，此时先前执行任务的线程继续执行 <code>release()</code> 方法，<code>release()</code> 方法使得 state 的变量会加 1 ，那么自旋的线程便会判断成功。如此，每次只有最多不超过 permits 数量的线程能自旋成功，便限制了执行任务线程的数量。</p></blockquote><p>由于篇幅问题，如果对 Semaphore 源码感兴趣的朋友可以看下这篇文章：<a href="https://juejin.im/post/5ae755366fb9a07ab508adc6" target="_blank" rel="noopener">https://juejin.im/post/5ae755366fb9a07ab508adc6</a></p><h3 id="4-CountDownLatch-（倒计时器）"><a href="#4-CountDownLatch-（倒计时器）" class="headerlink" title="4 CountDownLatch （倒计时器）"></a>4 CountDownLatch （倒计时器）</h3><p>CountDownLatch 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。在 Java 并发中，countdownlatch 的概念是一个常见的面试题，所以一定要确保你很好的理解了它。</p><p>CountDownLatch 是共享锁的一种实现，它默认构造 AQS 的 state 值为 count 。当线程使用  <code>countDown()</code> 方法时，其实使用了 <code>tryReleaseShared()</code> 方法以 <strong>CAS</strong> 的操作来减少 state ，直至 state 为 0 就代表所有的线程都调用了 <code>countDown()</code> 方法。当调用 <code>await()</code> 方法的时候，如果state不为 0 ，就代表仍然有线程没有调用 <code>countDown()</code> 方法，那么就把已经调用过 <code>countDown()</code> 的线程都放入阻塞队列 Park ，并自旋 <strong>CAS</strong> 判断 state == 0 ，直至最后一个线程调用了 <code>countDown()</code> ，使得 state == 0，于是阻塞的线程便判断成功，全部往下执行。</p><h4 id="4-1-CountDownLatch-的两种典型用法"><a href="#4-1-CountDownLatch-的两种典型用法" class="headerlink" title="4.1 CountDownLatch 的两种典型用法"></a>4.1 CountDownLatch 的两种典型用法</h4><ol><li>某一线程在开始运行前等待 N 个线程执行完毕。将 <code>CountDownLatch</code> 的计数器初始化为 N ：<code>new CountDownLatch(N)</code> ，每当一个任务线程执行完毕，就将计数器减 1 <code>countdownlatch.countDown()</code> ，当计数器的值变为 0 时，在 <code>CountDownLatch</code> 上 <code>await()</code> 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</li><li>实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 <code>CountDownLatch</code> 对象，将其计数器初始化为 1 ：<code>new CountDownLatch(1)</code> ，多个线程在开始执行任务前首先 <code>coundownlatch.await()</code> ，当主线程调用 <code>countDown()</code> 时，计数器变为 0 ，多个线程同时被唤醒。</li></ol><h4 id="4-2-CountDownLatch-的使用示例"><a href="#4-2-CountDownLatch-的使用示例" class="headerlink" title="4.2 CountDownLatch 的使用示例"></a>4.2 CountDownLatch 的使用示例</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountDownLatchExample1</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 请求的数量</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> threadCount <span class="token operator">=</span> <span class="token number">550</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span>    ExecutorService threadPool <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>threadCount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">final</span> <span class="token keyword">int</span> threadnum <span class="token operator">=</span> i<span class="token punctuation">;</span>      threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// Lambda 表达式的运用</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>          <span class="token function">test</span><span class="token punctuation">(</span>threadnum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// TODO Auto-generated catch block</span>          e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>          countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 表示一个请求已经被完成</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    threadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"finish"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> threadnum<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 模拟请求的耗时操作</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"threadnum:"</span> <span class="token operator">+</span> threadnum<span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 模拟请求的耗时操作</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上面的代码中，我们定义了请求的数量为 550 ，当这 550 个请求被处理完成之后，才会执行<code>System.out.println(&quot;finish&quot;);</code> 。</p><p>与 CountDownLatch 的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用 <code>CountDownLatch.await()</code> 方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</p><p>其他 N 个线程必须引用闭锁对象，因为他们需要通知 <code>CountDownLatch</code> 对象，他们已经完成了各自的任务。这种通知机制是通过 <code>CountDownLatch.countDown()</code> 方法来完成的；每调用一次这个方法，在构造函数中初始化的 count 值就减 1 。所以当 N 个线程都调用了这个方法，count 的值等于 0 ，然后主线程就能通过 <code>await()</code> 方法，恢复执行自己的任务。</p><p>再插一嘴：<code>CountDownLatch</code> 的  <code>await()</code> 方法使用不当很容易产生死锁，比如我们上面代码中的 for 循环改为：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadCount<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>这样就导致  <code>count</code> 的值没办法等于 0 ，然后就会导致一直等待。</p><p>如果对 CountDownLatch 源码感兴趣的朋友，可以查看： <a href="https://www.cnblogs.com/leesf456/p/5406191.html" target="_blank" rel="noopener">【JUC】JDK1.8源码分析之CountDownLatch（五）</a></p><h4 id="4-3-CountDownLatch-的不足"><a href="#4-3-CountDownLatch-的不足" class="headerlink" title="4.3 CountDownLatch 的不足"></a>4.3 CountDownLatch 的不足</h4><p>CountDownLatch 是<strong>一次性</strong>的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 CountDownLatch 使用完毕后，它不能再次被使用。</p><h4 id="4-4-CountDownLatch-相常见面试题"><a href="#4-4-CountDownLatch-相常见面试题" class="headerlink" title="4.4 CountDownLatch 相常见面试题"></a>4.4 CountDownLatch 相常见面试题</h4><p>解释一下 CountDownLatch 概念？</p><p>CountDownLatch 和 CyclicBarrier 的不同之处？</p><p>给出一些 CountDownLatch 使用的例子？</p><p>CountDownLatch 类中主要的方法？</p><h3 id="5-CyclicBarrier（循环栅栏）"><a href="#5-CyclicBarrier（循环栅栏）" class="headerlink" title="5 CyclicBarrier（循环栅栏）"></a>5 CyclicBarrier（循环栅栏）</h3><p>CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。</p><blockquote><p>CountDownLatch 的实现是基于 <strong>AQS</strong> 的，而 CycliBarrier 是基于 <strong>ReentrantLock</strong>（ReentrantLock 也属于  AQS 同步器）和 <strong>Condition</strong> 的。</p></blockquote><p>CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 <code>CyclicBarrier(int parties)</code> ，其参数表示屏障拦截的线程数量，每个线程调用 <code>await()</code> 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</p><p>再来看一下它的构造函数：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">CyclicBarrier</span><span class="token punctuation">(</span><span class="token keyword">int</span> parties<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>parties<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">CyclicBarrier</span><span class="token punctuation">(</span><span class="token keyword">int</span> parties<span class="token punctuation">,</span> Runnable barrierAction<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parties <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>parties <span class="token operator">=</span> parties<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> parties<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>barrierCommand <span class="token operator">=</span> barrierAction<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其中，parties 就代表了有拦截的线程的数量，当拦截的线程数量达到这个值的时候就打开栅栏，让所有线程通过。</p><h4 id="5-1-CyclicBarrier-的应用场景"><a href="#5-1-CyclicBarrier-的应用场景" class="headerlink" title="5.1 CyclicBarrier 的应用场景"></a>5.1 CyclicBarrier 的应用场景</h4><p>CyclicBarrier 可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个 sheet 里的银行流水，都执行完之后，得到每个 sheet 的日均银行流水，最后，再用 barrierAction 用这些线程的计算结果，计算出整个 Excel 的日均银行流水。</p><h4 id="5-2-CyclicBarrier-的使用示例"><a href="#5-2-CyclicBarrier-的使用示例" class="headerlink" title="5.2 CyclicBarrier 的使用示例"></a>5.2 CyclicBarrier 的使用示例</h4><p>示例 1：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CyclicBarrierExample2</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 请求的数量</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> threadCount <span class="token operator">=</span> <span class="token number">550</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 需要同步的线程数量</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> CyclicBarrier cyclicBarrier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建线程池</span>    ExecutorService threadPool <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">final</span> <span class="token keyword">int</span> threadNum <span class="token operator">=</span> i<span class="token punctuation">;</span>      Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>          <span class="token function">test</span><span class="token punctuation">(</span>threadNum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// TODO Auto-generated catch block</span>          e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// TODO Auto-generated catch block</span>          e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    threadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> threadnum<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> BrokenBarrierException <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"threadnum:"</span> <span class="token operator">+</span> threadnum <span class="token operator">+</span> <span class="token string">"is ready"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">/**等待60秒，保证子线程完全执行结束*/</span>      cyclicBarrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-----CyclicBarrierException------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"threadnum:"</span> <span class="token operator">+</span> threadnum <span class="token operator">+</span> <span class="token string">"is finish"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行结果，如下：</p><pre class=" language-java"><code class="language-java">threadnum<span class="token operator">:</span>0is readythreadnum<span class="token operator">:</span>1is readythreadnum<span class="token operator">:</span>2is readythreadnum<span class="token operator">:</span>3is readythreadnum<span class="token operator">:</span>4is readythreadnum<span class="token operator">:</span>4is finishthreadnum<span class="token operator">:</span>0is finishthreadnum<span class="token operator">:</span>1is finishthreadnum<span class="token operator">:</span>2is finishthreadnum<span class="token operator">:</span>3is finishthreadnum<span class="token operator">:</span>5is readythreadnum<span class="token operator">:</span>6is readythreadnum<span class="token operator">:</span>7is readythreadnum<span class="token operator">:</span>8is readythreadnum<span class="token operator">:</span>9is readythreadnum<span class="token operator">:</span>9is finishthreadnum<span class="token operator">:</span>5is finishthreadnum<span class="token operator">:</span>8is finishthreadnum<span class="token operator">:</span>7is finishthreadnum<span class="token operator">:</span>6is finish<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><p>可以看到当线程数量也就是请求数量达到我们定义的 5 个的时候， <code>await</code>方法之后的方法才被执行。</p><p>另外，CyclicBarrier 还提供一个更高级的构造函数 <code>CyclicBarrier(int parties, Runnable barrierAction)</code> ，用于在线程到达屏障时，优先执行 <code>barrierAction</code> ，方便处理更复杂的业务场景。示例代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CyclicBarrierExample3</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 请求的数量</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> threadCount <span class="token operator">=</span> <span class="token number">550</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 需要同步的线程数量</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> CyclicBarrier cyclicBarrier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------当线程数达到之后，优先执行------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建线程池</span>    ExecutorService threadPool <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">final</span> <span class="token keyword">int</span> threadNum <span class="token operator">=</span> i<span class="token punctuation">;</span>      Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>          <span class="token function">test</span><span class="token punctuation">(</span>threadNum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// TODO Auto-generated catch block</span>          e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// TODO Auto-generated catch block</span>          e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    threadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> threadnum<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> BrokenBarrierException <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"threadnum:"</span> <span class="token operator">+</span> threadnum <span class="token operator">+</span> <span class="token string">"is ready"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cyclicBarrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"threadnum:"</span> <span class="token operator">+</span> threadnum <span class="token operator">+</span> <span class="token string">"is finish"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行结果，如下：</p><pre class=" language-java"><code class="language-java">threadnum<span class="token operator">:</span>0is readythreadnum<span class="token operator">:</span>1is readythreadnum<span class="token operator">:</span>2is readythreadnum<span class="token operator">:</span>3is readythreadnum<span class="token operator">:</span>4is ready<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>当线程数达到之后，优先执行<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>threadnum<span class="token operator">:</span>4is finishthreadnum<span class="token operator">:</span>0is finishthreadnum<span class="token operator">:</span>2is finishthreadnum<span class="token operator">:</span>1is finishthreadnum<span class="token operator">:</span>3is finishthreadnum<span class="token operator">:</span>5is readythreadnum<span class="token operator">:</span>6is readythreadnum<span class="token operator">:</span>7is readythreadnum<span class="token operator">:</span>8is readythreadnum<span class="token operator">:</span>9is ready<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>当线程数达到之后，优先执行<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>threadnum<span class="token operator">:</span>9is finishthreadnum<span class="token operator">:</span>5is finishthreadnum<span class="token operator">:</span>6is finishthreadnum<span class="token operator">:</span>8is finishthreadnum<span class="token operator">:</span>7is finish<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><h4 id="5-3-CyclicBarrier-源码分析"><a href="#5-3-CyclicBarrier-源码分析" class="headerlink" title="5.3 CyclicBarrier 源码分析"></a>5.3 CyclicBarrier 源码分析</h4><p>当调用 <code>CyclicBarrier</code> 对象调用 <code>await()</code> 方法时，实际上调用的是 <code>dowait(false, 0L)</code> 方法。 <code>await()</code> 方法就像树立起一个栅栏的行为一样，将线程挡住了，当拦住的线程数量达到 parties 的值时，栅栏才会打开，线程才得以通过执行。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> BrokenBarrierException <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">dowait</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> 0L<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">TimeoutException</span> toe<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>toe<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// cannot happen</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p><code>dowait(false, 0L)</code>：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 当线程数量或者请求数量达到 count 时 await 之后的方法才会被执行。上面的示例中 count 的值就为 5。</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Main barrier code, covering the various policies.     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">dowait</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span>        <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> BrokenBarrierException<span class="token punctuation">,</span>               TimeoutException <span class="token punctuation">{</span>        <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 锁住</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> Generation g <span class="token operator">=</span> generation<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token punctuation">.</span>broken<span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BrokenBarrierException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果线程中断了，抛出异常</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">breakBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// cout减1</span>            <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token operator">--</span>count<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 当 count 数量减为 0 之后说明最后一个线程已经到达栅栏了，也就是达到了可以执行await 方法之后的条件</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// tripped</span>                <span class="token keyword">boolean</span> ranAction <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token keyword">final</span> Runnable command <span class="token operator">=</span> barrierCommand<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">!=</span> null<span class="token punctuation">)</span>                        command<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    ranAction <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 将 count 重置为 parties 属性的初始化值</span>                    <span class="token comment" spellcheck="true">// 唤醒之前等待的线程</span>                    <span class="token comment" spellcheck="true">// 下一波执行开始</span>                    <span class="token function">nextGeneration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ranAction<span class="token punctuation">)</span>                        <span class="token function">breakBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// loop until tripped, broken, interrupted, or timed out</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timed<span class="token punctuation">)</span>                        trip<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">></span> 0L<span class="token punctuation">)</span>                        nanos <span class="token operator">=</span> trip<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ie<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>g <span class="token operator">==</span> generation <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span> g<span class="token punctuation">.</span>broken<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token function">breakBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">throw</span> ie<span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// We're about to finish waiting even if we had not</span>                        <span class="token comment" spellcheck="true">// been interrupted, so this interrupt is deemed to</span>                        <span class="token comment" spellcheck="true">// "belong" to subsequent execution.</span>                        Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token punctuation">.</span>broken<span class="token punctuation">)</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BrokenBarrierException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>g <span class="token operator">!=</span> generation<span class="token punctuation">)</span>                    <span class="token keyword">return</span> index<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> nanos <span class="token operator">&lt;=</span> 0L<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">breakBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TimeoutException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>总结：<code>CyclicBarrier</code> 内部通过一个 count 变量作为计数器，count 的初始值为 parties 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减一。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</p><h4 id="5-4-CyclicBarrier-和-CountDownLatch-的区别"><a href="#5-4-CyclicBarrier-和-CountDownLatch-的区别" class="headerlink" title="5.4 CyclicBarrier 和 CountDownLatch 的区别"></a>5.4 CyclicBarrier 和 CountDownLatch 的区别</h4><p><img src="https://s1.ax1x.com/2020/04/17/JZ5l40.md.png" alt="CyclicBarrier 和 CountDownLatch 的区别"></p><p><strong>下面这个是国外一个大佬的回答：</strong></p><p>CountDownLatch 是计数器，只能使用一次，而 CyclicBarrier 的计数器提供 reset 功能，可以多次使用。但是我不那么认为它们之间的区别仅仅就是这么简单的一点。我们来从 jdk 作者设计的目的来看，javadoc 是这么描述它们的：</p><blockquote><p><strong>CountDownLatch：</strong>A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.（CountDownLatch：一个或者多个线程，等待其他多个线程完成某件事情之后才能执行。）<br><strong>CyclicBarrier：</strong>A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.（CyclicBarrier：多个线程互相等待，直到到达同一个同步点，再继续一起执行。）</p></blockquote><p>对于 CountDownLatch 来说，重点是“一个线程（多个线程）等待”，而其他的 N 个线程在完成“某件事情”之后，可以终止，也可以等待。而对于 CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。</p><p>CountDownLatch 是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而 CyclicBarrier 更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。</p><h3 id="6-ReentrantLock-和-ReentrantReadWriteLock"><a href="#6-ReentrantLock-和-ReentrantReadWriteLock" class="headerlink" title="6 ReentrantLock 和 ReentrantReadWriteLock"></a>6 ReentrantLock 和 ReentrantReadWriteLock</h3><p>ReentrantLock 和 synchronized 的区别在上面已经讲过了这里就不多做讲解。另外，需要注意的是：读写锁 <strong>ReentrantReadWriteLock</strong> 可以保证多个线程可以同时读，所以在读操作远大于写操作的时候，读写锁就非常有用了。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://juejin.im/post/5ae755256fb9a07ac3634067" target="_blank" rel="noopener">https://juejin.im/post/5ae755256fb9a07ac3634067</a></li><li><a href="https://blog.csdn.net/u010185262/article/details/54692886" target="_blank" rel="noopener">https://blog.csdn.net/u010185262/article/details/54692886</a></li><li><a href="https://blog.csdn.net/tolcf/article/details/50925145?utm_source=blogxgwz0" target="_blank" rel="noopener">https://blog.csdn.net/tolcf/article/details/50925145?utm_source=blogxgwz0</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atomic原子类总结</title>
      <link href="/2020/04/17/hou-duan/bing-fa/atomic-yuan-zi-lei-zong-jie/"/>
      <url>/2020/04/17/hou-duan/bing-fa/atomic-yuan-zi-lei-zong-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Atomic-原子类介绍"><a href="#1-Atomic-原子类介绍" class="headerlink" title="1 Atomic 原子类介绍"></a>1 Atomic 原子类介绍</h3><p><strong>Atomic</strong> 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 <strong>Atomic</strong> 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p><p>所以，所谓原子类说简单点就是具有原子/原子操作特征的类。</p><p>并发包 <code>java.util.concurrent</code> 的原子类都存放在 <code>java.util.concurrent.atomic</code> 下，如下图所示。</p><p><img src="https://s1.ax1x.com/2020/04/17/JZ53CV.png" alt="JUC 原子类概览"></p><p>根据操作的数据类型，可以将 JUC 包中的原子类分为 4 类。</p><p><strong>基本类型</strong> </p><p>使用原子的方式更新基本类型</p><ul><li>AtomicInteger：<strong>整型</strong>原子类</li><li>AtomicLong：<strong>长整型</strong>原子类</li><li>AtomicBoolean ：<strong>布尔型</strong>原子类</li></ul><p><strong>数组类型</strong></p><p>使用原子的方式更新数组里的某个元素</p><ul><li>AtomicIntegerArray：<strong>整型数组</strong>原子类</li><li>AtomicLongArray：<strong>长整型数组</strong>原子类</li><li>AtomicReferenceArray：<strong>引用类型数组</strong>原子类</li></ul><p><strong>引用类型</strong></p><ul><li>AtomicReference：<strong>引用类型</strong>原子类</li><li>AtomicMarkableReference：原子更新<strong>带有标记的引用类型</strong>。该类将 boolean 标记与引用关联起来，<del>也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</del></li><li>AtomicStampedReference：原子更新<strong>带有版本号的引用类型</strong>。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li></ul><p><strong>对象的属性修改类型</strong></p><ul><li>AtomicIntegerFieldUpdater：原子更新<strong>整型</strong>字段的更新器</li><li>AtomicLongFieldUpdater：原子更新<strong>长整型</strong>字段的更新器</li><li>AtomicReferenceFieldUpdater：原子更新<strong>引用类型</strong>里的字段</li></ul><blockquote><p>修正： <strong>AtomicMarkableReference 不能解决ABA问题</strong>   <strong><a href="https://github.com/Snailclimb/JavaGuide/issues/626" target="_blank" rel="noopener">issue#626</a></strong></p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** AtomicMarkableReference是将一个boolean值作是否有更改的标记，本质就是它的版本号只有两个，true和false，修改的时候在这两个版本号之间来回切换，这样做并不能解决ABA的问题，只是会降低ABA问题发生的几率而已。 @author : mazh @Date : 2020/1/17 14:41*/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SolveABAByAtomicMarkableReference</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> AtomicMarkableReference atomicMarkableReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicMarkableReference</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Thread refT1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                atomicMarkableReference<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">101</span><span class="token punctuation">,</span> atomicMarkableReference<span class="token punctuation">.</span><span class="token function">isMarked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">!</span>atomicMarkableReference<span class="token punctuation">.</span><span class="token function">isMarked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                atomicMarkableReference<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> atomicMarkableReference<span class="token punctuation">.</span><span class="token function">isMarked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">!</span>atomicMarkableReference<span class="token punctuation">.</span><span class="token function">isMarked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Thread refT2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">boolean</span> marked <span class="token operator">=</span> atomicMarkableReference<span class="token punctuation">.</span><span class="token function">isMarked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">boolean</span> c3 <span class="token operator">=</span> atomicMarkableReference<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">101</span><span class="token punctuation">,</span> marked<span class="token punctuation">,</span> <span class="token operator">!</span>marked<span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回true,实际应该返回false</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            refT1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            refT2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>CAS “ABA” 问题</strong></p><ul><li>描述：第一个线程取到了变量 x 的值 A，然后干别的事，总之就是只拿到了变量 x 的值 A。这段时间内第二个线程也取到了变量 x 的值 A，然后把变量 x 的值改为 B，然后干别的事，最后又把变量 x 的值变为 A （相当于还原了）。在这之后第一个线程终于进行了变量 x 的操作，但是此时变量 x 的值还是 A，所以 <strong>compareAndSet</strong> 操作是成功。</li><li>例子描述（可能不太合适，但好理解）：年初，现金为零，然后通过正常劳动赚了三百万，之后正常消费了（比如买房子）三百万。年末，虽然现金零收入（可能变成其他形式了），但是赚了钱是事实，还是得交税的！</li><li>代码例子（以 <code>AtomicInteger</code> 为例）</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicInteger<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicIntegerDefectDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">defectOfABA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">defectOfABA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> AtomicInteger atomicInteger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread coreThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>                <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                    <span class="token keyword">final</span> <span class="token keyword">int</span> currentValue <span class="token operator">=</span> atomicInteger<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" ------ currentValue="</span> <span class="token operator">+</span> currentValue<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 这段目的：模拟处理其他业务花费的时间</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">boolean</span> casResult <span class="token operator">=</span> atomicInteger<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                            <span class="token operator">+</span> <span class="token string">" ------ currentValue="</span> <span class="token operator">+</span> currentValue                            <span class="token operator">+</span> <span class="token string">", finalValue="</span> <span class="token operator">+</span> atomicInteger<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                            <span class="token operator">+</span> <span class="token string">", compareAndSet Result="</span> <span class="token operator">+</span> casResult<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>        coreThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 这段目的：为了让 coreThread 线程先跑起来</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Thread amateurThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>                <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> currentValue <span class="token operator">=</span> atomicInteger<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">boolean</span> casResult <span class="token operator">=</span> atomicInteger<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                            <span class="token operator">+</span> <span class="token string">" ------ currentValue="</span> <span class="token operator">+</span> currentValue                            <span class="token operator">+</span> <span class="token string">", finalValue="</span> <span class="token operator">+</span> atomicInteger<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                            <span class="token operator">+</span> <span class="token string">", compareAndSet Result="</span> <span class="token operator">+</span> casResult<span class="token punctuation">)</span><span class="token punctuation">;</span>                    currentValue <span class="token operator">=</span> atomicInteger<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    casResult <span class="token operator">=</span> atomicInteger<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                            <span class="token operator">+</span> <span class="token string">" ------ currentValue="</span> <span class="token operator">+</span> currentValue                            <span class="token operator">+</span> <span class="token string">", finalValue="</span> <span class="token operator">+</span> atomicInteger<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                            <span class="token operator">+</span> <span class="token string">", compareAndSet Result="</span> <span class="token operator">+</span> casResult<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>        amateurThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出内容如下：</p><pre class=" language-java"><code class="language-java">Thread<span class="token operator">-</span><span class="token number">0</span> <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> currentValue<span class="token operator">=</span><span class="token number">1</span>Thread<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> currentValue<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> finalValue<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> compareAndSet Result<span class="token operator">=</span><span class="token boolean">true</span>Thread<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> currentValue<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> finalValue<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> compareAndSet Result<span class="token operator">=</span><span class="token boolean">true</span>Thread<span class="token operator">-</span><span class="token number">0</span> <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> currentValue<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> finalValue<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> compareAndSet Result<span class="token operator">=</span><span class="token boolean">true</span></code></pre><p>下面我们来详细介绍一下这些原子类。</p><h3 id="2-基本类型原子类"><a href="#2-基本类型原子类" class="headerlink" title="2 基本类型原子类"></a>2 基本类型原子类</h3><h4 id="2-1-基本类型原子类介绍"><a href="#2-1-基本类型原子类介绍" class="headerlink" title="2.1 基本类型原子类介绍"></a>2.1 基本类型原子类介绍</h4><p>使用原子的方式更新基本类型。</p><ul><li>AtomicInteger：<strong>整型</strong>原子类</li><li>AtomicLong：<strong>长整型</strong>原子类</li><li>AtomicBoolean ：<strong>布尔型</strong>原子类</li></ul><p>上面三个类提供的方法几乎相同，所以我们这里以 <strong>AtomicInteger</strong> 为例子来介绍。</p><p> <strong>AtomicInteger 类常用方法</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//获取当前的值</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> newValue<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//获取当前的值，并设置新的值</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//获取当前的值，并自增</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//获取当前的值，并自减</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> delta<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//获取当前的值，并加上预期的值</span><span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lazySet</span><span class="token punctuation">(</span><span class="token keyword">int</span> newValue<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></code></pre><h4 id="2-2-AtomicInteger-常见方法使用"><a href="#2-2-AtomicInteger-常见方法使用" class="headerlink" title="2.2 AtomicInteger 常见方法使用"></a>2.2 AtomicInteger 常见方法使用</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicInteger<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicIntegerTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        <span class="token keyword">int</span> temvalue <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        AtomicInteger i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        temvalue <span class="token operator">=</span> i<span class="token punctuation">.</span><span class="token function">getAndSet</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"temvalue:"</span> <span class="token operator">+</span> temvalue <span class="token operator">+</span> <span class="token string">";  i:"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//temvalue:0;  i:3</span>        temvalue <span class="token operator">=</span> i<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"temvalue:"</span> <span class="token operator">+</span> temvalue <span class="token operator">+</span> <span class="token string">";  i:"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//temvalue:3;  i:4</span>        temvalue <span class="token operator">=</span> i<span class="token punctuation">.</span><span class="token function">getAndAdd</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"temvalue:"</span> <span class="token operator">+</span> temvalue <span class="token operator">+</span> <span class="token string">";  i:"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//temvalue:4;  i:9</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2-3-基本数据类型原子类的优势"><a href="#2-3-基本数据类型原子类的优势" class="headerlink" title="2.3 基本数据类型原子类的优势"></a>2.3 基本数据类型原子类的优势</h4><p>通过一个简单例子带大家看一下基本数据类型原子类的优势。</p><p><strong>①多线程环境不使用原子类保证线程安全（基本数据类型）</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//若要线程安全执行执行count++，需要加锁</span>        <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  count<span class="token operator">++</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token keyword">return</span> count<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>②多线程环境使用原子类保证线程安全（基本数据类型）</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Test2</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  count<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//使用AtomicInteger之后，不需要加锁，也可以实现线程安全。</span>       <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2-4-AtomicInteger-线程安全原理简单分析"><a href="#2-4-AtomicInteger-线程安全原理简单分析" class="headerlink" title="2.4 AtomicInteger 线程安全原理简单分析"></a>2.4 AtomicInteger 线程安全原理简单分析</h4><p>AtomicInteger 类的部分源码：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Unsafe unsafe <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> valueOffset<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            valueOffset <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span>                <span class="token punctuation">(</span>AtomicInteger<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span></code></pre><p>AtomicInteger 类主要利用 <strong>CAS (compare and swap) + volatile 和 Native 方法</strong>来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><p>CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 <code>objectFieldOffset()</code> 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p><h3 id="3-数组类型原子类"><a href="#3-数组类型原子类" class="headerlink" title="3 数组类型原子类"></a>3 数组类型原子类</h3><h4 id="3-1-数组类型原子类介绍"><a href="#3-1-数组类型原子类介绍" class="headerlink" title="3.1 数组类型原子类介绍"></a>3.1 数组类型原子类介绍</h4><p>使用原子的方式更新数组里的某个元素。</p><ul><li>AtomicIntegerArray：<strong>整形数组</strong>原子类</li><li>AtomicLongArray：<strong>长整形数组</strong>原子类</li><li>AtomicReferenceArray ：<strong>引用类型数组</strong>原子类</li></ul><p>上面三个类提供的方法几乎相同，所以我们这里以 <strong>AtomicIntegerArray</strong> 为例子来介绍。</p><p><strong>AtomicIntegerArray 类常用方法</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//获取 index=i 位置元素的值</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> newValue<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//返回 index=i 位置的当前的值，并将其设置为新值：newValue</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//获取 index=i 位置元素的值，并让该位置的元素自增</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//获取 index=i 位置元素的值，并让该位置的元素自减</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> delta<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//获取 index=i 位置元素的值，并加上预期的值</span><span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update）</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lazySet</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> newValue<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></code></pre><h4 id="3-2-AtomicIntegerArray-常见方法使用"><a href="#3-2-AtomicIntegerArray-常见方法使用" class="headerlink" title="3.2 AtomicIntegerArray 常见方法使用"></a>3.2 AtomicIntegerArray 常见方法使用</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicIntegerArray<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicIntegerArrayTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        <span class="token keyword">int</span> temvalue <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>        AtomicIntegerArray i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicIntegerArray</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        temvalue <span class="token operator">=</span> i<span class="token punctuation">.</span><span class="token function">getAndSet</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"temvalue:"</span> <span class="token operator">+</span> temvalue <span class="token operator">+</span> <span class="token string">";  i:"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        temvalue <span class="token operator">=</span> i<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"temvalue:"</span> <span class="token operator">+</span> temvalue <span class="token operator">+</span> <span class="token string">";  i:"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        temvalue <span class="token operator">=</span> i<span class="token punctuation">.</span><span class="token function">getAndAdd</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"temvalue:"</span> <span class="token operator">+</span> temvalue <span class="token operator">+</span> <span class="token string">";  i:"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">temvalue<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>  i<span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span>temvalue<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">;</span>  i<span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span>temvalue<span class="token operator">:</span><span class="token number">3</span><span class="token punctuation">;</span>  i<span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span></code></pre><h3 id="4-引用类型原子类"><a href="#4-引用类型原子类" class="headerlink" title="4 引用类型原子类"></a>4 引用类型原子类</h3><h4 id="4-1-引用类型原子类介绍"><a href="#4-1-引用类型原子类介绍" class="headerlink" title="4.1  引用类型原子类介绍"></a>4.1  引用类型原子类介绍</h4><p>基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用 引用类型原子类。</p><ul><li>AtomicReference：<strong>引用类型</strong>原子类</li><li>AtomicStampedReference：原子更新<strong>带有版本号的引用类型</strong>。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li><li>AtomicMarkableReference ：原子更新<strong>带有标记的引用类型</strong>。该类将 boolean 标记与引用关联起来，<del>也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</del></li></ul><p>上面三个类提供的方法几乎相同，所以我们这里以 AtomicReference 为例子来介绍。</p><h4 id="4-2-AtomicReference-类使用示例"><a href="#4-2-AtomicReference-类使用示例" class="headerlink" title="4.2 AtomicReference 类使用示例"></a>4.2 AtomicReference 类使用示例</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicReference<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicReferenceTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        AtomicReference<span class="token operator">&lt;</span>Person<span class="token operator">></span> ar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicReference</span><span class="token operator">&lt;</span>Person<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Person person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"SnailClimb"</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ar<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>        Person updatePerson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Daisy"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ar<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> updatePerson<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ar<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ar<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上述代码首先创建了一个 Person 对象，然后把 Person 对象设置进 AtomicReference 对象中，然后调用 compareAndSet 方法，该方法就是通过 CAS 操作设置 ar。如果 ar 的值为 person 的话，则将其设置为 updatePerson 。实现原理与 AtomicInteger 类中的 compareAndSet 方法相同。运行上面的代码后的输出结果如下：</p><pre class=" language-java"><code class="language-java">Daisy<span class="token number">20</span></code></pre><h4 id="4-3-AtomicStampedReference-类使用示例"><a href="#4-3-AtomicStampedReference-类使用示例" class="headerlink" title="4.3 AtomicStampedReference 类使用示例"></a>4.3 AtomicStampedReference 类使用示例</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicStampedReference<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicStampedReferenceDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 实例化、取当前值和 stamp 值</span>        <span class="token keyword">final</span> Integer initialRef <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> initialStamp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> AtomicStampedReference<span class="token operator">&lt;</span>Integer<span class="token operator">></span> asr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicStampedReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>initialRef<span class="token punctuation">,</span> initialStamp<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"currentValue="</span> <span class="token operator">+</span> asr<span class="token punctuation">.</span><span class="token function">getReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", currentStamp="</span> <span class="token operator">+</span> asr<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// compare and set</span>        <span class="token keyword">final</span> Integer newReference <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">,</span> newStamp <span class="token operator">=</span> <span class="token number">999</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">boolean</span> casResult <span class="token operator">=</span> asr<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>initialRef<span class="token punctuation">,</span> newReference<span class="token punctuation">,</span> initialStamp<span class="token punctuation">,</span> newStamp<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"currentValue="</span> <span class="token operator">+</span> asr<span class="token punctuation">.</span><span class="token function">getReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token operator">+</span> <span class="token string">", currentStamp="</span> <span class="token operator">+</span> asr<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token operator">+</span> <span class="token string">", casResult="</span> <span class="token operator">+</span> casResult<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取当前的值和当前的 stamp 值</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> Integer currentValue <span class="token operator">=</span> asr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> currentStamp <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"currentValue="</span> <span class="token operator">+</span> currentValue <span class="token operator">+</span> <span class="token string">", currentStamp="</span> <span class="token operator">+</span> currentStamp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 单独设置 stamp 值</span>        <span class="token keyword">final</span> <span class="token keyword">boolean</span> attemptStampResult <span class="token operator">=</span> asr<span class="token punctuation">.</span><span class="token function">attemptStamp</span><span class="token punctuation">(</span>newReference<span class="token punctuation">,</span> <span class="token number">88</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"currentValue="</span> <span class="token operator">+</span> asr<span class="token punctuation">.</span><span class="token function">getReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token operator">+</span> <span class="token string">", currentStamp="</span> <span class="token operator">+</span> asr<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token operator">+</span> <span class="token string">", attemptStampResult="</span> <span class="token operator">+</span> attemptStampResult<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 重新设置当前值和 stamp 值</span>        asr<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>initialRef<span class="token punctuation">,</span> initialStamp<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"currentValue="</span> <span class="token operator">+</span> asr<span class="token punctuation">.</span><span class="token function">getReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", currentStamp="</span> <span class="token operator">+</span> asr<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// [不推荐使用，除非搞清楚注释的意思了] weak compare and set</span>        <span class="token comment" spellcheck="true">// 困惑！weakCompareAndSet 这个方法最终还是调用 compareAndSet 方法。[版本: jdk-8u191]</span>        <span class="token comment" spellcheck="true">// 但是注释上写着 "May fail spuriously and does not provide ordering guarantees,</span>        <span class="token comment" spellcheck="true">// so is only rarely an appropriate alternative to compareAndSet."</span>        <span class="token comment" spellcheck="true">// todo 感觉有可能是 jvm 通过方法名在 native 方法里面做了转发</span>        <span class="token keyword">final</span> <span class="token keyword">boolean</span> wCasResult <span class="token operator">=</span> asr<span class="token punctuation">.</span><span class="token function">weakCompareAndSet</span><span class="token punctuation">(</span>initialRef<span class="token punctuation">,</span> newReference<span class="token punctuation">,</span> initialStamp<span class="token punctuation">,</span> newStamp<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"currentValue="</span> <span class="token operator">+</span> asr<span class="token punctuation">.</span><span class="token function">getReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token operator">+</span> <span class="token string">", currentStamp="</span> <span class="token operator">+</span> asr<span class="token punctuation">.</span><span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token operator">+</span> <span class="token string">", wCasResult="</span> <span class="token operator">+</span> wCasResult<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出结果如下：</p><pre class=" language-java"><code class="language-java">currentValue<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> currentStamp<span class="token operator">=</span><span class="token number">0</span>currentValue<span class="token operator">=</span><span class="token number">666</span><span class="token punctuation">,</span> currentStamp<span class="token operator">=</span><span class="token number">999</span><span class="token punctuation">,</span> casResult<span class="token operator">=</span><span class="token boolean">true</span>currentValue<span class="token operator">=</span><span class="token number">666</span><span class="token punctuation">,</span> currentStamp<span class="token operator">=</span><span class="token number">999</span>currentValue<span class="token operator">=</span><span class="token number">666</span><span class="token punctuation">,</span> currentStamp<span class="token operator">=</span><span class="token number">88</span><span class="token punctuation">,</span> attemptStampResult<span class="token operator">=</span><span class="token boolean">true</span>currentValue<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> currentStamp<span class="token operator">=</span><span class="token number">0</span>currentValue<span class="token operator">=</span><span class="token number">666</span><span class="token punctuation">,</span> currentStamp<span class="token operator">=</span><span class="token number">999</span><span class="token punctuation">,</span> wCasResult<span class="token operator">=</span><span class="token boolean">true</span></code></pre><h4 id="4-4-AtomicMarkableReference-类使用示例"><a href="#4-4-AtomicMarkableReference-类使用示例" class="headerlink" title="4.4 AtomicMarkableReference 类使用示例"></a>4.4 AtomicMarkableReference 类使用示例</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicMarkableReference<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicMarkableReferenceDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 实例化、取当前值和 mark 值</span>        <span class="token keyword">final</span> Boolean initialRef <span class="token operator">=</span> null<span class="token punctuation">,</span> initialMark <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> AtomicMarkableReference<span class="token operator">&lt;</span>Boolean<span class="token operator">></span> amr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicMarkableReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>initialRef<span class="token punctuation">,</span> initialMark<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"currentValue="</span> <span class="token operator">+</span> amr<span class="token punctuation">.</span><span class="token function">getReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", currentMark="</span> <span class="token operator">+</span> amr<span class="token punctuation">.</span><span class="token function">isMarked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// compare and set</span>        <span class="token keyword">final</span> Boolean newReference1 <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> newMark1 <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">boolean</span> casResult <span class="token operator">=</span> amr<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>initialRef<span class="token punctuation">,</span> newReference1<span class="token punctuation">,</span> initialMark<span class="token punctuation">,</span> newMark1<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"currentValue="</span> <span class="token operator">+</span> amr<span class="token punctuation">.</span><span class="token function">getReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token operator">+</span> <span class="token string">", currentMark="</span> <span class="token operator">+</span> amr<span class="token punctuation">.</span><span class="token function">isMarked</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token operator">+</span> <span class="token string">", casResult="</span> <span class="token operator">+</span> casResult<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取当前的值和当前的 mark 值</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> Boolean currentValue <span class="token operator">=</span> amr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">boolean</span> currentMark <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"currentValue="</span> <span class="token operator">+</span> currentValue <span class="token operator">+</span> <span class="token string">", currentMark="</span> <span class="token operator">+</span> currentMark<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 单独设置 mark 值</span>        <span class="token keyword">final</span> <span class="token keyword">boolean</span> attemptMarkResult <span class="token operator">=</span> amr<span class="token punctuation">.</span><span class="token function">attemptMark</span><span class="token punctuation">(</span>newReference1<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"currentValue="</span> <span class="token operator">+</span> amr<span class="token punctuation">.</span><span class="token function">getReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token operator">+</span> <span class="token string">", currentMark="</span> <span class="token operator">+</span> amr<span class="token punctuation">.</span><span class="token function">isMarked</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token operator">+</span> <span class="token string">", attemptMarkResult="</span> <span class="token operator">+</span> attemptMarkResult<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 重新设置当前值和 mark 值</span>        amr<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>initialRef<span class="token punctuation">,</span> initialMark<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"currentValue="</span> <span class="token operator">+</span> amr<span class="token punctuation">.</span><span class="token function">getReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", currentMark="</span> <span class="token operator">+</span> amr<span class="token punctuation">.</span><span class="token function">isMarked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// [不推荐使用，除非搞清楚注释的意思了] weak compare and set</span>        <span class="token comment" spellcheck="true">// 困惑！weakCompareAndSet 这个方法最终还是调用 compareAndSet 方法。[版本: jdk-8u191]</span>        <span class="token comment" spellcheck="true">// 但是注释上写着 "May fail spuriously and does not provide ordering guarantees,</span>        <span class="token comment" spellcheck="true">// so is only rarely an appropriate alternative to compareAndSet."</span>        <span class="token comment" spellcheck="true">// todo 感觉有可能是 jvm 通过方法名在 native 方法里面做了转发</span>        <span class="token keyword">final</span> <span class="token keyword">boolean</span> wCasResult <span class="token operator">=</span> amr<span class="token punctuation">.</span><span class="token function">weakCompareAndSet</span><span class="token punctuation">(</span>initialRef<span class="token punctuation">,</span> newReference1<span class="token punctuation">,</span> initialMark<span class="token punctuation">,</span> newMark1<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"currentValue="</span> <span class="token operator">+</span> amr<span class="token punctuation">.</span><span class="token function">getReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token operator">+</span> <span class="token string">", currentMark="</span> <span class="token operator">+</span> amr<span class="token punctuation">.</span><span class="token function">isMarked</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token operator">+</span> <span class="token string">", wCasResult="</span> <span class="token operator">+</span> wCasResult<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出结果如下：</p><pre class=" language-java"><code class="language-java">currentValue<span class="token operator">=</span>null<span class="token punctuation">,</span> currentMark<span class="token operator">=</span><span class="token boolean">false</span>currentValue<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">,</span> currentMark<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">,</span> casResult<span class="token operator">=</span><span class="token boolean">true</span>currentValue<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">,</span> currentMark<span class="token operator">=</span><span class="token boolean">true</span>currentValue<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">,</span> currentMark<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">,</span> attemptMarkResult<span class="token operator">=</span><span class="token boolean">true</span>currentValue<span class="token operator">=</span>null<span class="token punctuation">,</span> currentMark<span class="token operator">=</span><span class="token boolean">false</span>currentValue<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">,</span> currentMark<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">,</span> wCasResult<span class="token operator">=</span><span class="token boolean">true</span></code></pre><h3 id="5-对象的属性修改类型原子类"><a href="#5-对象的属性修改类型原子类" class="headerlink" title="5 对象的属性修改类型原子类"></a>5 对象的属性修改类型原子类</h3><h4 id="5-1-对象的属性修改类型原子类介绍"><a href="#5-1-对象的属性修改类型原子类介绍" class="headerlink" title="5.1 对象的属性修改类型原子类介绍"></a>5.1 对象的属性修改类型原子类介绍</h4><p>如果需要原子更新某个类里的某个字段时，需要用到对象的属性修改类型原子类。</p><ul><li>AtomicIntegerFieldUpdater：原子更新<strong>整形</strong>字段的更新器</li><li>AtomicLongFieldUpdater：原子更新<strong>长整形</strong>字段的更新器</li><li>AtomicReferenceFieldUpdater：原子更新<strong>引用类型</strong>里的字段的更新器</li></ul><p>要想原子地更新对象的属性需要两步。第一步，因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 <code>newUpdater()</code> 创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新的对象属性必须使用 public volatile 修饰符。</p><p>上面三个类提供的方法几乎相同，所以我们这里以 <code>AtomicIntegerFieldUpdater</code> 为例子来介绍。</p><h4 id="5-2-AtomicIntegerFieldUpdater-类使用示例"><a href="#5-2-AtomicIntegerFieldUpdater-类使用示例" class="headerlink" title="5.2 AtomicIntegerFieldUpdater 类使用示例"></a>5.2 AtomicIntegerFieldUpdater 类使用示例</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicIntegerFieldUpdater<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicIntegerFieldUpdaterTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        AtomicIntegerFieldUpdater<span class="token operator">&lt;</span>User<span class="token operator">></span> a <span class="token operator">=</span> AtomicIntegerFieldUpdater<span class="token punctuation">.</span><span class="token function">newUpdater</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"Java"</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 22</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 23</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">User</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出结果：</p><pre class=" language-java"><code class="language-java"><span class="token number">22</span><span class="token number">23</span></code></pre><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>《Java并发编程的艺术》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile</title>
      <link href="/2020/04/17/hou-duan/bing-fa/volatile/"/>
      <url>/2020/04/17/hou-duan/bing-fa/volatile/</url>
      
        <content type="html"><![CDATA[<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p><strong>volatile</strong> 可能是面试里面必问的一个话题吧，对他的认知很多朋友也仅限于会用阶段，今天我们换个角度去看看。</p><p>先来看一段 Demo 的代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Wenjun w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Wenjun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        w<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>w<span class="token punctuation">.</span><span class="token function">isFlag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"有点东西"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Wenjun</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> flag<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isFlag</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> flag<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"falg = "</span> <span class="token operator">+</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>你会发现，永远都不会输出<strong>有点东西</strong>这一段代码，按道理线程改了 <code>flag</code> 变量，主线程也能访问到的呀？</p><p>为什么会出现这个情况呢？那我们就需要聊一下另外一个东西了。</p><h2 id="JMM（-Java-Memory-Model-）"><a href="#JMM（-Java-Memory-Model-）" class="headerlink" title="JMM（ Java Memory Model ）"></a>JMM（ Java Memory Model ）</h2><p><code>JMM</code> ：Java 内存模型，是 Java 虚拟机规范中所定义的一种内存模型，Java 内存模型是标准化的，屏蔽掉了底层不同计算机的区别（ <code>注意这个跟 JVM 完全不是一个东西，只是还有小伙伴搞错的</code> ）。</p><p>那正式聊之前，丙丙先大概科普一下现代计算机的内存模型吧。</p><h3 id="现代计算机的内存模型"><a href="#现代计算机的内存模型" class="headerlink" title="现代计算机的内存模型"></a>现代计算机的内存模型</h3><p>其实早期计算机中 CPU 和内存的速度是差不多的，但在现代计算机中，<code>CPU 的指令速度远超内存的存取速度</code> ，由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的 <code>高速缓存(Cache)</code> 来作为内存与处理器之间的缓冲。</p><p>将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。</p><p>基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：<code>缓存一致性(Cache Coherence)</code> 。</p><p>在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（ Main Memory ）。</p><p><img src="https://s1.ax1x.com/2020/05/03/YSQAXV.png" alt="内存模型"></p><p>然后我们可以聊一下 JMM 了。</p><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p><code>Java 内存模型(Java Memory Model)</code> 描述了 Java 程序中各种变量（线程共享变量）的访问规则，以及在 JVM 中将变量存储到内存和从内存中读取变量这样的底层细节。</p><h3 id="JMM-有以下规定："><a href="#JMM-有以下规定：" class="headerlink" title="JMM 有以下规定："></a>JMM 有以下规定：</h3><p>所有的共享变量都存储于主内存，这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。</p><p>每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。</p><p><code>线程对变量的所有的操作(读、取)都必须在工作内存中完成，而不能直接读写主内存中的变量</code> 。</p><p>不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。</p><h3 id="本地内存和主内存的关系："><a href="#本地内存和主内存的关系：" class="headerlink" title="本地内存和主内存的关系："></a>本地内存和主内存的关系：</h3><p><img src="https://s1.ax1x.com/2020/05/03/YS3vgs.png" alt="JMM"></p><p>正是因为这样的机制，才导致了可见性问题的存在，那我们就讨论下可见性的解决方案。</p><h2 id="可见性的解决方案"><a href="#可见性的解决方案" class="headerlink" title="可见性的解决方案"></a>可见性的解决方案</h2><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Wenjun w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Wenjun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        w<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>w<span class="token punctuation">.</span><span class="token function">isFlag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"有点东西"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="为啥加锁可以解决可见性问题呢？"><a href="#为啥加锁可以解决可见性问题呢？" class="headerlink" title="为啥加锁可以解决可见性问题呢？"></a>为啥加锁可以解决可见性问题呢？</h3><p>因为某一个线程进入 <code>synchronized</code> 代码块前后，线程会获得锁，清空工作内存，从主内存拷贝共享变量最新的值到工作内存成为副本，执行代码，将修改后的副本的值刷新回主内存中，线程释放锁。</p><p>而获取不到锁的线程会阻塞等待，所以变量的值肯定一直都是最新的。</p><h3 id="volatile-修饰共享变量"><a href="#volatile-修饰共享变量" class="headerlink" title="volatile 修饰共享变量"></a>volatile 修饰共享变量</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Wenjun w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Wenjun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        w<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>w<span class="token punctuation">.</span><span class="token function">isFlag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"有点东西"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Wenjun</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> flag<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isFlag</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> flag<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"falg = "</span> <span class="token operator">+</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="volatile-做了啥？"><a href="#volatile-做了啥？" class="headerlink" title="volatile 做了啥？"></a>volatile 做了啥？</h3><p>每个线程操作数据的时候会把数据从主内存读取到自己的工作内存，如果他操作了数据并且写回了，其他已经读取的线程的变量副本就会失效了，需要对数据进行操作时又要再次去主内存中读取了。</p><p><code>volatile</code> 保证不同线程对共享变量操作的可见性，也就是说一个线程修改了 <code>volatile</code> 修饰的变量，当修改写回主内存时，另外一个线程立即看到最新的值。</p><p>是不是看着加一个关键字很简单，但实际上他在背后含辛茹苦默默付出了不少，我从计算机层面的缓存一致性协议解释一下这些名词的意义。</p><p><img src="https://s1.ax1x.com/2020/05/03/YSGAdf.gif" alt=""></p><p>之前我们说过当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，举例说明变量在多个 CPU 之间的共享。</p><p>如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？</p><p>为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有 <strong>MSI</strong> 、<strong>MESI</strong>（lllinois Protocol）、<strong>MOSI</strong> 、<strong>Synapse</strong> 、<strong>Firefly</strong> 及 <strong>Dragon Protocol</strong> 等。</p><p>聊一下 Intel 的 <strong>MESI</strong> 吧。</p><h2 id="MESI（缓存一致性协议）"><a href="#MESI（缓存一致性协议）" class="headerlink" title="MESI（缓存一致性协议）"></a>MESI（缓存一致性协议）</h2><p>当 CPU 写数据时，如果发现操作的变量是共享变量，即在其他 CPU 中也存在该变量的副本，会发出信号通知其他 CPU 将该变量的缓存行置为<strong>无效状态</strong>，因此当其他 CPU 需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p><h3 id="至于是怎么发现数据是否失效呢？"><a href="#至于是怎么发现数据是否失效呢？" class="headerlink" title="至于是怎么发现数据是否失效呢？"></a>至于是怎么发现数据是否失效呢？</h3><h2 id="嗅探"><a href="#嗅探" class="headerlink" title="嗅探"></a>嗅探</h2><p>每个处理器通过<strong>嗅探在总线上传播的数据</strong>来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p><p><img src="https://s1.ax1x.com/2020/05/03/YSYWZt.gif" alt=""></p><h3 id="嗅探的缺点不知道大家发现了没有？"><a href="#嗅探的缺点不知道大家发现了没有？" class="headerlink" title="嗅探的缺点不知道大家发现了没有？"></a>嗅探的缺点不知道大家发现了没有？</h3><h2 id="总线风暴"><a href="#总线风暴" class="headerlink" title="总线风暴"></a>总线风暴</h2><p>由于 volatile 的 <strong>MESI</strong> 缓存一致性协议，需要不断的从主内存嗅探和 <strong>CAS</strong> 不断循环，无效交互会导致总线带宽达到峰值。</p><blockquote><p>解决办法：部分 volatile 和 CAS 使用 synchronized 代替。</p></blockquote><p>所以不要大量使用 volatile ，至于什么时候去使用 volatile 什么时候使用锁，根据场景区分。</p><p>我们再来聊一下 <code>指令重排序</code> 的问题</p><h2 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h2><h3 id="什么是重排序"><a href="#什么是重排序" class="headerlink" title="什么是重排序?"></a>什么是重排序?</h3><p>为了提高性能，编译器和处理器常常会对既定的代码执行顺序进行指令重排序。</p><h3 id="重排序的类型有哪些呢？源码到最终执行会经过哪些重排序呢？"><a href="#重排序的类型有哪些呢？源码到最终执行会经过哪些重排序呢？" class="headerlink" title="重排序的类型有哪些呢？源码到最终执行会经过哪些重排序呢？"></a>重排序的类型有哪些呢？源码到最终执行会经过哪些重排序呢？</h3><p><img src="https://s1.ax1x.com/2020/05/03/YSUJxg.png" alt="重排序"></p><p>一个好的内存模型实际上会放松对处理器和编译器规则的束缚，也就是说软件技术和硬件技术都为同一个目标而进行奋斗：在不改变程序执行结果的前提下，尽可能提高执行效率。</p><p>JMM 对底层尽量减少约束，使其能够发挥自身优势。</p><p>因此，在执行程序时，为了提高性能，编译器和处理器常常会对指令进行重排序。</p><p>一般重排序可以分为如下三种：</p><ul><li><strong>编译器优化的重排序。</strong>编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li><strong>指令级并行的重排序。</strong>现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li><strong>内存系统的重排序。</strong>由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。</li></ul><p>这里还得提一个概念，<code>as-if-serial</code> 。</p><h2 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h2><p>不管怎么重排序，单线程下的执行结果不能被改变。</p><p>编译器、runtime 和处理器都必须遵守 <code>as-if-serial</code> 语义。</p><h3 id="那-volatile-是怎么保证不会被执行重排序的呢？"><a href="#那-volatile-是怎么保证不会被执行重排序的呢？" class="headerlink" title="那 volatile 是怎么保证不会被执行重排序的呢？"></a>那 volatile 是怎么保证不会被执行重排序的呢？</h3><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>Java 编译器会在生成指令序列时在适当的位置会插入 <code>内存屏障</code> 指令来禁止特定类型的处理器重排序。</p><p>为了实现 volatile 的内存语义，JMM 会限制特定类型的编译器和处理器重排序，JMM 会针对编译器制定 volatile 重排序规则表：</p><p><img src="https://s1.ax1x.com/2020/05/03/YSUxFP.png" alt="重排序规则表"></p><p>需要注意的是：volatile 写是在<strong>前面和后面分别插入内存屏障</strong>，而 volatile 读操作是在<strong>后面插入两个内存屏障</strong>。</p><h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><p><img src="https://s1.ax1x.com/2020/05/03/YSaiLj.png" alt="写"></p><h3 id="读"><a href="#读" class="headerlink" title="读"></a>读</h3><p><img src="https://s1.ax1x.com/2020/05/03/YSad6e.png" alt="读"></p><p>上面的我提过重排序原则，为了提高处理速度，JVM 会对代码进行编译优化，也就是指令重排序优化，并发编程下指令重排序会带来一些安全隐患：如<strong>指令重排序导致的多个线程操作之间的不可见性</strong>。</p><p>如果让程序员再去了解这些底层的实现以及具体规则，那么程序员的负担就太重了，严重影响了并发编程的效率。</p><p>从 JDK 1.5 开始，提出了 <code>happens-before</code> 的概念，通过这个概念来阐述操作之间的内存可见性。</p><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 <code>happens-before</code> 关系。</p><blockquote><p>volatile 域规则：对一个 volatile 域的写操作，happens-before 于任意线程后续对这个 volatile 域的读。</p></blockquote><p>如果现在我的变了 flag 变成了 false ，那么后面的那个操作，一定要知道我变了。</p><p>聊了这么多，我们要知道 volatile 是没办法保证原子性的，一定要保证原子性，可以使用其他方法。</p><h2 id="无法保证原子性"><a href="#无法保证原子性" class="headerlink" title="无法保证原子性"></a>无法保证原子性</h2><p>就是一次操作，要么完全成功，要么完全失败。</p><p>假设现在有 N 个线程对同一个变量进行累加也是没办法保证结果是对的，因为读写这个过程并不是原子性的。</p><p>要解决也简单，要么用原子类，比如 AtomicInteger ，要么加锁（ <code>记得关注 Atomic 的底层</code> ）。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 双重检查（推荐面试使用） * @Author: wenjun * @Date: 2019/10/28 10:43 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//防止重排序和保证可见性</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//新建对象实际有3个步骤（非原子操作）:1.创建空的对象2.调用构造方法3.赋值到对象上</span>                    <span class="token comment" spellcheck="true">//重排序:1.创建空的对象2.赋值到对象上3.调用构造方法，导致对象内的属性为空</span>                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>单例有 8 种写法，我说一下里面比较特殊的一种，涉及 volatile 的。</p><h3 id="大家可能好奇为啥要双重检查？如果不用-volatile-会怎么样？"><a href="#大家可能好奇为啥要双重检查？如果不用-volatile-会怎么样？" class="headerlink" title="大家可能好奇为啥要双重检查？如果不用 volatile 会怎么样？"></a>大家可能好奇为啥要双重检查？如果不用 volatile 会怎么样？</h3><p>我先讲一下 <code>禁止指令重排序</code> 的好处。</p><p>对象实际上创建对象要进过如下几个步骤：</p><ul><li>分配内存空间。</li><li>调用构造器，初始化实例。</li><li>返回地址给引用</li></ul><p>上面我不是说了嘛，是可能发生指令重排序的，那有可能构造函数在对象初始化完成前就赋值完成了，在内存里面开辟了一片存储区域后直接返回内存的引用，这个时候还没真正的初始化完对象。</p><p>但是别的线程去判断 <code>instance != null</code> ，直接拿去用了，其实这个对象是个半成品，那就有空指针异常了。</p><h3 id="可见性怎么保证的？"><a href="#可见性怎么保证的？" class="headerlink" title="可见性怎么保证的？"></a>可见性怎么保证的？</h3><p>因为可见性，线程 A 在自己的内存初始化了对象，还没来得及写回主内存，线程 B 也这么做了，那就创建了多个对象，不是真正意义上的单例了。</p><p>上面提到了 volatile 与 synchronized ，那我聊一下他们的区别。</p><h2 id="volatile-与-synchronized-的区别"><a href="#volatile-与-synchronized-的区别" class="headerlink" title="volatile 与 synchronized 的区别"></a>volatile 与 synchronized 的区别</h2><p><code>volatile</code> 只能修饰实例变量和类变量，而 <code>synchronized</code> 可以修饰方法以及代码块。</p><p><code>volatile</code> 保证数据的可见性，但是不保证原子性（多线程进行写操作，不保证线程安全）；而 <code>synchronized</code> 是一种排他（互斥）的机制。</p><p><code>volatile</code> 用于禁止指令重排序：可以解决单例双重检查对象初始化代码执行乱序问题。</p><p><code>volatile</code> 可以看做是轻量版的 <code>synchronized</code> ，<code>volatile</code> 不保证原子性，但是如果是对一个共享变量进行多个线程的赋值，而没有其他的操作，那么就可以用 <code>volatile</code> 来代替 <code>synchronized</code> ，因为赋值本身是有原子性的，而 <code>volatile</code> 又保证了可见性，所以就可以保证线程安全了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>volatile 修饰符适用于以下场景：某个属性被多个线程共享，其中有一个线程修改了此属性，其他线程可以立即得到修改后的值，比如 <code>boolean flag;</code> ，或者作为触发器，实现轻量级同步。</li><li>volatile 属性的读写操作都是<strong>无锁</strong>的，它不能替代 synchronized ，因为它没有提供原子性和互斥性。因为无锁，不需要花费时间在获取锁和释放锁上，所以说它是<strong>低成本</strong>的。</li><li>volatile 只能作用于<strong>属性</strong>，我们用 volatile 修饰属性，这样 compilers 就不会对这个属性做指令重排序。</li><li>volatile 提供了可见性，任何一个线程对其的修改将立马对其他线程可见，volatile 属性不会被线程缓存，始终从<strong>主存</strong>中读取。</li><li>volatile 提供了 <code>happens-before</code> 保证，对 volatile 变量 v 的写入 happens-before 所有其他线程后续对 v 的读操作。</li><li>volatile 可以使得 long 和 double 的赋值是<strong>原子</strong>的。</li><li>volatile 可以在单例双重检查中实现<strong>可见性和禁止指令重排序</strong>，从而保证安全性。</li></ol><p><strong>注：以上所有的内容如果能全部掌握我想 volatile 在面试官那是很加分了，但是我还没讲到很多关于计算机内存那一块的底层，那大家就需要后面去补课了，如果等得及，也可以等到我写计算机基础章节。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized</title>
      <link href="/2020/04/17/hou-duan/bing-fa/synchronized/"/>
      <url>/2020/04/17/hou-duan/bing-fa/synchronized/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/04/17/JVzVrq.png" alt="Synchronized 关键字使用、底层原理、JDK1.6 之后的底层优化以及和 ReentrantLock 的对比"></p><h3 id="synchronized-关键字最主要的三种使用方式的总结"><a href="#synchronized-关键字最主要的三种使用方式的总结" class="headerlink" title="synchronized 关键字最主要的三种使用方式的总结"></a>synchronized 关键字最主要的三种使用方式的总结</h3><ul><li><strong>修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁。</strong></li><li><strong>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。</strong>也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份，所以对该类的所有对象都加了锁）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。</li><li><strong>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁。</strong> 和 synchronized 方法一样，synchronized(this) 代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class 类上锁。这里再提一下：synchronized关键字加到非 static 静态方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 <code>synchronized(String a)</code> 因为 JVM 中，字符串常量池具有缓冲功能！</li></ul><p>下面我已一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。</p><blockquote><p>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”</p></blockquote><p><strong>双重校验锁实现单例模式（线程安全）</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> Singleton uniqueInstance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//类对象加锁</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>另外，需要注意 uniqueInstance 采用 <strong><code>volatile</code></strong> 关键字修饰也是很有必要。</p><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的，<strong><code>uniqueInstance = new Singleton();</code></strong> 这段代码其实是分为三步执行：</p><ol><li>为 uniqueInstance 分配内存空间；</li><li>初始化 uniqueInstance ；</li><li>将 uniqueInstance 指向分配的内存地址。</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <strong><code>getUniqueInstance()</code></strong> 后发现 uniqueInstance 不为空，因此返回 uniqueInstance ，但此时 uniqueInstance 还未被初始化。</p><p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p><h3 id="synchronized-关键字底层原理总结"><a href="#synchronized-关键字底层原理总结" class="headerlink" title="synchronized 关键字底层原理总结"></a>synchronized 关键字底层原理总结</h3><p><strong>synchronized 关键字底层原理属于 JVM 层面。</strong></p><p><strong>① synchronized 同步语句块的情况</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"synchronized 代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>通过 JDK 自带的 <code>javap</code> 命令查看 SynchronizedDemo 类的相关字节码信息：首先切换到类的对应目录执行 <code>javac SynchronizedDemo.java</code> 命令生成编译后的 .class 文件，然后执行 <code>javap -c -s -v -l SynchronizedDemo.class</code> 。</p><p><img src="https://images.gitbook.cn/abc37c80-d21d-11e8-aab3-09d30029e0d5" alt="synchronized 关键字原理"></p><p>从上面我们可以看出：</p><p><strong>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong> 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor（ monitor 对象存在于每个 Java  对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么 Java 中任意对象可以作为锁的原因）的持有权。当计数器为 0 则可以成功获取，获取后将锁计数器设为 1 也就是加 1 。相应的在执行 monitorexit 指令后，将锁计数器设为 0 ，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><p><strong>② synchronized 修饰方法的的情况</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedDemo2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"synchronized 方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="https://images.gitbook.cn/7d407bf0-d21e-11e8-b2d6-1188c7e0dd7e" alt="synchronized 关键字原理"></p><p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取而代之的却是 <strong>ACC_SYNCHRONIZED</strong> 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标识来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><blockquote><p>在 Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。</p></blockquote><h3 id="JDK1-6-之后的底层优化"><a href="#JDK1-6-之后的底层优化" class="headerlink" title="JDK1.6 之后的底层优化"></a>JDK1.6 之后的底层优化</h3><blockquote><p>JDK1.6 对锁的实现引入了大量的优化，如<strong>偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化</strong>等技术来减少锁操作的开销。</p></blockquote><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><p><strong>①偏向锁</strong></p><p><strong>引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉。</strong></p><p>偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步！关于偏向锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的 13 章第三节锁优化。</p><p>但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</p><p><strong>② 轻量级锁</strong></p><p>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段（1.6之后加入的）。<strong>轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了 CAS 操作。</strong> 关于轻量级锁的加锁和解锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的 13 章第三节锁优化。</p><p><strong>轻量级锁能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生 CAS 操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！</strong></p><p><strong>③  自旋锁和自适应自旋</strong></p><p>轻量级锁失败后，虚拟机为了<strong>避免线程真实地在操作系统层面挂起</strong>，还会进行一项称为自旋锁的优化手段。</p><p>互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。</p><p><strong>一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。</strong> 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁。”<strong>为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋。</strong></p><p>百度百科对自旋锁的解释：</p><blockquote><p>何谓自旋锁？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。</p></blockquote><p>自旋锁在 JDK 1.6 之前其实就已经引入了，不过是默认关闭的，需要通过 <strong><code>--XX:+UseSpinning</code></strong> 参数来开启。JDK 1.6 及 1.6 之后，就改为默认开启的了。需要注意的是：自旋等待不能完全替代阻塞，因为它还是要占用处理器时间。如果锁被占用的时间短，那么效果当然就很好了！反之，相反！自旋等待的时间必须要有限度。如果自旋超过了限定次数任然没有获得锁，就应该挂起线程。<strong>自旋次数的默认值是10次，用户可以修改 <code>--XX:PreBlockSpin</code> 来更改。</strong></p><p>另外，<strong>在 JDK 1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了</strong>。</p><p><strong>④ 锁消除</strong></p><p>锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。</p><p><strong>⑤ 锁粗化</strong></p><p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——直在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。</p><p>大部分情况下，上面的原则都是没有问题的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗。</p><h3 id="Synchronized-和-ReentrantLock-的对比"><a href="#Synchronized-和-ReentrantLock-的对比" class="headerlink" title="Synchronized 和 ReentrantLock 的对比"></a>Synchronized 和 ReentrantLock 的对比</h3><p><strong>① 两者都是可重入锁</strong></p><p>两者都是<strong>可重入锁</strong>。“可重入锁”概念是：<strong>自己可以再次获取自己的内部锁</strong>。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1 ，所以要等到锁的计数器下降为 0 时才能释放锁。</p><p><strong>② synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</strong></p><p>synchronized 是依赖于 JVM 实现的，前面我们也讲到了虚拟机团队在 JDK 1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 <code>lock()</code> 和 <code>unlock()</code> 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p><p><strong>③ ReentrantLock 比 synchronized 增加了一些高级功能</strong></p><p>相比 synchronized ，ReentrantLock 增加了一些高级功能。主要来说主要有三点：<strong>①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）。</strong></p><ul><li><strong>ReentrantLock 提供了一种能够中断等待锁的线程的机制</strong>，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>ReentrantLock 可以指定是公平锁还是非公平锁。而 synchronized 只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</strong>ReentrantLock 默认情况是非公平的，可以通过 ReentrantLock 类的 <code>ReentrantLock(boolean fair)</code> 构造方法来制定是否是公平的。</li><li>synchronized 关键字与 <code>wait()</code> 和 <code>notify()/notifyAll()</code> 方法相结合可以实现等待/通知机制，ReentrantLock 类当然也可以实现，但是需要借助于 Condition 接口与 <code>newCondition()</code> 方法。Condition 是 JDK 1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能，也就是在一个 Lock 对象中可以创建多个 Condition 实例（即对象监视器），<strong>线程对象可以注册在指定的 Condition 中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用 notify()/notifyAll() 方法进行通知时，被通知的线程是由 JVM 选择的，用 ReentrantLock 类结合 Condition 实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是 Condition 接口默认提供的。而 synchronized 关键字就相当于整个 Lock 对象中只有一个 Condition 实例，所有的线程都注册在它一个身上。如果执行 <code>notifyAll()</code> 方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而 Condition 实例的 <code>signalAll()</code> 方法只会唤醒注册在该 Condition 实例中的所有等待线程。</li></ul><p>如果你想使用上述功能，那么选择 <strong>ReentrantLock</strong> 是一个不错的选择。</p><p><strong>④ 性能已不是选择标准</strong></p><p>在 JDK 1.6 之前，synchronized 的性能是比 ReentrantLock 差很多。具体表示为：synchronized 关键字吞吐量随线程数的增加，下降得非常严重。而 ReentrantLock 基本保持一个比较稳定的水平。我觉得这也侧面反映了， synchronized 关键字还有非常大的优化余地。后续的技术发展也证明了这一点，我们上面也讲了在 JDK 1.6 之后 JVM 团队对 synchronized 关键字做了很多优化。<strong>JDK1.6 之后，synchronized 和 ReentrantLock 的性能基本是持平了。所以网上那些说因为性能才选择 ReentrantLock 的文章都是错的！JDK 1.6之后，性能已经不是选择 synchronized 和 ReentrantLock 的影响因素了！而且虚拟机在未来的性能改进中会更偏向于原生的 synchronized ，所以还是提倡在 synchronized 能满足你的需求的情况下，优先考虑使用 synchronized 关键字来进行同步！优化后的 synchronized 和 ReentrantLock 一样，在很多地方都是用到了 CAS 操作。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乐观锁与悲观锁</title>
      <link href="/2020/04/16/hou-duan/bing-fa/le-guan-suo-yu-bei-guan-suo/"/>
      <url>/2020/04/16/hou-duan/bing-fa/le-guan-suo-yu-bei-guan-suo/</url>
      
        <content type="html"><![CDATA[<h3 id="何谓乐观锁与悲观锁"><a href="#何谓乐观锁与悲观锁" class="headerlink" title="何谓乐观锁与悲观锁"></a>何谓乐观锁与悲观锁</h3><blockquote><p><strong>乐观锁</strong>对应于生活中乐观的人总是想着事情往好的方向发展，<strong>悲观锁</strong>对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另外一种人。</p></blockquote><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中 <code>synchronized</code> 和 <code>ReentrantLock</code> 等独占锁就是悲观锁思想的实现。</p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用<strong>版本号</strong>机制和 <strong>CAS</strong> 算法实现。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>，像数据库提供的类似于 <strong>write_condition机制</strong> ，其实都是提供的乐观锁。在Java中 <code>java.util.concurrent.atomic</code> 包下面的原子变量类就是使用了乐观锁的一种实现方式 <strong>CAS</strong> 实现的。</p><h4 id="两种锁的使用场景"><a href="#两种锁的使用场景" class="headerlink" title="两种锁的使用场景"></a>两种锁的使用场景</h4><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像<strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行 retry ，这样反倒是降低了性能，所以<strong>一般多写的场景下用悲观锁就比较合适。</strong></p><h3 id="乐观锁常见的两种实现方式"><a href="#乐观锁常见的两种实现方式" class="headerlink" title="乐观锁常见的两种实现方式"></a>乐观锁常见的两种实现方式</h3><blockquote><p><strong>乐观锁一般会使用版本号机制或CAS算法实现。</strong></p></blockquote><h4 id="1-版本号机制"><a href="#1-版本号机制" class="headerlink" title="1. 版本号机制"></a>1. 版本号机制</h4><p>一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数，当数据被修改时，version 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version  值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。</p><p><strong>举一个简单的例子：</strong><br>假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。</p><ol><li>操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。</li><li>在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。</li><li>操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。</li><li>操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</li></ol><p>这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员 A 的操作结果的可能。</p><h4 id="2-CAS算法"><a href="#2-CAS算法" class="headerlink" title="2. CAS算法"></a>2. CAS算法</h4><p>即 <strong>Compare and Swap（比较与交换）</strong>，是一种有名的<strong>无锁算法</strong>。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。<strong>CAS 算法</strong>涉及到三个操作数：</p><ul><li>需要读写的内存值 V </li><li>进行比较的值 A </li><li>拟写入的新值 B</li></ul><p>当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个<strong>自旋操作</strong>，即<strong>不断的重试（默认重试 10 次，每次重试时间依据先前线程决定）</strong>。</p><p>关于自旋锁，大家可以看一下这篇文章，非常不错：<a href="https://blog.csdn.net/qq_34337272/article/details/81252853" target="_blank" rel="noopener">《<br>面试必备之深入理解自旋锁》</a></p><h3 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a>乐观锁的缺点</h3><blockquote><p> ABA 问题是乐观锁一个常见的问题。</p></blockquote><h4 id="1-ABA-问题"><a href="#1-ABA-问题" class="headerlink" title="1 ABA 问题"></a>1 ABA 问题</h4><p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A ，那  CAS 操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 <strong>“ABA” 问题。</strong></p><p>JDK 1.5 以后的 <code>AtomicStampedReference</code> 类就提供了此种能力，其中的 <code>compareAndSet()</code> 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><h4 id="2-循环时间长开销大"><a href="#2-循环时间长开销大" class="headerlink" title="2 循环时间长开销大"></a>2 循环时间长开销大</h4><p><strong>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。</strong> 如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline），使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起 CPU 流水线被清空（CPU pipeline flush），从而提高 CPU 的执行效率。</p><h4 id="3-只能保证一个共享变量的原子操作"><a href="#3-只能保证一个共享变量的原子操作" class="headerlink" title="3 只能保证一个共享变量的原子操作"></a>3 只能保证一个共享变量的原子操作</h4><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了 <code>AtomicReference</code> 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。所以我们可以使用锁或者利用 <code>AtomicReference</code> 类把多个共享变量合并成一个共享变量来操作。</p><h3 id="CAS与synchronized的使用情景"><a href="#CAS与synchronized的使用情景" class="headerlink" title="CAS与synchronized的使用情景"></a>CAS与synchronized的使用情景</h3><blockquote><p><strong>简单的来说 CAS 适用于写比较少的情况下（多读场景，冲突一般较少），synchronized 适用于写比较多的情况下（多写场景，冲突一般较多）。</strong></p></blockquote><ol><li>对于资源竞争较少（线程冲突较轻）的情况，使用 synchronized 同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗 CPU 资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li><li>对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized 。</li></ol><p>补充：Java并发编程这个领域中 synchronized 关键字一直都是元老级的角色，很久之前很多人都会称它为 <strong>“重量级锁”</strong> 。但是，在 JavaSE 1.6 之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 <strong>偏向锁</strong> 和 <strong>轻量级锁</strong> 以及其它<strong>各种优化</strong>之后变得在某些情况下并不是那么重了。synchronized 的底层实现主要依靠 <strong>Lock-Free</strong> 的队列，基本思路是 <strong>自旋后阻塞</strong>，<strong>竞争切换后继续竞争锁</strong>，<strong>稍微牺牲了公平性，但获得了高吞吐量</strong>。在线程冲突较少的情况下，可以获得和 CAS 类似的性能；而线程冲突严重的情况下，性能远高于 CAS 。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程池学习总结</title>
      <link href="/2020/04/16/hou-duan/bing-fa/java-xian-cheng-chi-xue-xi-zong-jie/"/>
      <url>/2020/04/16/hou-duan/bing-fa/java-xian-cheng-chi-xue-xi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="一-使用线程池的好处"><a href="#一-使用线程池的好处" class="headerlink" title="一 使用线程池的好处"></a>一 使用线程池的好处</h2><blockquote><p><strong>池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</strong></p></blockquote><p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）。每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p><p>这里借用《Java 并发编程的艺术》提到的来说一下<strong>使用线程池的好处</strong>：</p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h2 id="二-Executor-框架"><a href="#二-Executor-框架" class="headerlink" title="二 Executor 框架"></a>二 Executor 框架</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p>Executor 框架是 Java5 之后引进的，在 Java 5 之后，通过 Executor 来启动线程比使用 Thread 的 <code>start()</code> 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。</p><blockquote><p>补充：this 逃逸是指在构造函数返回之前其他线程就持有该对象的引用，调用尚未构造完全的对象的方法可能引发令人疑惑的错误。</p></blockquote><p>Executor 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，Executor 框架让并发编程变得更加简单。</p><h3 id="2-2-Executor-框架结构（主要由三大部分组成）"><a href="#2-2-Executor-框架结构（主要由三大部分组成）" class="headerlink" title="2.2 Executor 框架结构（主要由三大部分组成）"></a>2.2 Executor 框架结构（主要由三大部分组成）</h3><h4 id="1-任务（Runnable-Callable）"><a href="#1-任务（Runnable-Callable）" class="headerlink" title="1) 任务（Runnable /Callable）"></a>1) 任务（<code>Runnable</code> /<code>Callable</code>）</h4><p>执行任务需要实现的 <strong><code>Runnable</code> 接口</strong> 或 <strong><code>Callable</code>接口</strong>。<strong><code>Runnable</code> 接口</strong>或 <strong><code>Callable</code> 接口</strong> 实现类都可以被 <strong><code>ThreadPoolExecutor</code></strong> 或 <strong><code>ScheduledThreadPoolExecutor</code></strong> 执行。</p><h4 id="2-任务的执行（Executor）"><a href="#2-任务的执行（Executor）" class="headerlink" title="2) 任务的执行（Executor）"></a>2) 任务的执行（<code>Executor</code>）</h4><p>如下图所示，包括任务执行机制的核心接口 <strong><code>Executor</code></strong> ，以及继承自 <strong><code>Executor</code></strong> 接口的 <strong><code>ExecutorService</code> 接口。<code>ThreadPoolExecutor</code></strong> 和 <strong><code>ScheduledThreadPoolExecutor</code></strong> 这两个关键类实现了 <strong><code>ExecutorService</code></strong> 接口。</p><p><strong>这里提了很多底层的类关系，但是，实际上我们需要更多关注的是 <code>ThreadPoolExecutor</code> 这个类，这个类在我们实际使用线程池的过程中，使用频率还是非常高的。</strong></p><blockquote><p><strong>注意：</strong> 通过查看 <code>ScheduledThreadPoolExecutor</code> 源代码我们发现 <code>ScheduledThreadPoolExecutor</code> 实际上是继承了 <code>ThreadPoolExecutor</code> 并实现了 <code>ScheduledExecutorService</code> ，而 <code>ScheduledExecutorService</code> 又实现了 <code>ExecutorService</code>，正如我们下面给出的类关系图显示的一样。</p></blockquote><p><strong><code>ThreadPoolExecutor</code> 类描述:</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//AbstractExecutorService实现了ExecutorService接口</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolExecutor</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractExecutorService</span></code></pre><p><strong><code>ScheduledThreadPoolExecutor</code> 类描述：</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//ScheduledExecutorService实现了ExecutorService接口</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ScheduledThreadPoolExecutor</span>        <span class="token keyword">extends</span> <span class="token class-name">ThreadPoolExecutor</span>        <span class="token keyword">implements</span> <span class="token class-name">ScheduledExecutorService</span></code></pre><p><img src="https://s1.ax1x.com/2020/04/16/JkJShQ.jpg" alt="任务的执行相关接口"></p><h4 id="3-异步计算的结果（Future）"><a href="#3-异步计算的结果（Future）" class="headerlink" title="3) 异步计算的结果（Future）"></a>3) 异步计算的结果（<code>Future</code>）</h4><p><strong><code>Future</code></strong> 接口以及 <strong><code>Future</code></strong> 接口的实现类 <strong><code>FutureTask</code></strong> 类都可以代表异步计算的结果。</p><p>当我们把 <strong><code>Runnable</code>接口</strong> 或 <strong><code>Callable</code> 接口</strong> 的实现类提交给 <strong><code>ThreadPoolExecutor</code></strong> 或 <strong><code>ScheduledThreadPoolExecutor</code></strong> 执行。（调用 <strong><code>submit()</code></strong> 方法时会返回一个 <strong><code>FutureTask</code></strong> 对象）</p><h3 id="2-3-Executor-框架的使用示意图"><a href="#2-3-Executor-框架的使用示意图" class="headerlink" title="2.3 Executor 框架的使用示意图"></a>2.3 Executor 框架的使用示意图</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL215LWJsb2ctdG8tdXNlLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8xOC01LTMwLzg0ODIzMzMwLmpwZw?x-oss-process=image/format,png" alt="Executor 框架的使用示意图"></p><ol><li><strong>主线程首先要创建实现 <code>Runnable</code> 或者 <code>Callable</code> 接口的任务对象。</strong></li><li><strong>把创建完成的实现 <code>Runnable</code>/<code>Callable</code>接口的 对象直接交给 <code>ExecutorService</code> 执行</strong> （<code>ExecutorService.execute(Runnable command)</code>）或者也可以把 <code>Runnable</code> 对象或<code>Callable</code> 对象提交给 <code>ExecutorService</code> 执行（<code>ExecutorService.submit(Runnable task)</code>或 <code>ExecutorService.submit(Callable &lt;T&gt; task)</code>）。</li><li><strong>如果执行 <code>ExecutorService.submit(…)</code>，<code>ExecutorService</code> 将返回一个实现<code>Future</code>接口的对象</strong>（我们刚刚也提到过了执行 <code>execute()</code>方法和 <code>submit()</code>方法的区别，<code>submit()</code>会返回一个 <code>FutureTask</code> 对象）。由于 FutureTask 实现了 <code>Runnable</code>，我们也可以创建 <code>FutureTask</code>，然后直接交给 <code>ExecutorService</code> 执行。</li><li><strong>最后，主线程可以执行 <code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行 <code>FutureTask.cancel(boolean mayInterruptIfRunning)</code>来取消此任务的执行。</strong></li></ol><h2 id="三-ThreadPoolExecutor-类简单介绍（重要）"><a href="#三-ThreadPoolExecutor-类简单介绍（重要）" class="headerlink" title="三 ThreadPoolExecutor 类简单介绍（重要）"></a>三 ThreadPoolExecutor 类简单介绍（重要）</h2><p><strong>线程池实现类 <code>ThreadPoolExecutor</code> 是 <code>Executor</code> 框架最核心的类。</strong></p><h3 id="3-1-ThreadPoolExecutor-类分析"><a href="#3-1-ThreadPoolExecutor-类分析" class="headerlink" title="3.1 ThreadPoolExecutor 类分析"></a>3.1 ThreadPoolExecutor 类分析</h3><p><code>ThreadPoolExecutor</code> 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法，比如默认制定拒绝策略是什么），这里就不贴代码讲了，比较简单。</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 用给定的初始参数创建一个新的ThreadPoolExecutor。     */</span>    <span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池的核心线程数量</span>                              <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池的最大线程数</span>                              <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span>                              TimeUnit unit<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//时间单位</span>                              BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//任务队列，用来储存等待执行任务的队列</span>                              ThreadFactory threadFactory<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程工厂，用来创建线程，一般默认即可</span>                              RejectedExecutionHandler handler<span class="token comment" spellcheck="true">//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span>                               <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>            maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>            maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>            keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> null <span class="token operator">||</span> threadFactory <span class="token operator">==</span> null <span class="token operator">||</span> handler <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><blockquote><p><strong>下面这些对创建线程池非常重要，在后面使用线程池的过程中你一定会用到！所以，务必拿着小本本记清楚。</strong></p></blockquote><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code> ：</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> ：</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>：</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><strong><code>ThreadPoolExecutor</code></strong>其他常见参数：</p><ol><li><strong><code>keepAliveTime</code>：</strong>当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li><li><strong><code>unit</code>：</strong>  <code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>threadFactory</code>：</strong> Executor 创建新线程的时候会用到。</li><li><strong><code>handler</code>：</strong> 饱和策略。关于饱和策略下面单独介绍一下。</li></ol><p>下面这张图可以加深你对线程池中各个参数的相互关系的理解（图片来源：《 Java 性能调优实战》）：</p><p><img src="https://s1.ax1x.com/2020/04/16/JkHFYV.md.jpg" alt="线程池各个参数的关系"></p><p><strong><code>ThreadPoolExecutor</code> 饱和策略定义：</strong></p><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略：</p><ul><li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong>抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li><li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong>调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。</li><li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li><li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li></ul><p>举个例子：</p><blockquote><p>Spring 通过 <code>ThreadPoolTaskExecutor</code> 或者我们直接通过 <code>ThreadPoolExecutor</code> 的构造函数创建线程池的时候，当我们不指定 <code>RejectedExecutionHandler</code> 饱和策略的话来配置线程池的时候默认使用的是 <code>ThreadPoolExecutor.AbortPolicy</code>。在默认情况下，<code>ThreadPoolExecutor</code> 将抛出 <code>RejectedExecutionException</code> 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 <code>ThreadPoolExecutor.CallerRunsPolicy</code>。当最大池被填满时，此策略为我们提供可伸缩队列。（这个直接查看 <code>ThreadPoolExecutor</code> 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了。）</p></blockquote><h3 id="3-2-推荐使用-ThreadPoolExecutor-构造函数创建线程池"><a href="#3-2-推荐使用-ThreadPoolExecutor-构造函数创建线程池" class="headerlink" title="3.2 推荐使用 ThreadPoolExecutor 构造函数创建线程池"></a>3.2 推荐使用 <code>ThreadPoolExecutor</code> 构造函数创建线程池</h3><p><strong>在《阿里巴巴 Java 开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。</strong></p><p><strong>为什么呢？</strong></p><blockquote><p><strong>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</strong></p></blockquote><p><strong>另外《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</strong></p><blockquote><p>Executors 返回线程池对象的弊端如下：</p><ul><li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code>：</strong> 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。</li><li><strong><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code>：</strong> 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li></ul></blockquote><p><strong>方式一：通过 <code>ThreadPoolExecutor</code> 构造函数实现（推荐）</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL215LWJsb2ctdG8tdXNlLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8xOC00LTE2LzE3ODU4MjMwLmpwZw?x-oss-process=image/format,png" alt="ThreadPoolExecutor 构造方法"><br><strong>方式二：通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来实现</strong><br>我们可以创建三种类型的 ThreadPoolExecutor ：</p><ul><li><strong>FixedThreadPool</strong></li><li><strong>SingleThreadExecutor</strong></li><li><strong>CachedThreadPool</strong></li></ul><p>对应 Executors 工具类中的方法如图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL215LWJsb2ctdG8tdXNlLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8xOC00LTE2LzEzMjk2OTAxLmpwZw?x-oss-process=image/format,png" alt="Executor 框架的工具类"></p><h2 id="四-ThreadPoolExecutor-使用示例（重要）"><a href="#四-ThreadPoolExecutor-使用示例（重要）" class="headerlink" title="四 ThreadPoolExecutor 使用示例（重要）"></a>四 ThreadPoolExecutor 使用示例（重要）</h2><p>我们上面讲解了 <code>Executor</code>框架以及 <code>ThreadPoolExecutor</code> 类，下面让我们实战一下，来通过写一个 <code>ThreadPoolExecutor</code> 的小 Demo 来回顾上面的内容。</p><h3 id="4-1-示例代码：Runnable-ThreadPoolExecutor"><a href="#4-1-示例代码：Runnable-ThreadPoolExecutor" class="headerlink" title="4.1 示例代码：Runnable+ThreadPoolExecutor"></a>4.1 示例代码：<code>Runnable</code>+<code>ThreadPoolExecutor</code></h3><p>首先创建一个 <code>Runnable</code> 接口的实现类（当然也可以是 <code>Callable</code> 接口，我们上面也说了两者的区别。）</p><p><code>MyRunnable.java</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Date<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。 * @author shuang.kou */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String command<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MyRunnable</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>command <span class="token operator">=</span> s<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" Start. Time = "</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">processCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" End. Time = "</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>command<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>编写测试程序，我们这里以阿里巴巴推荐的使用 <code>ThreadPoolExecutor</code> 构造函数自定义参数的方式来创建线程池。</p><p><code>ThreadPoolExecutorDemo.java</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ArrayBlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ThreadPoolExecutor<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolExecutorDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CORE_POOL_SIZE <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_POOL_SIZE <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> QUEUE_CAPACITY <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Long KEEP_ALIVE_TIME <span class="token operator">=</span> 1L<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//使用阿里巴巴推荐的创建线程池的方式</span>        <span class="token comment" spellcheck="true">//通过ThreadPoolExecutor构造函数自定义参数创建</span>        ThreadPoolExecutor executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>                CORE_POOL_SIZE<span class="token punctuation">,</span>                MAX_POOL_SIZE<span class="token punctuation">,</span>                KEEP_ALIVE_TIME<span class="token punctuation">,</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>QUEUE_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>CallerRunsPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span>            Runnable worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token string">""</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//执行Runnable</span>            executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>worker<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//终止线程池</span>        executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>executor<span class="token punctuation">.</span><span class="token function">isTerminated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Finished all threads"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以看到我们上面的代码指定了：</p><ol><li><code>corePoolSize</code>：核心线程数为 5。</li><li><code>maximumPoolSize</code> ：最大线程数为 10。</li><li><code>keepAliveTime</code> ：等待时间为 1L。</li><li><code>unit</code>：等待时间的单位为 TimeUnit.SECONDS。</li><li><code>workQueue</code>：任务队列为 <code>ArrayBlockingQueue</code>，并且容量为 100。</li><li><code>handler</code>：饱和策略为 <code>CallerRunsPolicy</code>。</li></ol><p><strong>Output：</strong></p><pre class=" language-java"><code class="language-java">pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Sun Apr <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">37</span> CST <span class="token number">2020</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Sun Apr <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">37</span> CST <span class="token number">2020</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Sun Apr <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">37</span> CST <span class="token number">2020</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Sun Apr <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">37</span> CST <span class="token number">2020</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Sun Apr <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">37</span> CST <span class="token number">2020</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Sun Apr <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">42</span> CST <span class="token number">2020</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Sun Apr <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">42</span> CST <span class="token number">2020</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Sun Apr <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">42</span> CST <span class="token number">2020</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Sun Apr <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">42</span> CST <span class="token number">2020</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Sun Apr <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">42</span> CST <span class="token number">2020</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Sun Apr <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">42</span> CST <span class="token number">2020</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Sun Apr <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">42</span> CST <span class="token number">2020</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Sun Apr <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">42</span> CST <span class="token number">2020</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Sun Apr <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">42</span> CST <span class="token number">2020</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> Start<span class="token punctuation">.</span> Time <span class="token operator">=</span> Sun Apr <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">42</span> CST <span class="token number">2020</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Sun Apr <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">47</span> CST <span class="token number">2020</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Sun Apr <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">47</span> CST <span class="token number">2020</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Sun Apr <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">47</span> CST <span class="token number">2020</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Sun Apr <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">47</span> CST <span class="token number">2020</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span> End<span class="token punctuation">.</span> Time <span class="token operator">=</span> Sun Apr <span class="token number">12</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">47</span> CST <span class="token number">2020</span></code></pre><h3 id="4-2-线程池原理分析"><a href="#4-2-线程池原理分析" class="headerlink" title="4.2 线程池原理分析"></a>4.2 线程池原理分析</h3><p>承接 4.1 节，我们通过代码输出结果可以看出：<strong>线程首先会先执行 5 个任务，然后这些任务有任务被执行完的话，就会去拿新的任务执行。</strong> 大家可以先通过上面讲解的内容，分析一下到底是咋回事？（自己独立思考一会）</p><p>现在，我们就分析上面的输出内容来简单分析一下线程池原理。</p><p><strong>为了搞懂线程池的原理，我们需要首先分析一下 <code>execute()</code>方法。</strong>在 4.1 节中的 Demo 中我们使用 <code>executor.execute(worker)</code>来提交一个任务到线程池中去，这个方法非常重要，下面我们来看看它的源码：</p><pre class=" language-java"><code class="language-java">   <span class="token comment" spellcheck="true">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span>   <span class="token keyword">private</span> <span class="token keyword">final</span> AtomicInteger ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span>RUNNING<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> c <span class="token operator">&amp;</span> CAPACITY<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//任务队列</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果任务为null，则抛出异常。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// ctl 中保存的线程池当前的一些状态信息</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//  下面会涉及到 3 步 操作</span>        <span class="token comment" spellcheck="true">// 1.首先判断当前线程池中之行的任务数量是否小于 corePoolSize</span>        <span class="token comment" spellcheck="true">// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 2.如果当前之行的任务数量大于等于 corePoolSize 的时候就会走到这里</span>        <span class="token comment" spellcheck="true">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态才会被并且队列可以加入任务，该任务才会被加入进去</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 如果当前线程池为空就新创建一个线程并执行。</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span>        <span class="token comment" spellcheck="true">//如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>通过下图可以更好的对上面这 3 步做一个展示，下图是我为了省事直接从网上找到，原地址不明。</p><p><img src="https://s1.ax1x.com/2020/04/16/JkHiF0.png" alt="图解线程池实现原理"></p><p><strong><code>addWorker()</code> 这个方法主要用来创建新的工作线程，如果返回true说明创建和启动工作线程成功，否则的话返回的就是false。</strong></p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 全局锁，并发操作必备</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 跟踪线程池的最大大小，只有在持有全局锁mainLock的前提下才能访问此集合</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> largestPoolSize<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 工作线程集合，存放线程池中所有的（活跃的）工作线程，只有在持有全局锁mainLock的前提下才能访问此集合</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> HashSet<span class="token operator">&lt;</span>Worker<span class="token operator">></span> workers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获取线程池状态</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>     <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token operator">~</span>CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//判断线程池的状态是否为 Running</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isRunning</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> c <span class="token operator">&lt;</span> SHUTDOWN<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 添加新的工作线程到线程池     * @param firstTask 要执行     * @param core参数为true的话表示使用线程池的基本大小，为false使用线程池最大大小     * @return 添加成功就返回true否则返回false     */</span>   <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addWorker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">,</span> <span class="token keyword">boolean</span> core<span class="token punctuation">)</span> <span class="token punctuation">{</span>        retry<span class="token operator">:</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//这两句用来获取线程池的状态</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Check if queue empty only if necessary.</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>                <span class="token operator">!</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>                   firstTask <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span>                   <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">//获取线程池中线程的数量</span>                <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// core参数为true的话表明队列也满了，线程池大小变为 maximumPoolSize </span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">>=</span> CAPACITY <span class="token operator">||</span>                    wc <span class="token operator">>=</span> <span class="token punctuation">(</span>core <span class="token operator">?</span> corePoolSize <span class="token operator">:</span> maximumPoolSize<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//原子操作将workcount的数量加1</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndIncrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">break</span> retry<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 如果线程的状态改变了就再次执行上述操作</span>                c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> rs<span class="token punctuation">)</span>                    <span class="token keyword">continue</span> retry<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// else CAS failed due to workerCount change; retry inner loop</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 标记工作线程是否启动成功</span>        <span class="token keyword">boolean</span> workerStarted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 标记工作线程是否创建成功</span>        <span class="token keyword">boolean</span> workerAdded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        Worker w <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">final</span> Thread t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">// 加锁</span>                <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>                mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                   <span class="token comment" spellcheck="true">//获取线程池状态</span>                    <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//rs &lt; SHUTDOWN 如果线程池状态依然为RUNNING,并且线程的状态是存活的话，就会将工作线程添加到工作线程集合中</span>                  <span class="token comment" spellcheck="true">//(rs=SHUTDOWN &amp;&amp; firstTask == null)如果线程池状态小于STOP，也就是RUNNING或者SHUTDOWN状态下，同时传入的任务实例firstTask为null，则需要添加到工作线程集合和启动新的Worker</span>                   <span class="token comment" spellcheck="true">// firstTask == null证明只新建线程而不执行任务</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;</span> SHUTDOWN <span class="token operator">||</span>                        <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// precheck that t is startable</span>                            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//更新当前工作线程的最大容量</span>                        <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> largestPoolSize<span class="token punctuation">)</span>                            largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">// 工作线程是否启动成功</span>                        workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 释放锁</span>                    mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//// 如果成功添加工作线程，则调用Worker内部的线程实例t的Thread#start()方法启动真实的线程实例</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">/// 标记线程启动成功</span>                    workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">// 线程启动失败，需要从工作线程中移除对应的Worker</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> workerStarted<span class="token punctuation">)</span>                <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> workerStarted<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>更多关于线程池源码分析的内容推荐这篇文章：《<a href="http://www.throwable.club/2019/07/15/java-concurrency-thread-pool-executor/" target="_blank" rel="noopener">JUC线程池ThreadPoolExecutor源码分析</a>》</p><p>现在，让我们在回到 4.1 节我们写的 Demo， 现在应该是不是很容易就可以搞懂它的原理了呢？</p><p>没搞懂的话，也没关系，可以看看我的分析：</p><blockquote><p>我们在代码中模拟了 10 个任务，我们配置的核心线程数为 5 、等待队列容量为 100 ，所以每次只可能存在 5 个任务同时执行，剩下的 5 个任务会被放到等待队列中去。当前的5个任务中如果有任务被执行完了，线程池就会去拿新的任务执行。</p></blockquote><h3 id="4-3-几个常见的对比"><a href="#4-3-几个常见的对比" class="headerlink" title="4.3 几个常见的对比"></a>4.3 几个常见的对比</h3><h4 id="4-3-1-Runnable-vs-Callable"><a href="#4-3-1-Runnable-vs-Callable" class="headerlink" title="4.3.1 Runnable vs Callable"></a>4.3.1 <code>Runnable</code> vs <code>Callable</code></h4><p><code>Runnable</code>自 Java 1.0 以来一直存在，但<code>Callable</code>仅在 Java 1.5 中引入,目的就是为了来处理<code>Runnable</code>不支持的用例。<code>Runnable</code> <strong>接口</strong>不会返回结果或抛出检查异常，但是 <code>Callable</code> <strong>接口</strong>可以。所以，如果任务不需要返回结果或抛出异常推荐使用 <code>Runnable</code> <strong>接口</strong>，这样代码看起来会更加简洁。</p><p>工具类 <code>Executors</code> 可以实现 <code>Runnable</code> 对象和 <code>Callable</code> 对象之间的相互转换。（<code>Executors.callable(Runnable task)</code>）或 <code>Executors.callable(Runnable task, Object resule)</code>）。</p><p><code>Runnable.java</code></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">/**    * 被线程执行，没有返回值也无法抛出异常    */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>Callable.java</code></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 计算结果，或在无法这样做时抛出异常。     * @return 计算得出的结果     * @throws 如果无法计算结果，则抛出异常     */</span>    V <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="4-3-2-execute-vs-submit"><a href="#4-3-2-execute-vs-submit" class="headerlink" title="4.3.2 execute() vs submit()"></a>4.3.2 <code>execute()</code> vs <code>submit()</code></h4><ol><li><strong><code>execute()</code> 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li><li><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code> 方法来获取返回值，<code>get()</code> 方法会阻塞当前线程直到任务完成，而使用 <code>get(long timeout, TimeUnit unit)</code> 方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ol><p>我们以 <strong>AbstractExecutorService</strong> 接口中的一个 <code>submit()</code> 方法为例子来看看源代码：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> Future<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        RunnableFuture<span class="token operator">&lt;</span>Void<span class="token operator">></span> ftask <span class="token operator">=</span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">execute</span><span class="token punctuation">(</span>ftask<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ftask<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>上面方法调用的 <code>newTaskFor()</code> 方法返回了一个 <code>FutureTask</code> 对象。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">protected</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> RunnableFuture<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>Runnable runnable<span class="token punctuation">,</span> T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>runnable<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>我们再来看看<code>execute()</code>方法：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span></code></pre><h4 id="4-3-3-shutdown-VSshutdownNow"><a href="#4-3-3-shutdown-VSshutdownNow" class="headerlink" title="4.3.3 shutdown()VSshutdownNow()"></a>4.3.3 <code>shutdown()</code>VS<code>shutdownNow()</code></h4><ul><li><strong><code>shutdown()</code>：</strong>关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li><li><strong><code>shutdownNow()</code>：</strong>关闭线程池，线程的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li></ul><h4 id="4-3-2-isTerminated-VS-isShutdown"><a href="#4-3-2-isTerminated-VS-isShutdown" class="headerlink" title="4.3.2 isTerminated() VS isShutdown()"></a>4.3.2 <code>isTerminated()</code> VS <code>isShutdown()</code></h4><ul><li><strong><code>isShutDown()</code></strong> 当调用 <code>shutdown()</code> 方法后返回为 true。</li><li><strong><code>isTerminated()</code></strong> 当调用 <code>shutdown()</code> 方法后，并且所有提交的任务完成后返回为 true。</li></ul><h3 id="4-4-加餐：Callable-ThreadPoolExecutor示例代码"><a href="#4-4-加餐：Callable-ThreadPoolExecutor示例代码" class="headerlink" title="4.4 加餐：Callable+ThreadPoolExecutor示例代码"></a>4.4 加餐：<code>Callable</code>+<code>ThreadPoolExecutor</code>示例代码</h3><p><code>MyCallable.java</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Callable<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyCallable</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//返回执行当前 Callable 的线程名字</span>        <span class="token keyword">return</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>CallableDemo.java</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Date<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ArrayBlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Callable<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ExecutionException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Future<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ThreadPoolExecutor<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CallableDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CORE_POOL_SIZE <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_POOL_SIZE <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> QUEUE_CAPACITY <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Long KEEP_ALIVE_TIME <span class="token operator">=</span> 1L<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//使用阿里巴巴推荐的创建线程池的方式</span>        <span class="token comment" spellcheck="true">//通过ThreadPoolExecutor构造函数自定义参数创建</span>        ThreadPoolExecutor executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>                CORE_POOL_SIZE<span class="token punctuation">,</span>                MAX_POOL_SIZE<span class="token punctuation">,</span>                KEEP_ALIVE_TIME<span class="token punctuation">,</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>QUEUE_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>CallerRunsPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Future<span class="token operator">&lt;</span>String<span class="token operator">>></span> futureList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Callable<span class="token operator">&lt;</span>String<span class="token operator">></span> callable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyCallable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//提交任务到线程池</span>            Future<span class="token operator">&lt;</span>String<span class="token operator">></span> future <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>callable<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//将返回值 future 添加到 list，我们可以通过 future 获得 执行 Callable 得到的返回值</span>            futureList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>future<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Future<span class="token operator">&lt;</span>String<span class="token operator">></span> fut <span class="token operator">:</span> futureList<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"::"</span> <span class="token operator">+</span> fut<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> <span class="token operator">|</span> ExecutionException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//关闭线程池</span>        executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Output：</p><pre class=" language-java"><code class="language-java">Wed Nov <span class="token number">13</span> <span class="token number">13</span><span class="token operator">:</span><span class="token number">40</span><span class="token operator">:</span><span class="token number">41</span> CST <span class="token number">2019</span><span class="token operator">:</span><span class="token operator">:</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span>Wed Nov <span class="token number">13</span> <span class="token number">13</span><span class="token operator">:</span><span class="token number">40</span><span class="token operator">:</span><span class="token number">42</span> CST <span class="token number">2019</span><span class="token operator">:</span><span class="token operator">:</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span>Wed Nov <span class="token number">13</span> <span class="token number">13</span><span class="token operator">:</span><span class="token number">40</span><span class="token operator">:</span><span class="token number">42</span> CST <span class="token number">2019</span><span class="token operator">:</span><span class="token operator">:</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span>Wed Nov <span class="token number">13</span> <span class="token number">13</span><span class="token operator">:</span><span class="token number">40</span><span class="token operator">:</span><span class="token number">42</span> CST <span class="token number">2019</span><span class="token operator">:</span><span class="token operator">:</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span>Wed Nov <span class="token number">13</span> <span class="token number">13</span><span class="token operator">:</span><span class="token number">40</span><span class="token operator">:</span><span class="token number">42</span> CST <span class="token number">2019</span><span class="token operator">:</span><span class="token operator">:</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span>Wed Nov <span class="token number">13</span> <span class="token number">13</span><span class="token operator">:</span><span class="token number">40</span><span class="token operator">:</span><span class="token number">42</span> CST <span class="token number">2019</span><span class="token operator">:</span><span class="token operator">:</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span>Wed Nov <span class="token number">13</span> <span class="token number">13</span><span class="token operator">:</span><span class="token number">40</span><span class="token operator">:</span><span class="token number">43</span> CST <span class="token number">2019</span><span class="token operator">:</span><span class="token operator">:</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span>Wed Nov <span class="token number">13</span> <span class="token number">13</span><span class="token operator">:</span><span class="token number">40</span><span class="token operator">:</span><span class="token number">43</span> CST <span class="token number">2019</span><span class="token operator">:</span><span class="token operator">:</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span>Wed Nov <span class="token number">13</span> <span class="token number">13</span><span class="token operator">:</span><span class="token number">40</span><span class="token operator">:</span><span class="token number">43</span> CST <span class="token number">2019</span><span class="token operator">:</span><span class="token operator">:</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span>Wed Nov <span class="token number">13</span> <span class="token number">13</span><span class="token operator">:</span><span class="token number">40</span><span class="token operator">:</span><span class="token number">43</span> CST <span class="token number">2019</span><span class="token operator">:</span><span class="token operator">:</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">5</span></code></pre><h2 id="五-几种常见的线程池详解"><a href="#五-几种常见的线程池详解" class="headerlink" title="五 几种常见的线程池详解"></a>五 几种常见的线程池详解</h2><h3 id="5-1-FixedThreadPool"><a href="#5-1-FixedThreadPool" class="headerlink" title="5.1 FixedThreadPool"></a>5.1 FixedThreadPool</h3><h4 id="5-1-1-介绍"><a href="#5-1-1-介绍" class="headerlink" title="5.1.1 介绍"></a>5.1.1 介绍</h4><p><code>FixedThreadPool</code> 被称为可重用固定线程数的线程池。通过 Executors 类中的相关源代码来看一下相关实现：</p><pre class=" language-java"><code class="language-java">   <span class="token comment" spellcheck="true">/**     * 创建一个可重用固定数量线程的线程池     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">,</span> ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>                                      0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                      <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                      threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>另外还有一个 <code>FixedThreadPool</code> 的实现方法，和上面的类似，所以这里不多做阐述：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>                                      0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                      <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>从上面源代码可以看出新创建的 <code>FixedThreadPool</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都被设置为 nThreads，这个 nThreads 参数是我们使用的时候自己传递的。</strong></p><h4 id="5-1-2-执行任务过程介绍"><a href="#5-1-2-执行任务过程介绍" class="headerlink" title="5.1.2 执行任务过程介绍"></a>5.1.2 执行任务过程介绍</h4><p><code>FixedThreadPool</code> 的 <code>execute()</code> 方法运行示意图（该图片来源：《Java 并发编程的艺术》）：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL215LWJsb2ctdG8tdXNlLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8xOC00LTE2LzcxMzc1OTYzLmpwZw?x-oss-process=image/format,png" alt="FixedThreadPool的execute()方法运行示意图"></p><p><strong>上图说明：</strong></p><ol><li>如果当前运行的线程数小于 <strong>corePoolSize</strong>， 如果再来新任务的话，就创建新的线程来执行任务；</li><li>当前运行的线程数等于 <strong>corePoolSize</strong> 后， 如果再来新任务的话，会将任务加入 <code>LinkedBlockingQueue</code>；</li><li>线程池中的线程执行完手头的任务后，会在循环中反复从 <code>LinkedBlockingQueue</code> 中获取任务来执行；</li></ol><h4 id="5-1-3-为什么不推荐使用FixedThreadPool？"><a href="#5-1-3-为什么不推荐使用FixedThreadPool？" class="headerlink" title="5.1.3 为什么不推荐使用FixedThreadPool？"></a>5.1.3 为什么不推荐使用<code>FixedThreadPool</code>？</h4><p><strong><code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code>（队列的容量为 Intger.MAX_VALUE）作为线程池的工作队列会对线程池带来如下影响 ：</strong></p><ol><li>当线程池中的线程数达到 <code>corePoolSize</code> 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 <code>corePoolSize</code>；</li><li>由于使用无界队列时 <code>maximumPoolSize</code> 将是一个无效参数，因为不可能存在任务队列满的情况。所以，通过创建 <code>FixedThreadPool</code>的源码可以看出创建的 <code>FixedThreadPool</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 被设置为同一个值；</li><li>由于 1 和 2，使用无界队列时 <code>keepAliveTime</code> 将是一个无效参数；</li><li>运行中的 <code>FixedThreadPool</code>（未执行 <code>shutdown()</code>或 <code>shutdownNow()</code>）不会拒绝任务，在任务比较多的时候会导致 OOM（内存溢出）；</li></ol><h3 id="5-2-SingleThreadExecutor-详解"><a href="#5-2-SingleThreadExecutor-详解" class="headerlink" title="5.2 SingleThreadExecutor 详解"></a>5.2 SingleThreadExecutor 详解</h3><h4 id="5-2-1-介绍"><a href="#5-2-1-介绍" class="headerlink" title="5.2.1 介绍"></a>5.2.1 介绍</h4><p><code>SingleThreadExecutor</code> 是只有一个线程的线程池。下面看看<strong>SingleThreadExecutor 的实现：</strong></p><pre class=" language-java"><code class="language-java">   <span class="token comment" spellcheck="true">/**     *返回只有一个线程的线程池     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span>ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>            <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>                                    0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                    <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                    threadFactory<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">   <span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>            <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>                                    0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                    <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>从上面源代码可以看出新创建的 <code>SingleThreadExecutor</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都被设置为 1.其他参数和 <code>FixedThreadPool</code> 相同。</p><h4 id="5-2-2-执行任务过程介绍"><a href="#5-2-2-执行任务过程介绍" class="headerlink" title="5.2.2 执行任务过程介绍"></a>5.2.2 执行任务过程介绍</h4><p><strong><code>SingleThreadExecutor</code> 的运行示意图（该图片来源：《Java 并发编程的艺术》）：</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL215LWJsb2ctdG8tdXNlLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8xOC00LTE2LzgyMjc2NDU4LmpwZw?x-oss-process=image/format,png" alt="SingleThreadExecutor的运行示意图"></p><p><strong>上图说明;</strong></p><ol><li>如果当前运行的线程数少于 corePoolSize，则创建一个新的线程执行任务；</li><li>当前线程池中有一个运行的线程后，将任务加入 <code>LinkedBlockingQueue</code>；</li><li>线程执行完当前的任务后，会在循环中反复从<code>LinkedBlockingQueue</code> 中获取任务来执行；</li></ol><h4 id="5-2-3-为什么不推荐使用SingleThreadExecutor？"><a href="#5-2-3-为什么不推荐使用SingleThreadExecutor？" class="headerlink" title="5.2.3 为什么不推荐使用SingleThreadExecutor？"></a>5.2.3 为什么不推荐使用<code>SingleThreadExecutor</code>？</h4><p><code>SingleThreadExecutor</code> 使用无界队列 <code>LinkedBlockingQueue</code> 作为线程池的工作队列（队列的容量为 Intger.MAX_VALUE）。<code>SingleThreadExecutor</code> 使用无界队列作为线程池的工作队列会对线程池带来的影响与 <code>FixedThreadPool</code> 相同。说简单点就是可能会导致 OOM。</p><h3 id="5-3-CachedThreadPool-详解"><a href="#5-3-CachedThreadPool-详解" class="headerlink" title="5.3 CachedThreadPool 详解"></a>5.3 CachedThreadPool 详解</h3><h4 id="5-3-1-介绍"><a href="#5-3-1-介绍" class="headerlink" title="5.3.1 介绍"></a>5.3.1 介绍</h4><p><code>CachedThreadPool</code> 是一个会根据需要创建新线程的线程池。下面通过源码来看看 <code>CachedThreadPool</code> 的实现：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span>ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span>                                      60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                                      <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                      threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span>                                      60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                                      <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><code>CachedThreadPool</code> 的<code>corePoolSize</code> 被设置为空（0），<code>maximumPoolSize</code>被设置为 Integer.MAX_VALUE，即它是无界的，这也就意味着如果主线程提交任务的速度高于 <code>maximumPool</code> 中线程处理任务的速度时，<code>CachedThreadPool</code> 会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。</p><h4 id="5-3-2-执行任务过程介绍"><a href="#5-3-2-执行任务过程介绍" class="headerlink" title="5.3.2 执行任务过程介绍"></a>5.3.2 执行任务过程介绍</h4><p><strong>CachedThreadPool 的 execute()方法的执行示意图（该图片来源：《Java 并发编程的艺术》）：</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL215LWJsb2ctdG8tdXNlLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8xOC00LTE2LzE4NjExNzY3LmpwZw?x-oss-process=image/format,png" alt="CachedThreadPool的execute()方法的执行示意图"></p><p><strong>上图说明：</strong></p><ol><li>首先执行 <code>SynchronousQueue.offer(Runnable task)</code> 提交任务到任务队列。如果当前 <code>maximumPool</code> 中有空闲线程正在执行 <code>SynchronousQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code>，那么主线程执行 offer 操作与空闲线程执行的 <code>poll</code> 操作配对成功，主线程把任务交给空闲线程执行，<code>execute()</code>方法执行完成，否则执行下面的步骤 2；</li><li>当初始 <code>maximumPool</code> 为空，或者 <code>maximumPool</code> 中没有空闲线程时，将没有线程执行 <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>。这种情况下，步骤 1 将失败，此时 <code>CachedThreadPool</code> 会创建新线程执行任务，<code>execute()</code> 方法执行完成。</li></ol><h4 id="5-3-3-为什么不推荐使用CachedThreadPool？"><a href="#5-3-3-为什么不推荐使用CachedThreadPool？" class="headerlink" title="5.3.3 为什么不推荐使用CachedThreadPool？"></a>5.3.3 为什么不推荐使用<code>CachedThreadPool</code>？</h4><p><code>CachedThreadPool</code>允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</p><h2 id="六-ScheduledThreadPoolExecutor-详解"><a href="#六-ScheduledThreadPoolExecutor-详解" class="headerlink" title="六 ScheduledThreadPoolExecutor 详解"></a>六 ScheduledThreadPoolExecutor 详解</h2><p><strong><code>ScheduledThreadPoolExecutor</code> 主要用来在给定的延迟后运行任务，或者定期执行任务。</strong> 这个在实际项目中基本不会被用到，所以对这部分大家只需要简单了解一下它的思想。关于如何在 Spring Boot 中 实现定时任务，可以查看这篇文章<a href="https://github.com/Snailclimb/springboot-guide/blob/master/docs/advanced/SpringBoot-ScheduleTasks.md" target="_blank" rel="noopener">《5 分钟搞懂如何在 Spring Boot 中 Schedule Tasks》</a>。</p><h3 id="6-1-简介"><a href="#6-1-简介" class="headerlink" title="6.1 简介"></a>6.1 简介</h3><p><strong><code>ScheduledThreadPoolExecutor</code> 使用的任务队列 <code>DelayQueue</code> 封装了一个 <code>PriorityQueue</code>，<code>PriorityQueue</code> 会对队列中的任务进行排序，执行所需时间短的放在前面先被执行(<code>ScheduledFutureTask</code> 的 <code>time</code> 变量小的先执行)，如果执行所需时间相同则先提交的任务将被先执行(<code>ScheduledFutureTask</code> 的 <code>squenceNumber</code> 变量小的先执行)。</strong></p><p><strong><code>ScheduledThreadPoolExecutor</code> 和 <code>Timer</code> 的比较：</strong></p><ul><li><code>Timer</code> 对系统时钟的变化敏感，<code>ScheduledThreadPoolExecutor</code>不是；</li><li><code>Timer</code> 只有一个执行线程，因此长时间运行的任务可以延迟其他任务。 <code>ScheduledThreadPoolExecutor</code> 可以配置任意数量的线程。 此外，如果你想（通过提供 ThreadFactory），你可以完全控制创建的线程;</li><li>在<code>TimerTask</code> 中抛出的运行时异常会杀死一个线程，从而导致 <code>Timer</code> 死机:-( …即计划任务将不再运行。<code>ScheduledThreadExecutor</code> 不仅捕获运行时异常，还允许您在需要时处理它们（通过重写 <code>ThreadPoolExecutor</code>的<code>afterExecute()</code> 方法）。抛出异常的任务将被取消，但其他任务将继续运行。</li></ul><p><strong>综上，在 JDK1.5 之后，你没有理由再使用 Timer 进行任务调度了。</strong></p><blockquote><p><strong>备注：</strong>Quartz 是一个由 java 编写的任务调度库，由 OpenSymphony 组织开源出来。在实际项目开发中使用 Quartz 的还是居多，比较推荐使用 Quartz。因为 Quartz 理论上能够同时对上万个任务进行调度，拥有丰富的功能特性，包括任务调度、任务持久化、可集群化、插件等。</p></blockquote><h3 id="6-2-运行机制"><a href="#6-2-运行机制" class="headerlink" title="6.2 运行机制"></a>6.2 运行机制</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL215LWJsb2ctdG8tdXNlLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8xOC00LTE2LzkyNTk0Njk4LmpwZw?x-oss-process=image/format,png" alt="ScheduledThreadPoolExecutor运行机制"></p><p><strong><code>ScheduledThreadPoolExecutor</code> 的执行主要分为两大部分：</strong></p><ol><li>当调用 <code>ScheduledThreadPoolExecutor</code> 的 <strong><code>scheduleAtFixedRate()</code></strong> 方法或者<strong><code>scheduleWirhFixedDelay()</code></strong> 方法时，会向 <code>ScheduledThreadPoolExecutor</code> 的 <strong><code>DelayQueue</code></strong> 添加一个实现了 <strong><code>RunnableScheduledFuture</code></strong> 接口的 <strong><code>ScheduledFutureTask</code></strong> 。</li><li>线程池中的线程从 <code>DelayQueue</code> 中获取 <code>ScheduledFutureTask</code>，然后执行任务。</li></ol><p><strong><code>ScheduledThreadPoolExecutor</code> 为了实现周期性的执行任务，对 <code>ThreadPoolExecutor</code>做了如下修改：</strong></p><ul><li>使用 <strong><code>DelayQueue</code></strong> 作为任务队列；</li><li>获取任务的方不同；</li><li>执行周期任务后，增加了额外的处理。</li></ul><h3 id="6-3-ScheduledThreadPoolExecutor-执行周期任务的步骤"><a href="#6-3-ScheduledThreadPoolExecutor-执行周期任务的步骤" class="headerlink" title="6.3 ScheduledThreadPoolExecutor 执行周期任务的步骤"></a>6.3 ScheduledThreadPoolExecutor 执行周期任务的步骤</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL215LWJsb2ctdG8tdXNlLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8xOC01LTMwLzU5OTE2Mzg5LmpwZw?x-oss-process=image/format,png" alt="ScheduledThreadPoolExecutor执行周期任务的步骤"></p><ol><li>线程 1 从 <code>DelayQueue</code> 中获取已到期的 <code>ScheduledFutureTask(DelayQueue.take())</code>。到期任务是指 <code>ScheduledFutureTask</code>的 time 大于等于当前系统的时间；</li><li>线程 1 执行这个 <code>ScheduledFutureTask</code>；</li><li>线程 1 修改 <code>ScheduledFutureTask</code> 的 time 变量为下次将要被执行的时间；</li><li>线程 1 把这个修改 time 之后的 <code>ScheduledFutureTask</code> 放回 <code>DelayQueue</code> 中（<code>DelayQueue.add()</code>）。</li></ol><h2 id="七-线程池大小确定"><a href="#七-线程池大小确定" class="headerlink" title="七 线程池大小确定"></a>七 线程池大小确定</h2><p><strong>线程池数量的确定一直是困扰着程序员的一个难题，大部分程序员在设定线程池大小的时候就是随心而定。</strong></p><p>很多人甚至可能都会觉得把线程池配置过大一点比较好！我觉得这明显是有问题的。就拿我们生活中非常常见的一例子来说：<strong>并不是人多就能把事情做好，增加了沟通交流成本。你本来一件事情只需要 3 个人做，你硬是拉来了 6 个人，会提升做事效率嘛？我想并不会。</strong> 线程数量过多的影响也是和我们分配多少人做事情一样，对于多线程这个场景来说主要是增加了<strong>上下文切换</strong>成本。不清楚什么是上下文切换的话，可以看我下面的介绍。</p><blockquote><p>上下文切换：</p><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p><p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p><p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p></blockquote><p><strong>类比于实现世界中的人类通过合作做某件事情，我们可以肯定的一点是线程池大小设置过大或者过小都会有问题，合适的才是最好。</strong></p><p><strong>如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的！ CPU 根本没有得到充分利用。</strong></p><p><strong>但是，如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</strong></p><p>有一个简单并且适用面比较广的公式：</p><ul><li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li><li><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li></ul><p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p><h2 id="八-参考"><a href="#八-参考" class="headerlink" title="八 参考"></a>八 参考</h2><ul><li>《Java 并发编程的艺术》</li><li><a href="https://www.journaldev.com/2340/java-scheduler-scheduledexecutorservice-scheduledthreadpoolexecutor-example" target="_blank" rel="noopener" title="Java Scheduler ScheduledExecutorService ScheduledThreadPoolExecutor Example">Java Scheduler ScheduledExecutorService ScheduledThreadPoolExecutor Example</a></li><li><a href="https://examples.javacodegeeks.com/core-java/util/concurrent/scheduledthreadpoolexecutor/java-util-concurrent-scheduledthreadpoolexecutor-example/" target="_blank" rel="noopener" title="java.util.concurrent.ScheduledThreadPoolExecutor Example">java.util.concurrent.ScheduledThreadPoolExecutor Example</a></li><li><a href="https://www.journaldev.com/1069/threadpoolexecutor-java-thread-pool-example-executorservice" target="_blank" rel="noopener" title="ThreadPoolExecutor – Java Thread Pool Example">ThreadPoolExecutor – Java Thread Pool Example</a></li></ul><h2 id="九-其他推荐阅读"><a href="#九-其他推荐阅读" class="headerlink" title="九 其他推荐阅读"></a>九 其他推荐阅读</h2><ul><li><a href="https://www.cnblogs.com/warehouse/p/10720781.html" target="_blank" rel="noopener" title="Java并发（三）线程池原理">Java 并发（三）线程池原理</a></li><li><a href="https://github.com/crossoverJie/JCSprout/blob/master/MD/ThreadPoolExecutor.md" target="_blank" rel="noopener" title="如何优雅的使用和理解线程池">如何优雅的使用和理解线程池</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何设计一个RPC框架</title>
      <link href="/2020/04/16/kuang-jia/wei-fu-wu/ru-he-she-ji-yi-ge-rpc-kuang-jia/"/>
      <url>/2020/04/16/kuang-jia/wei-fu-wu/ru-he-she-ji-yi-ge-rpc-kuang-jia/</url>
      
        <content type="html"><![CDATA[<h2 id="如何设计一个-RPC-框架？"><a href="#如何设计一个-RPC-框架？" class="headerlink" title="如何设计一个 RPC 框架？"></a>如何设计一个 RPC 框架？</h2><p>如何设计一个 RPC 框架可以说是面试时的常客了，下面我就简要谈谈自己的看法。</p><h3 id="什么是-RPC-？"><a href="#什么是-RPC-？" class="headerlink" title="什么是 RPC ？"></a>什么是 RPC ？</h3><p>RPC（Remote Procedure  Call）——远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。比如两个不同的服务 A、B  部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 HTTP请求当然可以，但是可能会比较慢而且一些优化做的并不好。RPC 的出现就是为了解决这个问题。</p><h3 id="RPC-架构"><a href="#RPC-架构" class="headerlink" title="RPC 架构"></a>RPC 架构</h3><p>一个完整的RPC架构里面包含了四个核心的组件，分别是 <strong>Client</strong>、<strong>Client Stub</strong>、<strong>Server</strong> 以及 <strong>Server Stub</strong> ，这个 Stub 可以理解为存根。</p><ul><li>客户端（Client）：服务的调用方。</li><li>客户端存根（Client Stub）：存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。</li><li>服务端（Server）：真正的服务提供者。</li><li>服务端存根（Server Stub）：接收客户端发送过来的消息，将消息解包，并调用本地的方法。</li></ul><h3 id="RPC-调用过程"><a href="#RPC-调用过程" class="headerlink" title="RPC 调用过程"></a><strong>RPC 调用过程</strong></h3><p><img src="https://s1.ax1x.com/2020/04/16/JFconS.jpg" alt="RPC调用过程"></p><ul><li>服务消费方（client）调用以本地调用方式调用服务；</li><li>client stub 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li><li>client stub 找到服务地址，并将消息发送到服务端；</li><li>server stub 收到消息后进行解码；</li><li>server stub 根据解码结果调用本地的服务；</li><li>本地服务执行并将结果返回给 server stub ；</li><li>server stub 将返回结果打包成消息并发送至消费方；</li><li>client stub 接收到消息，并进行解码；</li><li>服务消费方得到最终结果。</li></ul><p>下面再贴一个网上的时序图：</p><p><img src="https://s1.ax1x.com/2020/04/16/JFc5X8.png" alt="RPC调用过程时序图"></p><h3 id="RPC-框架涉及技术"><a href="#RPC-框架涉及技术" class="headerlink" title="RPC 框架涉及技术"></a>RPC 框架涉及技术</h3><p><strong>建立通信</strong></p><p>​        首先，要解决通讯的问题，主要是通过在客户端和服务器之间建立 TCP 连接，远程过程调用的所有交换的数据都在这个连接里传输。当前很多RPC框架都直接基于 Netty 这一 IO 通信框架，推荐使用 Netty 作为底层通信框架。</p><p><strong>网络传输</strong></p><p>​        数据传输采用什么协议（二进制数据格式组织）？</p><p>​        数据该如何序列化和反序列化？( kryo / protobuf / protostuff / hessian / fastjson / …)</p><p><strong>服务寻址</strong></p><ul><li>服务注册：服务提供者启动后主动把服务注册到服务中心，注册中心（如 ZooKeeper 、Eureka）存储了该服务的 IP 、端口、调用方式（协议、序列化方式）等信息。</li><li>服务发现：服务消费者第一次调用服务时，会通过注册中心找到相应的服务提供方地址列表，并缓存到本地，以供后续使用。当消费者再次调用服务时，不会再去请求注册中心，而是直接通过负载均衡算法从 IP 列表中取一个服务提供者的服务器调用服务。</li></ul><p><strong>服务调用</strong></p><p>​        服务消费者进行本地调用（通过动态代理）之后得到了返回值。实际上是在 Proxy 中封装了一系列的过程，包括序列化、请求服务提供者、反序列化等。</p><h3 id="实现高可用-RPC-框架需要考虑到的问题"><a href="#实现高可用-RPC-框架需要考虑到的问题" class="headerlink" title="实现高可用 RPC 框架需要考虑到的问题"></a>实现高可用 RPC 框架需要考虑到的问题</h3><ul><li>既然系统采用分布式架构，那一个服务势必会有多个实例，要解决如何获取实例的问题？</li><li>如何选择实例呢？就要考虑负载均衡。</li><li>如果每次都去注册中心查询列表，效率很低，那么就要加缓存。</li><li>客户端总不能每次调用完都等着服务端返回数据，所以就要支持异步调用。</li><li>服务端的接口修改了，老的接口还有人在用，这就需要版本控制。</li><li>服务端总不能每次接到请求都马上启动一个线程去处理，于是就需要线程池。</li><li>容器支持，如 Kubernetes 、Docker 等。</li></ul><h3 id="简易的回答思路"><a href="#简易的回答思路" class="headerlink" title="简易的回答思路"></a>简易的回答思路</h3><ul><li>上来你的服务就得去注册中心注册吧，你是不是得有个注册中心，保留各个服务的信息，可以用 Zookeeper 来做，对吧。</li><li>然后你的消费者需要去注册中心拿对应的服务信息吧，对吧，而且每个服务可能会存在于多台机器上。</li><li>接着你就该发起一次请求了，咋发起？当然是基于动态代理了，你面向接口获取到一个动态代理，这个动态代理就是接口在本地的一个代理，然后这个代理会找到服务对应的机器地址。</li><li>然后找哪个机器发送请求？那肯定得有个负载均衡算法了，比如最简单的可以随机轮询是不是。</li><li>接着找到一台机器，就可以跟它发送请求了，第一个问题咋发送？你可以说用 Netty 了，NIO 方式；第二个问题发送啥格式数据？你可以说用 hessian 序列化协议了，或者是别的，对吧。然后请求过去了。</li><li>服务器那边一样的，需要针对你自己的服务生成一个动态代理，监听某个网络端口了，然后代理你本地的服务代码。接收到请求的时候，就调用对应的服务代码，对吧。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发容器总结</title>
      <link href="/2020/04/16/hou-duan/bing-fa/java-bing-fa-rong-qi-zong-jie/"/>
      <url>/2020/04/16/hou-duan/bing-fa/java-bing-fa-rong-qi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="一-JDK-提供的并发容器总结"><a href="#一-JDK-提供的并发容器总结" class="headerlink" title="一 JDK 提供的并发容器总结"></a>一 JDK 提供的并发容器总结</h2><p>JDK 提供的这些容器大部分在 <code>java.util.concurrent</code> 包中。</p><ul><li><strong>ConcurrentHashMap：</strong> 线程安全的 HashMap。</li><li><strong>CopyOnWriteArrayList：</strong> 线程安全的 List，在读多写少的场合性能非常好，远远好于 Vector。</li><li><strong>ConcurrentLinkedQueue：</strong> 高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。</li><li><strong>BlockingQueue：</strong> 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。</li><li><strong>ConcurrentSkipListMap：</strong> 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。</li></ul><h2 id="二-ConcurrentHashMap"><a href="#二-ConcurrentHashMap" class="headerlink" title="二 ConcurrentHashMap"></a>二 ConcurrentHashMap</h2><p>我们知道 HashMap 不是线程安全的，在并发场景下如果要保证一种可行的方式是使用 <code>Collections.synchronizedMap()</code> 方法来包装我们的 HashMap。但这是通过使用一个全局的锁来同步不同线程间的并发访问，因此会带来不可忽视的性能问题。</p><p>所以就有了 HashMap 的线程安全版本—— ConcurrentHashMap 的诞生。在 ConcurrentHashMap 中，无论是读操作还是写操作都能保证很高的性能：在进行读操作时(几乎)不需要加锁，而在写操作时通过锁分段技术只对所操作的段加锁而不影响客户端对其它段的访问。</p><p>关于 ConcurrentHashMap 相关问题，我在 <a href="https://www.niewenjun.com/2020/04/15/hou-duan/ji-he/java-ji-he-kuang-jia-chang-jian-mian-shi-ti"Java集合框架常见面试题"">Java 集合框架常见面试题</a> 这篇文章中已经提到过。</p><h2 id="三-CopyOnWriteArrayList"><a href="#三-CopyOnWriteArrayList" class="headerlink" title="三 CopyOnWriteArrayList"></a>三 CopyOnWriteArrayList</h2><h3 id="3-1-CopyOnWriteArrayList-简介"><a href="#3-1-CopyOnWriteArrayList-简介" class="headerlink" title="3.1 CopyOnWriteArrayList 简介"></a>3.1 CopyOnWriteArrayList 简介</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token keyword">extends</span> <span class="token class-name">Object</span><span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">,</span> RandomAccess<span class="token punctuation">,</span> Cloneable<span class="token punctuation">,</span> Serializable</code></pre><p>在很多应用场景中，读操作可能会远远大于写操作。由于读操作根本不会修改原有的数据，因此对于每次读取都进行加锁其实是一种资源浪费。我们应该允许多个线程同时访问 List 的内部数据，毕竟读取操作是安全的。</p><p>这和我们之前在多线程章节讲过 <code>ReentrantReadWriteLock</code> 读写锁的思想非常类似，也就是读读共享、写写互斥、读写互斥、写读互斥。JDK 中提供了 <code>CopyOnWriteArrayList</code> 类比相比于在读写锁的思想又更进一步。为了将读取的性能发挥到极致，<code>CopyOnWriteArrayList</code> 读取是完全不用加锁的，并且更厉害的是：写入也不会阻塞读取操作。只有写入和写入之间需要进行同步等待。这样一来，读操作的性能就会大幅度提升。<strong>那它是怎么做的呢？</strong></p><h3 id="3-2-CopyOnWriteArrayList-是如何做到的？"><a href="#3-2-CopyOnWriteArrayList-是如何做到的？" class="headerlink" title="3.2 CopyOnWriteArrayList 是如何做到的？"></a>3.2 CopyOnWriteArrayList 是如何做到的？</h3><p><code>CopyOnWriteArrayList</code> 类的所有可变操作（add，set 等等）都是通过创建底层数组的新副本来实现的。当 List 需要被修改的时候，我并不修改原有内容，而是对原有数据进行一次复制，将修改的内容写入副本。写完之后，再将修改完的副本替换原来的数据，这样就可以保证写操作不会影响读操作了。</p><p>从 <code>CopyOnWriteArrayList</code> 的名字就能看出<code>CopyOnWriteArrayList</code> 是满足<code>CopyOnWrite</code> 的 ArrayList，所谓<code>CopyOnWrite</code> 也就是说：在计算机，如果你想要对一块内存进行修改时，我们不在原有内存块中进行写操作，而是将内存拷贝一份，在新的内存中进行写操作，写完之后呢，就将指向原来内存指针指向新的内存，原来的内存就可以被回收掉了。</p><h3 id="3-3-CopyOnWriteArrayList-读取和写入源码简单分析"><a href="#3-3-CopyOnWriteArrayList-读取和写入源码简单分析" class="headerlink" title="3.3 CopyOnWriteArrayList 读取和写入源码简单分析"></a>3.3 CopyOnWriteArrayList 读取和写入源码简单分析</h3><h4 id="3-3-1-CopyOnWriteArrayList-读取操作的实现"><a href="#3-3-1-CopyOnWriteArrayList-读取操作的实现" class="headerlink" title="3.3.1 CopyOnWriteArrayList 读取操作的实现"></a>3.3.1 CopyOnWriteArrayList 读取操作的实现</h4><p>读取操作没有任何同步控制和锁操作，理由就是内部数组 array 不会发生修改，只会被另外一个 array 替换，因此可以保证数据安全。</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/** The array, accessed only via getArray/setArray. */</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">;</span>    <span class="token keyword">public</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> E <span class="token function">get</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> a<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> array<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h4 id="3-3-2-CopyOnWriteArrayList-写入操作的实现"><a href="#3-3-2-CopyOnWriteArrayList-写入操作的实现" class="headerlink" title="3.3.2 CopyOnWriteArrayList 写入操作的实现"></a>3.3.2 CopyOnWriteArrayList 写入操作的实现</h4><p>CopyOnWriteArrayList 写入操作 <code>add()</code> 方法在添加集合的时候加了锁，保证了同步，避免了多线程写的时候会 copy 出多个副本出来。</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * Appends the specified element to the end of this list.     *     * @param e element to be appended to this list     * @return {@code true} (as specified by {@link Collection#add})     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//加锁</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>            Object<span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//拷贝新数组</span>            newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//释放锁</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h2 id="四-ConcurrentLinkedQueue"><a href="#四-ConcurrentLinkedQueue" class="headerlink" title="四 ConcurrentLinkedQueue"></a>四 ConcurrentLinkedQueue</h2><p>Java 提供的线程安全的 Queue 可以分为<strong>阻塞队列</strong>和<strong>非阻塞队列</strong>，其中阻塞队列的典型例子是 <strong>BlockingQueue</strong>，非阻塞队列的典型例子是 <strong>ConcurrentLinkedQueue</strong>，在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。 <strong>阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。</strong></p><p>从名字可以看出，<code>ConcurrentLinkedQueue</code>这个队列使用链表作为其数据结构。ConcurrentLinkedQueue 应该算是在高并发环境中性能最好的队列了。它之所有能有很好的性能，是因为其内部复杂的实现。</p><p>ConcurrentLinkedQueue 内部代码我们就不分析了，大家知道 ConcurrentLinkedQueue 主要使用 <strong>CAS</strong> 非阻塞算法来实现线程安全就好了。</p><p>ConcurrentLinkedQueue 适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的 ConcurrentLinkedQueue 来替代。</p><h2 id="五-BlockingQueue"><a href="#五-BlockingQueue" class="headerlink" title="五 BlockingQueue"></a>五 BlockingQueue</h2><h3 id="5-1-BlockingQueue-简单介绍"><a href="#5-1-BlockingQueue-简单介绍" class="headerlink" title="5.1 BlockingQueue 简单介绍"></a>5.1 BlockingQueue 简单介绍</h3><p>上面我们己经提到了 ConcurrentLinkedQueue 作为高性能的非阻塞队列。下面我们要讲到的是阻塞队列——BlockingQueue。阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是 BlockingQueue 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</p><p>BlockingQueue 是一个接口，继承自 Queue，所以其实现类也可以作为 Queue 的实现来使用，而 Queue 又继承自 Collection 接口。下面是 BlockingQueue 的相关实现类：</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-9/51622268.jpg" alt="BlockingQueue 的实现类"></p><blockquote><p><strong>下面主要介绍一下：ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue，这三个 BlockingQueue 的实现类。</strong></p></blockquote><h3 id="5-2-ArrayBlockingQueue"><a href="#5-2-ArrayBlockingQueue" class="headerlink" title="5.2 ArrayBlockingQueue"></a>5.2 ArrayBlockingQueue</h3><p><strong>ArrayBlockingQueue</strong> 是 BlockingQueue 接口的有界队列实现类，底层采用<strong>数组</strong>来实现。ArrayBlockingQueue 一旦创建，容量不能改变。其并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻塞；尝试从一个空队列中取一个元素也会同样阻塞。</p><p>ArrayBlockingQueue 默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 ArrayBlockingQueue。而非公平性则是指访问 ArrayBlockingQueue 的顺序不是遵守严格的时间顺序，有可能存在，当 ArrayBlockingQueue 可以被访问时，长时间阻塞的线程依然无法访问到 ArrayBlockingQueue。如果保证公平性，通常会降低吞吐量。如果需要获得公平性的 ArrayBlockingQueue，可采用如下代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> ArrayBlockingQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="5-3-LinkedBlockingQueue"><a href="#5-3-LinkedBlockingQueue" class="headerlink" title="5.3 LinkedBlockingQueue"></a>5.3 LinkedBlockingQueue</h3><p><strong>LinkedBlockingQueue</strong> 底层基于<strong>单向链表</strong>实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足 FIFO 的特性，与 ArrayBlockingQueue 相比起来具有更高的吞吐量，为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存。通常在创建 LinkedBlockingQueue 对象时，会指定其大小，如果未指定，容量等于 Integer.MAX_VALUE。</p><p><strong>相关构造方法:</strong></p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     *某种意义上的无界队列     * Creates a {@code LinkedBlockingQueue} with a capacity of     * {@link Integer#MAX_VALUE}.     */</span>    <span class="token keyword">public</span> <span class="token function">LinkedBlockingQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     *有界队列     * Creates a {@code LinkedBlockingQueue} with the given (fixed) capacity.     *     * @param capacity the capacity of this queue     * @throws IllegalArgumentException if {@code capacity} is not greater     *         than zero     */</span>    <span class="token keyword">public</span> <span class="token function">LinkedBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>capacity <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>        last <span class="token operator">=</span> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="5-4-PriorityBlockingQueue"><a href="#5-4-PriorityBlockingQueue" class="headerlink" title="5.4 PriorityBlockingQueue"></a>5.4 PriorityBlockingQueue</h3><p><strong>PriorityBlockingQueue</strong> 是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 <code>compareTo()</code> 方法来指定元素排序规则，或者初始化时通过构造器参数 <code>Comparator</code> 来指定排序规则。</p><p>PriorityBlockingQueue 并发控制采用的是 <strong>ReentrantLock</strong>，队列为无界队列（ArrayBlockingQueue 是有界队列，LinkedBlockingQueue 也可以通过在构造函数中传入 capacity 指定队列最大的容量，但是 PriorityBlockingQueue 只能指定初始的队列大小，后面插入元素的时候，<strong>如果空间不够的话会自动扩容</strong>）。</p><p>简单地说，它就是 PriorityQueue 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 <strong>ClassCastException</strong> 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。</p><p><strong>推荐文章：</strong></p><p><a href="https://javadoop.com/post/java-concurrent-queue" target="_blank" rel="noopener" title="https://javadoop.com/post/java-concurrent-queue">《解读 Java 并发队列 BlockingQueue》</a></p><h2 id="六-ConcurrentSkipListMap"><a href="#六-ConcurrentSkipListMap" class="headerlink" title="六 ConcurrentSkipListMap"></a>六 ConcurrentSkipListMap</h2><p>下面这部分内容参考了极客时间专栏<a href="https://time.geekbang.org/column/intro/126?code=zl3GYeAsRI4rEJIBNu5B/km7LSZsPDlGWQEpAYw5Vu0=&utm_term=SPoster" target="_blank" rel="noopener" title="《数据结构与算法之美》">《数据结构与算法之美》</a>以及《实战 Java 高并发程序设计》。</p><p><strong>为了引出 ConcurrentSkipListMap，先带着大家简单理解一下跳表。</strong></p><p>对于一个单链表，即使链表是有序的，如果我们想要在其中查找某个数据，也只能从头到尾遍历链表，这样效率自然就会很低，跳表就不一样了。跳表是一种可以用来快速查找的数据结构，有点类似于平衡树。它们都可以对元素进行快速的查找。但一个重要的区别是：对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整。而对跳表的插入和删除只需要对整个数据结构的局部进行操作即可。这样带来的好处是：在高并发的情况下，你会需要一个全局锁来保证整个平衡树的线程安全。而对于跳表，你只需要部分锁即可。这样，在高并发环境下，你就可以拥有更好的性能。而就查询的性能而言，跳表的时间复杂度也是 <strong>O(logn)</strong> 所以在并发数据结构中，JDK 使用跳表来实现一个 Map。</p><p>跳表的本质是同时维护了多个链表，并且链表是分层的。</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-9/93666217.jpg" alt="2级索引跳表"></p><p>最低层的链表维护了跳表内所有的元素，每上面一层链表都是下面一层的子集。</p><p>跳表内的所有链表的元素都是排序的。查找时，可以从顶级链表开始找。一旦发现被查找的元素大于当前链表中的取值，就会转入下一层链表继续找。这也就是说在查找过程中，搜索是跳跃式的。如上图所示，在跳表中查找元素 18。</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-9/32005738.jpg" alt="在跳表中查找元素18"></p><p>查找 18 的时候原来需要遍历 18 次，现在只需要 7 次即可。针对链表长度比较大的时候，构建索引查找效率的提升就会非常明显。</p><p>从上面很容易看出，<strong>跳表是一种利用空间换时间的算法。</strong></p><blockquote><p>Redis中 <strong>zset（sorted set）</strong>就使用到了跳表这种数据结构。</p></blockquote><p>使用跳表实现 Map 和使用哈希算法实现 Map 的另外一个不同之处是：哈希并不会保存元素的顺序，而跳表内所有的元素都是排序的。因此在对跳表进行遍历时，你会得到一个有序的结果。所以，如果你的应用需要有序性，那么跳表就是你不二的选择。JDK 中实现这一数据结构的类是 ConcurrentSkipListMap。</p><h2 id="七-参考"><a href="#七-参考" class="headerlink" title="七 参考"></a>七 参考</h2><ul><li>《实战 Java 高并发程序设计》</li><li><a href="https://javadoop.com/post/java-concurrent-queue" target="_blank" rel="noopener">https://javadoop.com/post/java-concurrent-queue</a></li><li><a href="https://juejin.im/post/5aeebd02518825672f19c546" target="_blank" rel="noopener">https://juejin.im/post/5aeebd02518825672f19c546</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架常见面试题</title>
      <link href="/2020/04/15/hou-duan/ji-he/java-ji-he-kuang-jia-chang-jian-mian-shi-ti/"/>
      <url>/2020/04/15/hou-duan/ji-he/java-ji-he-kuang-jia-chang-jian-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="剖析面试最常见问题之-Java-集合框架"><a href="#剖析面试最常见问题之-Java-集合框架" class="headerlink" title="剖析面试最常见问题之 Java 集合框架"></a>剖析面试最常见问题之 Java 集合框架</h1><h2 id="说说-List-，Set-，Map-三者的区别？"><a href="#说说-List-，Set-，Map-三者的区别？" class="headerlink" title="说说 List ，Set ，Map 三者的区别？"></a>说说 List ，Set ，Map 三者的区别？</h2><ul><li><strong>List（对付顺序的好帮手）：</strong>List 接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象。</li><li><strong>Set（注重独一无二的性质）：</strong> 不允许重复的集合。不会有多个元素引用相同的对象。</li><li><strong>Map（用 Key 来搜索的专家）：</strong>使用键值对存储。Map 会维护与 Key 有关联的值。两个 Key 可以引用相同的对象，但 Key 不能重复，典型的 Key 是 String 类型，但也可以是任何对象。</li></ul><h2 id="ArrayList-与-LinkedList-区别"><a href="#ArrayList-与-LinkedList-区别" class="headerlink" title="ArrayList 与 LinkedList 区别?"></a>ArrayList 与 LinkedList 区别?</h2><ul><li><p><strong>1. 是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全。</p></li><li><p><strong>2. 底层数据结构：</strong> <code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（ JDK 1.6 之前为循环链表，JDK 1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</p></li><li><p><strong>3. 插入和删除是否受元素位置的影响：</strong> ① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行 <code>add(E e)</code> 方法的时候，<code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1) 。但是如果要在指定位置 i 插入和删除元素的话（ <code>add(int index, E element)</code> ）时间复杂度就为 O(n-i) 。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的 (n-i) 个元素都要执行向后位/向前移一位的操作。 ② <strong><code>LinkedList</code> 采用链表存储，所以对于 <code>add(E e)</code> 方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1) ，如果是要在指定位置 <code>i</code> 插入和删除元素的话（ <code>add(int index, E element)</code> ） 时间复杂度近似为 <code>o(n)</code> 因为需要先移动到指定位置再插入。</strong></p></li><li><p><strong>4. 是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象（对应于 <code>get(int index)</code> 方法）。</p></li><li><p><strong>5. 内存空间占用：</strong> ArrayList 的空间浪费主要体现在在 List 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p></li></ul><h3 id="补充内容：RandomAccess-接口"><a href="#补充内容：RandomAccess-接口" class="headerlink" title="补充内容：RandomAccess 接口"></a><strong>补充内容：RandomAccess 接口</strong></h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RandomAccess</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>查看源码我们发现实际上 <code>RandomAccess</code> 接口中什么都没有定义。所以，在我看来 <code>RandomAccess</code> 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p><p>在 <code>binarySearch()</code> 方法中，它要判断传入的 List 是否 <code>RamdomAccess</code> 的实例，如果是，调用 <code>indexedBinarySearch()</code> 方法，如果不是，那么调用 <code>iteratorBinarySearch()</code> 方法。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span>    <span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">>></span> list<span class="token punctuation">,</span> T key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token keyword">instanceof</span> <span class="token class-name">RandomAccess</span> <span class="token operator">||</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>BINARYSEARCH_THRESHOLD<span class="token punctuation">)</span>            <span class="token keyword">return</span> Collections<span class="token punctuation">.</span><span class="token function">indexedBinarySearch</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> Collections<span class="token punctuation">.</span><span class="token function">iteratorBinarySearch</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口， 而 <code>LinkedList</code> 没有实现。为什么呢？我觉得还是和底层数据结构有关！<code>ArrayList</code> 底层是数组，而 <code>LinkedList</code> 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)，所以不支持快速随机访问。<code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，就表明了他具有快速随机访问功能。 <code>RandomAccess</code> 接口只是标识，并不是说 <code>ArrayList</code> 实现 <code>RandomAccess</code> 接口才具有快速随机访问功能的！</p><p><strong>下面再总结一下 list 的遍历方式选择：</strong></p><ul><li>实现了 <code>RandomAccess</code> 接口的 List，优先选择普通 for 循环 ，其次 for-each 。</li><li>未实现 <code>RandomAccess</code>接口的 List ，优先选择 Iterator 遍历（ for-each 遍历底层也是通过 Iterator 实现的），大 size 的数据，千万不要使用普通 for 循环。</li></ul><h3 id="补充内容：双向链表和双向循环链表"><a href="#补充内容：双向链表和双向循环链表" class="headerlink" title="补充内容：双向链表和双向循环链表"></a>补充内容：双向链表和双向循环链表</h3><p><strong>双向链表：</strong> 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</p><p><img src="https://s1.ax1x.com/2020/04/15/Jp7XdS.png" alt="双向链表"></p><p><strong>双向循环链表：</strong> 最后一个节点的 next 指向 head ，而 head 的 prev 指向最后一个节点，构成一个环。</p><p><img src="https://s1.ax1x.com/2020/04/15/Jp7OZ8.png" alt="双向循环链表"></p><h2 id="ArrayList-与-Vector-区别呢？为什么要用-ArrayList-取代-Vector-呢？"><a href="#ArrayList-与-Vector-区别呢？为什么要用-ArrayList-取代-Vector-呢？" class="headerlink" title="ArrayList 与 Vector 区别呢？为什么要用 ArrayList 取代 Vector 呢？"></a>ArrayList 与 Vector 区别呢？为什么要用 ArrayList 取代 Vector 呢？</h2><p><code>Vector</code> 类的所有方法都是同步的。可以由两个线程安全地访问一个 Vector 对象，但是一个线程访问 Vector 的话代码要在同步操作上耗费大量的时间。</p><p><code>ArrayList</code> 不是同步的，所以在不需要保证线程安全时建议使用 ArrayList 。</p><h2 id="说一说-ArrayList-的扩容机制吧"><a href="#说一说-ArrayList-的扩容机制吧" class="headerlink" title="说一说 ArrayList 的扩容机制吧"></a>说一说 ArrayList 的扩容机制吧</h2><p>详见笔主的这篇文章：<a href="https://wenjunnie.github.io/2020/04/14/hou-duan/ji-he/arraylist-kuo-rong-ji-zhi" target="_blank" rel="noopener">通过源码一步一步分析ArrayList 扩容机制</a></p><h2 id="HashMap-和-HashTable-的区别"><a href="#HashMap-和-HashTable-的区别" class="headerlink" title="HashMap 和 HashTable 的区别"></a>HashMap 和 HashTable 的区别</h2><ol><li><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）。</li><li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它。</li><li><strong>对Null key 和Null value的支持：</strong> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 <strong>NullPointerException</strong>。</li><li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ①创建时如果不指定容量初始值，HashTable 默认的初始大小为 11 ，之后每次扩充，容量变为原来的 2n+1 。HashMap 默认的初始化大小为 16 。之后每次扩充，容量变为原来的 2 倍。②创建时如果给定了容量初始值，那么 HashTable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小（HashMap 中的 <code>tableSizeFor()</code> 方法保证，下面给出了源代码）。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小，后面会介绍到为什么是 2 的幂次方。</li><li><strong>底层数据结构：</strong> JDK 1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8 ）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。HashTable 没有这样的机制。</li></ol><p><strong>HashMap 中带有初始容量的构造函数：</strong></p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span>                                               initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>            initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> Float<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span>                                               loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>下面这个方法保证了 HashMap 总是使用 2 的幂作为哈希表的大小。</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * Returns a power of two size for the given target capacity.     */</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>        n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">;</span>        n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">;</span>        n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">8</span><span class="token punctuation">;</span>        n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span> MAXIMUM_CAPACITY <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h2 id="HashMap-和-HashSet区别"><a href="#HashMap-和-HashSet区别" class="headerlink" title="HashMap 和 HashSet区别"></a>HashMap 和 HashSet区别</h2><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（ HashSet 的源码非常非常少，因为除了 <code>clone()</code> 、<code>writeObject()</code> 、<code>readObject()</code> 是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p><table><thead><tr><th align="center">HashMap</th><th align="center">HashSet</th></tr></thead><tbody><tr><td align="center">实现了Map接口</td><td align="center">实现Set接口</td></tr><tr><td align="center">存储键值对</td><td align="center">仅存储对象</td></tr><tr><td align="center">调用 <code>put()</code>向map中添加元素</td><td align="center">调用 <code>add()</code>方法向Set中添加元素</td></tr><tr><td align="center">HashMap使用键（Key）计算hashCode</td><td align="center">HashSet使用成员对象来计算hashCode值，对于两个对象来说hashCode可能相同，所以<code>equals()</code>方法用来判断对象的相等性，</td></tr></tbody></table><h2 id="HashSet-如何检查重复？"><a href="#HashSet-如何检查重复？" class="headerlink" title="HashSet 如何检查重复？"></a>HashSet 如何检查重复？</h2><p>当你把对象加入 <code>HashSet</code> 时，HashSet 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他加入的对象的 hashCode 值作比较，如果没有相符的 hashCode ，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashCode 值的对象，这时会调用 <code>equals()</code> 方法来检查 hashCode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。（摘自《Head fist java》第二版）</p><p><strong>hashCode() 与equals() 的相关规定：</strong></p><ol><li>如果两个对象相等，则 hashCode 一定也是相同的。</li><li>两个对象相等，<code>equals()</code> 方法返回 true 。</li><li>两个对象有相同的 hashCode 值，它们也不一定是相等的。</li><li>综上，<code>equals()</code> 方法被覆盖过，则 <code>hashCode()</code> 方法也必须被覆盖。</li><li><code>hashCode()</code> 的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code> ，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ol><p><strong>== 与 equals() 的区别</strong></p><ol><li>== 是判断两个变量或实例是不是指向同一个内存空间，<code>equals()</code> 是判断两个变量或实例所指向的内存空间的值是不是相同。</li><li>== 是指对内存地址进行比较，<code>equals()</code> 是对字符串的内容进行比较。</li><li>== 指引用是否相同，<code>equals()</code> 指的是值是否相同。</li></ol><h2 id="HashMap-的底层实现"><a href="#HashMap-的底层实现" class="headerlink" title="HashMap 的底层实现"></a>HashMap 的底层实现</h2><h3 id="JDK-1-8-之前"><a href="#JDK-1-8-之前" class="headerlink" title="JDK 1.8 之前"></a>JDK 1.8 之前</h3><p>JDK 1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过“拉链法”解决冲突。</strong></p><p><strong>所谓扰动函数指的就是 HashMap 的 hash() 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p><p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p><p>JDK 1.8 的 <code>hash()</code> 方法 相比于 JDK 1.7 <code>hash()</code> 方法更加简化，但是原理不变。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> h<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// key.hashCode()：返回散列值也就是hashcode</span>      <span class="token comment" spellcheck="true">// ^ ：按位异或</span>      <span class="token comment" spellcheck="true">// >>>:无符号右移，忽略符号位，空位都以0补齐</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p>对比一下 JDK 1.7 的 HashMap 的 <code>hash()</code> 方法源码。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// This function ensures that hashCodes that differ only by</span>    <span class="token comment" spellcheck="true">// constant multiples at each bit position have a bounded</span>    <span class="token comment" spellcheck="true">// number of collisions (approximately 8 at default load factor).</span>    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>相比于 JDK 1.8 的 <code>hash()</code> 方法 ，JDK 1.7 的 <code>hash()</code> 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p><p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><img src="https://s1.ax1x.com/2020/04/15/J9jQDs.png" alt="jdk 1.8 之前的内部结构 - HashMap"></p><h3 id="JDK-1-8-之后"><a href="#JDK-1-8-之后" class="headerlink" title="JDK 1.8 之后"></a>JDK 1.8 之后</h3><p>相比于之前的版本， JDK 1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8 ）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64 ，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><p><img src="https://s1.ax1x.com/2020/04/15/J9X1fO.md.png" alt="jdk 1.8 之后的内部结构 - HashMap"></p><blockquote><p>TreeMap 、TreeSet 以及 JDK 1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为<strong>二叉查找树在某些情况下会退化成一个线性结构</strong>。</p></blockquote><h3 id="1-7-与-1-8-的主要区别："><a href="#1-7-与-1-8-的主要区别：" class="headerlink" title="1.7 与 1.8 的主要区别："></a>1.7 与 1.8 的主要区别：</h3><ul><li><strong>1. 底层数据结构： 1.7 是数组+链表，1.8 是数组+链表/红黑树；</strong></li><li><strong>2. 发生哈希碰撞时链表插入方式： 1.7 是头插法，1.8 是尾插法，从而在扩容时会保持链表元素原本的顺序，避免循环链表的产生（在 resize 过程中执行 <code>transfer()</code> 方法）；</strong></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">,</span> <span class="token keyword">boolean</span> rehash<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//新table的容量</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//遍历原table</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">:</span> table<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>null <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//保存下一次循环的 Entry&lt;K,V></span>            Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rehash<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//通过e的key值计算e的hash值</span>                e<span class="token punctuation">.</span>hash <span class="token operator">=</span> null <span class="token operator">==</span> e<span class="token punctuation">.</span>key <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//得到e在新table中的插入位置</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//采用链头插入法将e插入i位置，最后得到的链表相对于原table正好是头尾相反的</span>            e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//下一次循环</span>            e <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>推荐阅读：</strong></p><ul><li>《Java 8系列之重新认识HashMap》 ：<a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21673805</a></li></ul><h2 id="HashMap-的长度为什么是2的幂次方？"><a href="#HashMap-的长度为什么是2的幂次方？" class="headerlink" title="HashMap 的长度为什么是2的幂次方？"></a>HashMap 的长度为什么是2的幂次方？</h2><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值 -2147483648 到 2147483647 ，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ <code>(n - 1) &amp; hash</code> ”。（ n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。</p><p><strong>这个算法应该如何设计呢？</strong></p><p>我们首先可能会想到采用 % 取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length == hash&amp;(length-1) 的前提是 length 是 2 的 n 次方）。”</strong> 并且 <strong>采用二进制位操作 &amp; ，相对于 % 能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</strong></p><h2 id="HashMap-多线程操作导致死循环问题"><a href="#HashMap-多线程操作导致死循环问题" class="headerlink" title="HashMap 多线程操作导致死循环问题"></a>HashMap 多线程操作导致死循环问题</h2><p>主要原因在于并发下的 <code>rehash</code> 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap ，因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p><p>详情请查看：<a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9606.html</a></p><h2 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h2><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><strong>底层数据结构：</strong> JDK 1.7 的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK 1.8 采用的数据结构跟 HashMap 1.8 的结构一样，<strong>数组+链表/红黑二叉树</strong>。Hashtable 和 JDK 1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在 JDK 1.7 的时候，ConcurrentHashMap（分段锁）</strong>对整个桶数组进行了分割分段（Segment），每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK 1.8 的时候已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（ JDK 1.6 以后对 synchronized 锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap ，虽然在 JDK 1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong>Hashtable（同一把锁）</strong>：使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 <code>put</code> 添加元素，另一个线程不能使用 <code>put</code> 添加元素，也不能使用 <code>get</code> ，竞争会越来越激烈效率越低。</li></ul><p><strong>两者的对比图：</strong></p><p>图片来源：<a href="http://www.cnblogs.com/chengxiao/p/6842045.html" target="_blank" rel="noopener">http://www.cnblogs.com/chengxiao/p/6842045.html</a></p><p><strong>HashTable ：</strong></p><p><img src="https://s1.ax1x.com/2020/04/15/J9XG1e.md.png" alt="HashTable 全表锁"></p><p><strong>JDK 1.7 的 ConcurrentHashMap ：</strong></p><p><img src="https://s1.ax1x.com/2020/04/15/J9XJ6H.md.png" alt="JDK 1.7 的 ConcurrentHashMap"></p><p><strong>JDK 1.8 的 ConcurrentHashMap（ TreeBin ：红黑二叉树节点  Node ：链表节点）：</strong></p><p><img src="https://s1.ax1x.com/2020/04/15/J9XQk6.md.png" alt="JDK1.8的ConcurrentHashMap"></p><h2 id="ConcurrentHashMap-线程安全的具体实现方式-底层具体实现"><a href="#ConcurrentHashMap-线程安全的具体实现方式-底层具体实现" class="headerlink" title="ConcurrentHashMap 线程安全的具体实现方式/底层具体实现"></a>ConcurrentHashMap 线程安全的具体实现方式/底层具体实现</h2><h3 id="JDK-1-7（上面有示意图）"><a href="#JDK-1-7（上面有示意图）" class="headerlink" title="JDK 1.7（上面有示意图）"></a>JDK 1.7（上面有示意图）</h3><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p><strong>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成</strong>。</p><p>Segment 实现了 ReentrantLock ，所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Segment</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">ReentrantLock</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和 HashMap 类似，是一种<strong>数组和链表</strong>结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个 HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 的锁。</p><h3 id="JDK-1-8-（上面有示意图）"><a href="#JDK-1-8-（上面有示意图）" class="headerlink" title="JDK 1.8 （上面有示意图）"></a>JDK 1.8 （上面有示意图）</h3><p>ConcurrentHashMap 取消了 Segment 分段锁，采用 <strong>CAS</strong> 和 <strong>synchronized</strong> 来保证并发安全。数据结构跟 HashMap 1.8 的结构类似，<strong>数组+链表/红黑树</strong>。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N) ）转换为红黑树（寻址时间复杂度为 O(log(N)) ）</p><p>*<em>synchronized *</em>只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p><h2 id="comparable-和-Comparator的区别"><a href="#comparable-和-Comparator的区别" class="headerlink" title="comparable 和 Comparator的区别"></a>comparable 和 Comparator的区别</h2><ul><li>comparable 接口实际上是出自 java.lang 包 它有一个 <code>compareTo(Object obj)</code> 方法用来排序。</li><li>comparator 接口实际上是出自 java.util 包它有一个 <code>compare(Object obj1, Object obj2)</code> 方法用来排序。</li></ul><p>一般我们需要对一个集合使用自定义排序时，我们就要重写 <code>compareTo()</code> 方法或 <code>compare()</code> 方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写 <code>compareTo()</code> 方法和使用自制的 Comparator 方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 <code>Collections.sort()</code> 。</p><h3 id="Comparator-定制排序"><a href="#Comparator-定制排序" class="headerlink" title="Comparator 定制排序"></a>Comparator 定制排序</h3><pre class=" language-java"><code class="language-java">        ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> arrayList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"原始数组:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// void reverse(List list)：反转</span>        Collections<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Collections.reverse(arrayList):"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// void sort(List list),按自然排序的升序排序</span>        Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Collections.sort(arrayList):"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 定制排序的用法</span>        Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Integer o1<span class="token punctuation">,</span> Integer o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> o2<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>o1<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"定制排序后："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Output：</p><pre class=" language-java"><code class="language-java">原始数组<span class="token operator">:</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">]</span>Collections<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>定制排序后：<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">]</span></code></pre><h3 id="重写-compareTo-方法实现按年龄来排序"><a href="#重写-compareTo-方法实现按年龄来排序" class="headerlink" title="重写 compareTo() 方法实现按年龄来排序"></a>重写 compareTo() 方法实现按年龄来排序</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</span><span class="token comment" spellcheck="true">// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</span><span class="token comment" spellcheck="true">// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>Person<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * TODO重写compareTo方法实现按年龄来排序     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span>Person o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">></span> o<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">&lt;</span> o<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TreeMap<span class="token operator">&lt;</span>Person<span class="token punctuation">,</span> String<span class="token operator">></span> pdata <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token operator">&lt;</span>Person<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pdata<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"zhangsan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pdata<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"lisi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pdata<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"王五"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"wangwu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pdata<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"小红"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"xiaohong"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 得到key的值的同时得到key所对应的值</span>        Set<span class="token operator">&lt;</span>Person<span class="token operator">></span> keys <span class="token operator">=</span> pdata<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Person key <span class="token operator">:</span> keys<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> key<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>Output：</p><pre class=" language-java"><code class="language-java"><span class="token number">5</span><span class="token operator">-</span>小红<span class="token number">10</span><span class="token operator">-</span>王五<span class="token number">20</span><span class="token operator">-</span>李四<span class="token number">30</span><span class="token operator">-</span>张三</code></pre><h2 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h2><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h4 id="1-List"><a href="#1-List" class="headerlink" title="1. List"></a>1. List</h4><ul><li><strong>ArrayList：</strong>Object 数组</li><li><strong>Vector：</strong>Object 数组</li><li><strong>LinkedList：</strong>双向链表（ JDK 1.6 之前为循环链表，JDK 1.7 取消了循环）</li></ul><h4 id="2-Set"><a href="#2-Set" class="headerlink" title="2. Set"></a>2. Set</h4><ul><li><strong>HashSet（无序，唯一）：</strong> 基于 HashMap 实现的，底层采用 HashMap 来保存元素</li><li><strong>LinkedHashSet：</strong> LinkedHashSet 继承于 HashSet ，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的 LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的</li><li><strong>TreeSet（有序，唯一）：</strong> 红黑树（自平衡的排序二叉树）</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li><strong>HashMap：</strong> JDK 1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK 1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8 ）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64 ，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li><li><strong>LinkedHashMap：</strong> LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="https://www.imooc.com/article/22931" target="_blank" rel="noopener">《LinkedHashMap 源码详细分析（JDK1.8）》</a></li><li><strong>Hashtable：</strong> 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li><li><strong>TreeMap：</strong> 红黑树（自平衡的排序二叉树）</li></ul><h2 id="如何选用集合？"><a href="#如何选用集合？" class="headerlink" title="如何选用集合？"></a>如何选用集合？</h2><p>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 Map 接口下的集合，需要排序时选择 <strong>TreeMap</strong> ，不需要排序时就选择 <strong>HashMap</strong> ，需要保证线程安全就选用 <strong>ConcurrentHashMap</strong> 。当我们只需要存放元素值时，就选择实现 Collection 接口的集合，需要保证元素唯一时选择实现 Set 接口的集合比如 <strong>TreeSet</strong> 或 <strong>HashSet</strong> ，不需要就选择实现 List 接口的比如 <strong>ArrayList</strong> 或 <strong>LinkedList</strong> ，然后再根据实现这些接口的集合的特点来选用。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRU算法</title>
      <link href="/2020/04/14/suan-fa/lru-suan-fa/"/>
      <url>/2020/04/14/suan-fa/lru-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="LRU-算法"><a href="#LRU-算法" class="headerlink" title="LRU 算法"></a>LRU 算法</h2><h3 id="LinkedHashMap-实现-LRU"><a href="#LinkedHashMap-实现-LRU" class="headerlink" title="LinkedHashMap 实现 LRU"></a>LinkedHashMap 实现 LRU</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LRUCache</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CACHE_SIZE<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> CACHE_SIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span>CACHE_SIZE <span class="token operator">/</span> <span class="token number">0.75</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.75f</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>CACHE_SIZE <span class="token operator">=</span> CACHE_SIZE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Object<span class="token operator">></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> CACHE_SIZE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LRU算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap</title>
      <link href="/2020/04/14/hou-duan/ji-he/hashmap/"/>
      <url>/2020/04/14/hou-duan/ji-he/hashmap/</url>
      
        <content type="html"><![CDATA[<h2 id="HashMap-简介"><a href="#HashMap-简介" class="headerlink" title="HashMap 简介"></a>HashMap 简介</h2><p>HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一。 </p><p>JDK 1.8 之前 HashMap 由 <strong>数组+链表</strong> 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK 1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8 ）时，将链表转化为<strong>红黑树</strong>（将链表转换成红黑树前会判断，如果当前数组的长度小于 64 ，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间，具体可以参考 <code>treeifyBin()</code> 方法。</p><h2 id="底层数据结构分析"><a href="#底层数据结构分析" class="headerlink" title="底层数据结构分析"></a>底层数据结构分析</h2><h3 id="JDK-1-8-之前"><a href="#JDK-1-8-之前" class="headerlink" title="JDK 1.8 之前"></a>JDK 1.8 之前</h3><p>JDK 1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash  值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p><p><strong>所谓扰动函数指的就是 HashMap 的 <code>hash()</code> 方法。使用 <code>hash()</code> 方法也就是扰动函数是为了防止一些实现比较差的 <code>hashCode()</code> 方法，换句话说使用扰动函数之后可以减少碰撞。</strong></p><p><strong>JDK 1.8 HashMap 的 hash() 方法源码:</strong></p><p>JDK 1.8 的 <code>hash()</code> 方法 相比于 JDK 1.7 <code>hash()</code> 方法更加简化，但是原理不变。</p><pre class=" language-java"><code class="language-java">      <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> h<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// key.hashCode()：返回散列值也就是hashcode</span>        <span class="token comment" spellcheck="true">// ^ ：按位异或</span>        <span class="token comment" spellcheck="true">// >>>:无符号右移，忽略符号位，空位都以0补齐</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>对比一下 JDK 1.7 的 HashMap 的 <code>hash()</code> 方法源码。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// This function ensures that hashCodes that differ only by</span>    <span class="token comment" spellcheck="true">// constant multiples at each bit position have a bounded</span>    <span class="token comment" spellcheck="true">// number of collisions (approximately 8 at default load factor).</span>    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>相比于 JDK 1.8 的 <code>hash()</code> 方法 ，JDK 1.7 的 <code>hash()</code> 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p><p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><img src="https://s1.ax1x.com/2020/04/15/J9jQDs.png" alt="jdk 1.8 之前的内部结构"></p><h3 id="JDK-1-8-之后"><a href="#JDK-1-8-之后" class="headerlink" title="JDK 1.8 之后"></a>JDK 1.8 之后</h3><p>相比于之前的版本， JDK 1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8 ）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64 ，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/67233764.jpg" alt="JDK 1.8 之后的 HashMap 底层数据结构"></p><p><strong>类的属性：</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">,</span> Cloneable<span class="token punctuation">,</span> Serializable <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 序列号</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 362498820763181265L<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 默认的初始容量是16</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 最大容量</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 默认的填充因子</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 当桶(bucket)上的结点数小于这个值时树转链表</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 桶中结构转化为红黑树对应的table的最小大小</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 存储元素的数组，总是2的幂次倍</span>    <span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>k<span class="token punctuation">,</span>v<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 存放具体元素的集</span>    <span class="token keyword">transient</span> Set<span class="token operator">&lt;</span>map<span class="token punctuation">.</span>entry<span class="token operator">&lt;</span>k<span class="token punctuation">,</span>v<span class="token operator">>></span> entrySet<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 存放元素的个数，注意这个不等于数组的长度。</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 每次扩容和更改map结构的计数器</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span>    <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 加载因子</span>    <span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><p><strong>loadFactor 负载因子</strong></p><p>loadFactor 负载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于 1 ，那么数组中存放的数据（entry）也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0 ，数组中存放的数据（entry）也就越少，也就越稀疏。</p><blockquote><p>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值。 </p></blockquote><p>给定的默认容量为 16，负载因子为 0.75 。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 <code>rehash</code> 、复制数据等操作，所以非常消耗性能。</p></li><li><p><strong>threshold</strong></p><p><strong>threshold = capacity * loadFactor</strong> ，<strong>当 size &gt;= threshold **的时候，那么就要考虑对数组扩增了，也就是说，这个的意思就是</strong>衡量数组是否需要扩增的一个标准**。</p></li></ul><p><strong>Node 节点类源码:</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 继承自 Map.Entry&lt;K,V></span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>       <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span>       <span class="token keyword">final</span> K key<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//键</span>       V value<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//值</span>       <span class="token comment" spellcheck="true">// 指向下一个节点</span>       Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>       <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> hash<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> K <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token keyword">return</span> key<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> key <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 重写hashCode()方法</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">^</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">setValue</span><span class="token punctuation">(</span>V newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>            value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 重写 equals() 方法</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span> e <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span>o<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>树节点类源码:</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> parent<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 父</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> left<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 左</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> right<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 右</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> prev<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// needed to unlink next upon deletion</span>        <span class="token keyword">boolean</span> red<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 判断颜色</span>        <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V val<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 返回根节点</span>        <span class="token keyword">final</span> TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> r <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">,</span> p<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> r<span class="token punctuation">.</span>parent<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> r<span class="token punctuation">;</span>                r <span class="token operator">=</span> p<span class="token punctuation">;</span>       <span class="token punctuation">}</span></code></pre><h2 id="HashMap-源码分析"><a href="#HashMap-源码分析" class="headerlink" title="HashMap 源码分析"></a>HashMap 源码分析</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>HashMap 中有四个构造方法，它们分别如下：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 默认构造函数。</span>    <span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// all   other fields defaulted</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// 包含另一个“Map”的构造函数</span>     <span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span>         <span class="token function">putMapEntries</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//下面会分析到这个方法</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// 指定“容量大小”的构造函数</span>     <span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// 指定“容量大小”和“加载因子”的构造函数</span>     <span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>             initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> Float<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span></code></pre><p><strong>putMapEntries 方法：</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">putMapEntries</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> m<span class="token punctuation">,</span> <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 判断table是否已经初始化</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// pre-size</span>            <span class="token comment" spellcheck="true">// 未初始化，s为m的实际元素个数</span>            <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>s <span class="token operator">/</span> loadFactor<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1.0F</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span>                    <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 计算得到的t大于阈值，则初始化阈值</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">></span> threshold<span class="token punctuation">)</span>                threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> threshold<span class="token punctuation">)</span>            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将m中的所有元素添加至HashMap中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> e <span class="token operator">:</span> m<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            K key <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            V value <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> evict<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h3><p>HashMap 只提供了 <code>put</code> 用于添加元素，<code>putVal</code> 方法只是给 <code>put</code> 方法调用的一个方法，并没有提供给用户使用。</p><p><strong>对 putVal 方法添加元素的分析如下：</strong></p><ul><li>①如果定位到的数组位置没有元素就直接插入。</li><li>②如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同就直接覆盖，如果 key 不相同，就判断 p 是否是一个树节点，如果是就调用 <code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code> 将元素添加进入。如果不是就遍历链表插入（插入的是链表尾部）。</li></ul><p>PS：下图有一个小问题，来自 <a href="https://github.com/Snailclimb/JavaGuide/issues/608" target="_blank" rel="noopener">issue#608</a> 指出：直接覆盖之后应该就会 return ，不会有后续操作。参考 JDK 1.8 HashMap.java 658 行。</p><p><img src="https://s1.ax1x.com/2020/04/16/JiIBxs.md.png" alt="put 方法"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// table未初始化或者长度为0，进行扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 桶中已经存在元素</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 将第一个元素赋值给e，用e来记录</span>                e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// hash值不相等，即key不相等；为红黑树结点</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 放入树中</span>            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 为链表结点</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在链表最末插入结点</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 到达链表的尾部</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 在尾部插入新结点</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 结点数量达到阈值，转化为红黑树</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 判断链表中结点的key值与插入的元素的key值是否相等</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">// 相等，跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 表示在桶中找到key值、hash值与插入元素相等的结点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">// 记录e的value</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// onlyIfAbsent为false或者旧值为null</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//用新值替换旧值</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 访问后回调</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 返回旧值</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 结构性修改</span>    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 实际大小大于阈值则扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 插入后回调</span>    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span> </code></pre><p><strong>我们再来对比一下 JDK 1.7 put 方法的代码</strong></p><p><strong>对于 put 方法的分析如下：</strong></p><ul><li>①如果定位到的数组位置没有元素 就直接插入。</li><li>②如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的 key 比较，如果 key 相同就直接覆盖，不同就采用头插法插入元素。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> EMPTY_TABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">inflateTable</span><span class="token punctuation">(</span>threshold<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 先遍历</span>        Object k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>         <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 再插入</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span> null <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 数组元素相等</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token comment" spellcheck="true">// always check first node</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> first<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 桶中不止一个节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在树中get</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 在链表中get</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize 方法"></a>resize 方法</h3><p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 <code>resize</code> 。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>            threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 没超过最大值，就扩充为原来的2倍</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// double threshold</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// initial capacity was placed in threshold</span>        newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// signifies using defaults</span>        newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 计算新的resize上限</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 把每个bucket都移动到新的buckets中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span>                     Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>                    <span class="token keyword">do</span> <span class="token punctuation">{</span>                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 原索引</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">// 原索引+oldCap</span>                        <span class="token keyword">else</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 原索引放到bucket里</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// 原索引+oldCap放到bucket里</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="HashMap-常用方法测试"><a href="#HashMap-常用方法测试" class="headerlink" title="HashMap 常用方法测试"></a>HashMap 常用方法测试</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Collection<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Set<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMapDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 键不能重复，值可以重复</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"san"</span><span class="token punctuation">,</span> <span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"si"</span><span class="token punctuation">,</span> <span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"wu"</span><span class="token punctuation">,</span> <span class="token string">"王五"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"wang"</span><span class="token punctuation">,</span> <span class="token string">"老王"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"wang"</span><span class="token punctuation">,</span> <span class="token string">"老王2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 老王被覆盖</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"lao"</span><span class="token punctuation">,</span> <span class="token string">"老王"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-------直接输出hashmap:-------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * 遍历HashMap         */</span>        <span class="token comment" spellcheck="true">// 1.获取Map中的所有键</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-------foreach获取Map中所有的键:------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> keys <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String key <span class="token operator">:</span> keys<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>key<span class="token operator">+</span><span class="token string">"  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//换行</span>        <span class="token comment" spellcheck="true">// 2.获取Map中所有值</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-------foreach获取Map中所有的值:------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Collection<span class="token operator">&lt;</span>String<span class="token operator">></span> values <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String value <span class="token operator">:</span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>value<span class="token operator">+</span><span class="token string">"  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//换行</span>        <span class="token comment" spellcheck="true">// 3.得到key的值的同时得到key所对应的值</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-------得到key的值的同时得到key所对应的值:-------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> keys2 <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String key <span class="token operator">:</span> keys2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">"："</span> <span class="token operator">+</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"   "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/**         * 如果既要遍历key又要value，那么建议这种方式，应为如果先获取keySet然后再执行map.get(key)，map内部会执行两次遍历。         * 一次是在获取keySet的时候，一次是在遍历所有key的时候。         */</span>        <span class="token comment" spellcheck="true">// 当我调用put(key,value)方法的时候，首先会把key和value封装到</span>        <span class="token comment" spellcheck="true">// Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取</span>        <span class="token comment" spellcheck="true">// map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来</span>        <span class="token comment" spellcheck="true">// 调用Entry对象中的getKey()和getValue()方法就能获取键值对了</span>        Set<span class="token operator">&lt;</span>java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">>></span> entrys <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> entry <span class="token operator">:</span> entrys<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"--"</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/**         * HashMap其他常用方法         */</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.size()："</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.isEmpty()："</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"san"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.remove()："</span><span class="token operator">+</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.get(si)："</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"si"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.containsKey(si)："</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token string">"si"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after containsValue(李四)："</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">containsValue</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"si"</span><span class="token punctuation">,</span> <span class="token string">"李四2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after map.replace(si, 李四2):"</span><span class="token operator">+</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>直接输出hashmap<span class="token operator">:</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token punctuation">{</span>san<span class="token operator">=</span>张三<span class="token punctuation">,</span> wang<span class="token operator">=</span>老王<span class="token number">2</span><span class="token punctuation">,</span> si<span class="token operator">=</span>李四<span class="token punctuation">,</span> lao<span class="token operator">=</span>老王<span class="token punctuation">,</span> wu<span class="token operator">=</span>王五<span class="token punctuation">}</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>foreach获取Map中所有的键<span class="token operator">:</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>san  wang  si  lao  wu  <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>foreach获取Map中所有的值<span class="token operator">:</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>张三  老王<span class="token number">2</span>  李四  老王  王五  <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>得到key的值的同时得到key所对应的值<span class="token operator">:</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>san：张三   wang：老王<span class="token number">2</span>   si：李四   lao：老王   wu：王五   san<span class="token operator">--</span>张三wang<span class="token operator">--</span>老王<span class="token number">2</span>si<span class="token operator">--</span>李四lao<span class="token operator">--</span>老王wu<span class="token operator">--</span>王五after map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：<span class="token number">5</span>after map<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：<span class="token boolean">false</span>张三after map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：<span class="token punctuation">{</span>wang<span class="token operator">=</span>老王<span class="token number">2</span><span class="token punctuation">,</span> si<span class="token operator">=</span>李四<span class="token punctuation">,</span> lao<span class="token operator">=</span>老王<span class="token punctuation">,</span> wu<span class="token operator">=</span>王五<span class="token punctuation">}</span>after map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>si<span class="token punctuation">)</span>：李四after map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>si<span class="token punctuation">)</span>：<span class="token boolean">true</span>after <span class="token function">containsValue</span><span class="token punctuation">(</span>李四<span class="token punctuation">)</span>：<span class="token boolean">true</span>李四after map<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>si<span class="token punctuation">,</span> 李四<span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">{</span>wang<span class="token operator">=</span>老王<span class="token number">2</span><span class="token punctuation">,</span> si<span class="token operator">=</span>李四<span class="token number">2</span><span class="token punctuation">,</span> lao<span class="token operator">=</span>老王<span class="token punctuation">,</span> wu<span class="token operator">=</span>王五<span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedList</title>
      <link href="/2020/04/14/hou-duan/ji-he/linkedlist/"/>
      <url>/2020/04/14/hou-duan/ji-he/linkedlist/</url>
      
        <content type="html"><![CDATA[<h2 id="LinkedList简介"><a href="#LinkedList简介" class="headerlink" title="LinkedList简介"></a><font face="楷体" id="1">LinkedList简介</font></h2><p><font color="red">LinkedList</font> 是一个实现了<font color="red"> List 接口</font>和<font color="red"> Deque 接口</font>的<font color="red">双端链表</font>。<br>LinkedList 底层的链表结构使它<font color="red">支持高效的插入和删除操作</font>，另外它实现了 Deque 接口，使得 LinkedList 类也具有队列的特性。<br>LinkedList <font color="red">不是线程安全的</font>，如果想使 LinkedList 变成线程安全的，可以调用静态类 <font color="red">Collections 类</font>中的 <font color="red">synchronizedList</font> 方法： </p><pre class=" language-java"><code class="language-java">List list<span class="token operator">=</span>Collections<span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="内部结构分析"><a href="#内部结构分析" class="headerlink" title="内部结构分析"></a><font face="楷体" id="2">内部结构分析</font></h2><p><strong>如下图所示：</strong><br><img src="https://s1.ax1x.com/2020/04/14/Gzu661.jpg" alt="LinkedList内部结构"><br>看完了图之后，我们再看 LinkedList 类中的一个<font color="red"><strong>内部私有类 Node</strong></font> 就很好理解了：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>        E item<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//节点值</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//后继节点</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//前驱节点</span>        <span class="token function">Node</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev<span class="token punctuation">,</span> E element<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>这个类就代表双端链表的节点 Node 。这个类有三个属性，分别是前驱节点，本节点的值，后继结点。</p><h2 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a><font face="楷体" id="3">LinkedList源码分析</font></h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><font face="楷体" id="3.1">构造方法</font></h3><p><strong>空构造方法：</strong></p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token function">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span></code></pre><p><strong>用已有的集合创建链表的构造方法：</strong></p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token function">LinkedList</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addAll</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a><font face="楷体" id="3.2">add方法</font></h3><p><strong>add(E e) ：将元素添加到链表尾部</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">linkLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里就只调用了这一个方法</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">   <span class="token comment" spellcheck="true">/**     * 链接使e作为最后一个元素。     */</span>    <span class="token keyword">void</span> <span class="token function">linkLast</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> e<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        last <span class="token operator">=</span> newNode<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//新建节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> null<span class="token punctuation">)</span>            first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token keyword">else</span>            l<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指向后继元素也就是指向下一个元素</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>add(int index,E e)：在指定位置添加元素</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">checkPositionIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//检查索引是否处于[0-size]之间</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> size<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//添加在链表尾部</span>            <span class="token function">linkLast</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span><span class="token comment" spellcheck="true">//添加在链表中间</span>            <span class="token function">linkBefore</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><font color="red">linkBefore 方法</font>需要给定两个参数，一个<font color="red">插入节点的值</font>，一个<font color="red">指定的 node</font> ，所以我们又调用了 <font color="red">Node(index)</font> 去找到 index 对应的 node 。</p><p><strong>addAll(Collection  c )：将集合插入到链表尾部</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">addAll</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>addAll(int index, Collection c)： 将集合从指定位置开始插入</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//1:检查index范围是否在size之内</span>        <span class="token function">checkPositionIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//2:toArray()方法把集合的数据存到对象数组中</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numNew <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numNew <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//3：得到插入位置的前驱节点和后继节点</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> pred<span class="token punctuation">,</span> succ<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果插入位置为尾部，前驱节点为last，后继节点为null</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>            succ <span class="token operator">=</span> null<span class="token punctuation">;</span>            pred <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//否则，调用node()方法得到后继节点，再得到前驱节点</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            succ <span class="token operator">=</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>            pred <span class="token operator">=</span> succ<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 4：遍历数据将数据插入</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Object o <span class="token operator">:</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span> E e <span class="token operator">=</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> o<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//创建新节点</span>            Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> e<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//如果插入位置在链表头部</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">==</span> null<span class="token punctuation">)</span>                first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>            <span class="token keyword">else</span>                pred<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>            pred <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//如果插入位置在尾部，重置last节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>succ <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            last <span class="token operator">=</span> pred<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//否则，将插入的链表与先前链表连接起来</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> succ<span class="token punctuation">;</span>            succ<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        size <span class="token operator">+=</span> numNew<span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    </code></pre><p>上面可以看出 <code>addAll()</code> 方法通常包括下面四个步骤：</p><ol><li>检查 index 范围是否在 size 之内。</li><li><code>toArray()</code> 方法把集合的数据存到对象数组中。</li><li>得到插入位置的前驱和后继节点。</li><li>遍历数据，将数据插入到指定位置。</li></ol><p><strong>addFirst(E e)： 将元素添加到链表头部</strong></p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addFirst</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">linkFirst</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">linkFirst</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> e<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//新建节点，以头节点为后继节点</span>        first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果链表为空，last节点也指向该节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> null<span class="token punctuation">)</span>            last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//否则，将头节点的前驱指针指向新节点，也就是指向前一个元素</span>        <span class="token keyword">else</span>            f<span class="token punctuation">.</span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>addLast(E e)： 将元素添加到链表尾部，与 <code>add(E e)</code> 方法一样</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addLast</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">linkLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="根据位置取数据的方法"><a href="#根据位置取数据的方法" class="headerlink" title="根据位置取数据的方法"></a><font face="楷体" id="3.3">根据位置取数据的方法</font></h3><p><strong>get(int index)： 根据指定索引返回数据</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//检查index范围是否在size之内</span>        <span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//调用Node(index)去找到index对应的node然后返回它的值</span>        <span class="token keyword">return</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>获取头节点（index=0）数据方法:</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> f<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">public</span> E <span class="token function">element</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">public</span> E <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> null <span class="token operator">:</span> f<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">public</span> E <span class="token function">peekFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> null <span class="token operator">:</span> f<span class="token punctuation">.</span>item<span class="token punctuation">;</span>     <span class="token punctuation">}</span></code></pre><p><strong>区别：</strong></p><blockquote><p>getFirst()，element()，peek()，peekFirst()</p></blockquote><p>这四个获取头结点方法的区别在于对链表为空时的处理，是抛出异常还是返回 null ，其中 <code>getFirst()</code> 和<code>element()</code> 方法将会在链表为空时，抛出异常。</p><p><code>element()</code> 方法的内部就是使用 <code>getFirst()</code> 实现的。它们会在链表为空时，抛出<strong>NoSuchElementException</strong>。<br><strong>获取尾节点（index=-1）数据方法:</strong></p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> E <span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> l<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">public</span> E <span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> null <span class="token operator">:</span> l<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>两者区别：</strong><br><code>getLast()</code> 方法在链表为空时，会抛出 <strong>NoSuchElementException</strong> ，而 <code>peekLast()</code> 则不会，只是会返回 <strong>null</strong> 。</p><h3 id="根据对象得到索引的方法"><a href="#根据对象得到索引的方法" class="headerlink" title="根据对象得到索引的方法"></a><font face="楷体" id="3.4">根据对象得到索引的方法</font></h3><p><strong>int indexOf(Object o)： 从头遍历找</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//从头遍历</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>item <span class="token operator">==</span> null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> index<span class="token punctuation">;</span>                index<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//从头遍历</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> index<span class="token punctuation">;</span>                index<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>int lastIndexOf(Object o)： 从尾遍历找</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lastIndexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> size<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//从尾遍历</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">)</span> <span class="token punctuation">{</span>                index<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>item <span class="token operator">==</span> null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> index<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//从尾遍历</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">)</span> <span class="token punctuation">{</span>                index<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> index<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="检查链表是否包含某对象的方法："><a href="#检查链表是否包含某对象的方法：" class="headerlink" title="检查链表是否包含某对象的方法："></a><font face="楷体" id="3.5">检查链表是否包含某对象的方法：</font></h3><p><strong>contains(Object o)： 检查对象o是否存在于链表中</strong></p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a><font face="楷体" id="3.6">删除方法</font></h3><p><strong>remove() ,removeFirst() ,pop(): 删除头节点</strong></p><pre><code>public E pop() {        return removeFirst();    }public E remove() {        return removeFirst();    }public E removeFirst() {        final Node&lt;E&gt; f = first;        if (f == null)            throw new NoSuchElementException();        return unlinkFirst(f);    }</code></pre><p><strong>removeLast(), pollLast(): 删除尾节点</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">unlinkLast</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">public</span> E <span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> null <span class="token operator">:</span> <span class="token function">unlinkLast</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>区别：</strong> <code>removeLast()</code> 在链表为空时将抛出 <strong>NoSuchElementException</strong> ，而 <code>pollLast()</code> 方法返回 <strong>null</strong> 。</p><p><strong>remove(Object o): 删除指定元素</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//如果删除对象为null</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//从头开始遍历</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//找到元素</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>item <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token comment" spellcheck="true">//从链表中移除找到的元素</span>                    <span class="token function">unlink</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//从头开始遍历</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> null<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//找到元素</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//从链表中移除找到的元素</span>                    <span class="token function">unlink</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>当删除指定对象时，只需调用 <code>remove(Object o)</code> 即可，不过该方法一次只会删除一个匹配的对象，如果删除了匹配对象，返回 true ，否则 false 。</p><p><strong>unlink(Node<E> x) 方法：</strong></p><pre class=" language-java"><code class="language-java">E <span class="token function">unlink</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// assert x != null;</span>        <span class="token keyword">final</span> E element <span class="token operator">=</span> x<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//得到后继节点</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//得到前驱节点</span>        <span class="token comment" spellcheck="true">//删除前驱指针</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            first <span class="token operator">=</span> next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果删除的节点是头节点,令头节点指向该节点的后继节点</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            prev<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将前驱节点的后继节点指向后继节点</span>            x<span class="token punctuation">.</span>prev <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//删除后继指针</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            last <span class="token operator">=</span> prev<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            next<span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>            x<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        x<span class="token punctuation">.</span>item <span class="token operator">=</span> null<span class="token punctuation">;</span>        size<span class="token operator">--</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> element<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>remove(int index)：删除指定位置的元素</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//检查index范围</span>        <span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将节点删除</span>        <span class="token keyword">return</span> <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h2 id="LinkedList类常用方法测试"><a href="#LinkedList类常用方法测试" class="headerlink" title="LinkedList类常用方法测试"></a><font face="楷体" id="4">LinkedList类常用方法测试</font></h2><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Iterator<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>LinkedList<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedListDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> srgs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建存放int类型的linkedList</span>        LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> linkedList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/************************** linkedList的基本操作 ************************/</span>        linkedList<span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 添加元素到列表开头</span>        linkedList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 在列表结尾添加元素</span>        linkedList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 在指定位置添加元素</span>        linkedList<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 添加元素到列表结尾</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"LinkedList（直接输出的）: "</span> <span class="token operator">+</span> linkedList<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getFirst()获得第一个元素: "</span> <span class="token operator">+</span> linkedList<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回此列表的第一个元素</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getLast()获得第最后一个元素: "</span> <span class="token operator">+</span> linkedList<span class="token punctuation">.</span><span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回此列表的最后一个元素</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"removeFirst()删除第一个元素并返回: "</span> <span class="token operator">+</span> linkedList<span class="token punctuation">.</span><span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 移除并返回此列表的第一个元素</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"removeLast()删除最后一个元素并返回: "</span> <span class="token operator">+</span> linkedList<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 移除并返回此列表的最后一个元素</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"After remove:"</span> <span class="token operator">+</span> linkedList<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"contains()方法判断列表是否包含1这个元素:"</span> <span class="token operator">+</span> linkedList<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 判断此列表包含指定元素，如果是，则返回true</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"该linkedList的大小 : "</span> <span class="token operator">+</span> linkedList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回此列表的元素个数</span>        <span class="token comment" spellcheck="true">/************************** 位置访问操作 ************************/</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-----------------------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        linkedList<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将此列表中指定位置的元素替换为指定的元素</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"After set(1, 3):"</span> <span class="token operator">+</span> linkedList<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"get(1)获得指定位置（这里为1）的元素: "</span> <span class="token operator">+</span> linkedList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回此列表中指定位置处的元素</span>        <span class="token comment" spellcheck="true">/************************** Search操作 ************************/</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-----------------------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        linkedList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"indexOf(3): "</span> <span class="token operator">+</span> linkedList<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回此列表中首次出现的指定元素的索引</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"lastIndexOf(3): "</span> <span class="token operator">+</span> linkedList<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 返回此列表中最后出现的指定元素的索引</span>        <span class="token comment" spellcheck="true">/************************** Queue操作 ************************/</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-----------------------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"peek(): "</span> <span class="token operator">+</span> linkedList<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取但不移除此列表的头</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"element(): "</span> <span class="token operator">+</span> linkedList<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取但不移除此列表的头</span>        linkedList<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取并移除此列表的头</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"After poll():"</span> <span class="token operator">+</span> linkedList<span class="token punctuation">)</span><span class="token punctuation">;</span>        linkedList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"After remove():"</span> <span class="token operator">+</span> linkedList<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取并移除此列表的头</span>        linkedList<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"After offer(4):"</span> <span class="token operator">+</span> linkedList<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将指定元素添加到此列表的末尾</span>        <span class="token comment" spellcheck="true">/************************** Deque操作 ************************/</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-----------------------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        linkedList<span class="token punctuation">.</span><span class="token function">offerFirst</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 在此列表的开头插入指定的元素</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"After offerFirst(2):"</span> <span class="token operator">+</span> linkedList<span class="token punctuation">)</span><span class="token punctuation">;</span>        linkedList<span class="token punctuation">.</span><span class="token function">offerLast</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 在此列表末尾插入指定的元素</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"After offerLast(5):"</span> <span class="token operator">+</span> linkedList<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"peekFirst(): "</span> <span class="token operator">+</span> linkedList<span class="token punctuation">.</span><span class="token function">peekFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取但不移除此列表的第一个元素</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"peekLast(): "</span> <span class="token operator">+</span> linkedList<span class="token punctuation">.</span><span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取但不移除此列表的第一个元素</span>        linkedList<span class="token punctuation">.</span><span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取并移除此列表的第一个元素</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"After pollFirst():"</span> <span class="token operator">+</span> linkedList<span class="token punctuation">)</span><span class="token punctuation">;</span>        linkedList<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取并移除此列表的最后一个元素</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"After pollLast():"</span> <span class="token operator">+</span> linkedList<span class="token punctuation">)</span><span class="token punctuation">;</span>        linkedList<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将元素推入此列表所表示的堆栈（插入到列表的头）</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"After push(2):"</span> <span class="token operator">+</span> linkedList<span class="token punctuation">)</span><span class="token punctuation">;</span>        linkedList<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从此列表所表示的堆栈处弹出一个元素（获取并移除列表第一个元素）</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"After pop():"</span> <span class="token operator">+</span> linkedList<span class="token punctuation">)</span><span class="token punctuation">;</span>        linkedList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        linkedList<span class="token punctuation">.</span><span class="token function">removeFirstOccurrence</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表）</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"After removeFirstOccurrence(3):"</span> <span class="token operator">+</span> linkedList<span class="token punctuation">)</span><span class="token punctuation">;</span>        linkedList<span class="token punctuation">.</span><span class="token function">removeLastOccurrence</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从此列表中移除最后一次出现的指定元素（从尾部到头部遍历列表）</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"After removeFirstOccurrence(3):"</span> <span class="token operator">+</span> linkedList<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/************************** 遍历操作 ************************/</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-----------------------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        linkedList<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            linkedList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 迭代器遍历</span>        <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Iterator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> iterator <span class="token operator">=</span> linkedList<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">long</span> end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Iterator："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 顺序遍历(随机遍历)</span>        start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> linkedList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            linkedList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"for："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 另一种for循环遍历</span>        start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Integer i <span class="token operator">:</span> linkedList<span class="token punctuation">)</span>            <span class="token punctuation">;</span>        end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"for2："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 通过pollFirst()或pollLast()来遍历LinkedList</span>        LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> temp1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        temp1<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>linkedList<span class="token punctuation">)</span><span class="token punctuation">;</span>        start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>temp1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            temp1<span class="token punctuation">.</span><span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"pollFirst()或pollLast()："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 通过removeFirst()或removeLast()来遍历LinkedList</span>        LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> temp2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        temp2<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>linkedList<span class="token punctuation">)</span><span class="token punctuation">;</span>        start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>temp2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            temp2<span class="token punctuation">.</span><span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"removeFirst()或removeLast()："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">LinkedList（直接输出的）<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span>获得第一个元素<span class="token operator">:</span> <span class="token number">0</span><span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span>获得第最后一个元素<span class="token operator">:</span> <span class="token number">3</span><span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span>删除第一个元素并返回<span class="token operator">:</span> <span class="token number">0</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span>删除最后一个元素并返回<span class="token operator">:</span> <span class="token number">3</span>After remove<span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法判断列表是否包含<span class="token number">1</span>这个元素<span class="token operator">:</span><span class="token boolean">true</span>该linkedList的大小 <span class="token operator">:</span> <span class="token number">2</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>After <span class="token function">set</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>获得指定位置（这里为<span class="token number">1</span>）的元素<span class="token operator">:</span> <span class="token number">3</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token number">1</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token number">2</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token number">1</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token number">1</span>After <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>After <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>After <span class="token function">offer</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>After <span class="token function">offerFirst</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>After <span class="token function">offerLast</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token function">peekFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token number">2</span><span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token number">5</span>After <span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>After <span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>After <span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>After <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>After <span class="token function">removeFirstOccurrence</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>After <span class="token function">removeFirstOccurrence</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>Iterator：<span class="token number">13</span> ms<span class="token keyword">for</span>：<span class="token number">5540</span> msfor2：<span class="token number">2</span> ms<span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span>或<span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：<span class="token number">4</span> ms<span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span>或<span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：<span class="token number">4</span> ms</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList扩容机制</title>
      <link href="/2020/04/14/hou-duan/ji-he/arraylist-kuo-rong-ji-zhi/"/>
      <url>/2020/04/14/hou-duan/ji-he/arraylist-kuo-rong-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayList-扩容机制"><a href="#ArrayList-扩容机制" class="headerlink" title="ArrayList 扩容机制"></a>ArrayList 扩容机制</h1><h2 id="一-先从-ArrayList-的构造函数说起"><a href="#一-先从-ArrayList-的构造函数说起" class="headerlink" title="一 先从 ArrayList 的构造函数说起"></a>一 先从 ArrayList 的构造函数说起</h2><p><strong>ArrayList 有三种方式来初始化，构造方法源码如下：</strong></p><pre class=" language-java"><code class="language-java">   <span class="token comment" spellcheck="true">/**     * 默认初始容量大小     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_CAPACITY <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     *默认构造函数，使用初始容量10构造一个空列表(无参数构造)     */</span>    <span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 带初始容量参数的构造函数。（用户自己指定容量）     */</span>    <span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//初始容量大于0</span>            <span class="token comment" spellcheck="true">//创建initialCapacity大小的数组</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//初始容量等于0</span>            <span class="token comment" spellcheck="true">//创建空数组</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//初始容量小于0，抛出异常</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal Capacity: "</span><span class="token operator">+</span>                                               initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">/**    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回    *如果指定的集合为null，throws NullPointerException。     */</span>     <span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        elementData <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>                elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// replace with empty array.</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>细心的同学一定会发现 ：<strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10 。</strong> 下面在我们分析 ArrayList 扩容时会讲到这一点内容！</p><h2 id="二-一步一步分析-ArrayList-扩容机制"><a href="#二-一步一步分析-ArrayList-扩容机制" class="headerlink" title="二 一步一步分析 ArrayList 扩容机制"></a>二 一步一步分析 ArrayList 扩容机制</h2><p>这里以无参构造函数创建的 ArrayList 为例分析。</p><h3 id="1-先来看-add-方法"><a href="#1-先来看-add-方法" class="headerlink" title="1. 先来看 add 方法"></a>1. 先来看 <code>add</code> 方法</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 将指定的元素追加到此列表的末尾。      */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//添加元素之前，先调用ensureCapacityInternal方法</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>        <span class="token comment" spellcheck="true">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span>        elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="2-再来看看-ensureCapacityInternal-方法"><a href="#2-再来看看-ensureCapacityInternal-方法" class="headerlink" title="2. 再来看看 ensureCapacityInternal() 方法"></a>2. 再来看看 <code>ensureCapacityInternal()</code> 方法</h3><p>可以看到 <code>add</code> 方法首先调用了 <code>ensureCapacityInternal(size + 1)</code> 。</p><pre class=" language-java"><code class="language-java">   <span class="token comment" spellcheck="true">//得到最小扩容量</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token function">calculateCapacity</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">calculateCapacity</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">,</span> <span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//获取默认的容量和传入参数的较大值</span>            <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> minCapacity<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>当要 add 进第1个元素时，minCapacity 为1，在 Math.max() 方法比较后，minCapacity 为10。</strong></p><h3 id="3-ensureExplicitCapacity-方法"><a href="#3-ensureExplicitCapacity-方法" class="headerlink" title="3. ensureExplicitCapacity() 方法"></a>3. <code>ensureExplicitCapacity()</code> 方法</h3><p>如果调用 <code>ensureCapacityInternal()</code> 方法就一定会进过（执行）这个方法，下面我们来研究一下这个方法的源码！</p><pre class=" language-java"><code class="language-java">  <span class="token comment" spellcheck="true">//判断是否需要扩容</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// overflow-conscious code</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span>            <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>我们来仔细分析一下：</p><ul><li>当我们要 add 进第1个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list ），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为10。此时，<code>minCapacity - elementData.length &gt; 0</code> 成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li><li>当 add 第 2 个元素时，minCapacity 为2，此时 elementData.length（容量）在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li><li>添加第 3 、4 ··· 到第 10 个元素时，依然不会执行 <code>grow()</code> 方法，数组容量都为 10 。</li></ul><p>直到添加第 11 个元素，minCapacity(为 11 ) 比 elementData.length(为 10 )要大。进入 <code>grow</code> 方法进行扩容。</p><h3 id="4-grow-方法"><a href="#4-grow-方法" class="headerlink" title="4. grow() 方法"></a>4. <code>grow()</code> 方法</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 要分配的最大数组大小     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_ARRAY_SIZE <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * ArrayList扩容的核心方法。     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//oldCapacity为旧容量，newCapacity为新容量</span>        <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将oldCapacity右移一位，其效果相当于`oldCapacity / 2`，</span>        <span class="token comment" spellcheck="true">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span>        <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span>       <span class="token comment" spellcheck="true">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// minCapacity is usually close to size, so this is a win:</span>        elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)，所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（ oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如 ：10+10/2 = 15，33+33/2=49 。如果是奇数的话会丢掉小数。</p><blockquote><p>  “&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除 2 ，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity / 2 。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很，因为程序仅仅移动一下而已，不去计算，这样提高了效率，节省了资源 。</p></blockquote><p><strong>我们再来通过例子探究一下 <code>grow()</code> 方法 ：</strong></p><ul><li>当 add 第1个元素时，oldCapacity 为 0 ，经比较后第一个 if 判断成立，newCapacity = minCapacity(为 10 )。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10 ，<code>add()</code> 方法中 return true ，size 增为 1 。</li><li>当 add 第 11 个元素进入 <code>grow()</code> 方法时，newCapacity 为 15 ，比 minCapacity(为 11 )大，第一个 if 判断不成立。新容量没有大于数组最大 size ，不会进入 <code>hugeCapacity</code> 方法。数组容量扩为 15 ，<code>add()</code> 方法中return true ，size 增为 11 。</li><li>以此类推······</li></ul><p><strong>这里补充一点比较重要，但是容易被忽视掉的知识点：</strong></p><ul><li>Java 中的 <code>length</code> 属性是针对数组说的，比如说你声明了一个数组，想知道这个数组的长度则用到了 <code>length</code> 这个属性。</li><li>Java 中的 <code>length()</code> 方法是针对字符串说的，如果想看这个字符串的长度则用到 <code>length()</code> 这个方法。</li><li>Java 中的 <code>size()</code> 方法是针对泛型集合说的，如果想看这个泛型有多少个元素，就调用此方法来查看！</li></ul><h3 id="5-hugeCapacity-方法。"><a href="#5-hugeCapacity-方法。" class="headerlink" title="5. hugeCapacity() 方法。"></a>5. <code>hugeCapacity()</code> 方法。</h3><p>从上面 <code>grow()</code> 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE ，进入（执行）<code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE ，如果 minCapacity 大于最大容量，则新容量为 <code>Integer.MAX_VALUE</code> ，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code> 。 </p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// overflow</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//对minCapacity和MAX_ARRAY_SIZE进行比较</span>        <span class="token comment" spellcheck="true">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span>        <span class="token comment" spellcheck="true">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span>        <span class="token comment" spellcheck="true">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> MAX_ARRAY_SIZE<span class="token punctuation">)</span> <span class="token operator">?</span>            Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span>            MAX_ARRAY_SIZE<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h2 id="三-System-arraycopy-和-Arrays-copyOf-方法"><a href="#三-System-arraycopy-和-Arrays-copyOf-方法" class="headerlink" title="三 System.arraycopy() 和 Arrays.copyOf() 方法"></a>三 <code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code> 方法</h2><p>阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及 <code>add(int index, E element)</code> 、<code>toArray()</code>  等方法中都用到了该方法！</p><h3 id="3-1-System-arraycopy-方法"><a href="#3-1-System-arraycopy-方法" class="headerlink" title="3.1 System.arraycopy() 方法"></a>3.1 <code>System.arraycopy()</code> 方法</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 在此列表中的指定位置插入指定的元素。      *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>        <span class="token comment" spellcheck="true">//arraycopy()方法实现数组自己复制自己</span>        <span class="token comment" spellcheck="true">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> size <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>我们写一个简单的方法测试一下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArraycopyTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">99</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结果：</p><pre class=" language-java"><code class="language-java"><span class="token number">0</span> <span class="token number">1</span> <span class="token number">99</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> </code></pre><h3 id="3-2-Arrays-copyOf-方法"><a href="#3-2-Arrays-copyOf-方法" class="headerlink" title="3.2 Arrays.copyOf() 方法"></a>3.2 <code>Arrays.copyOf()</code> 方法</h3><pre class=" language-java"><code class="language-java">   <span class="token comment" spellcheck="true">/**     以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。      */</span>    <span class="token keyword">public</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//elementData：要复制的数组；size：要复制的长度</span>        <span class="token keyword">return</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>个人觉得使用 <code>Arrays.copyOf()</code> 方法主要是为了给原有数组扩容，测试代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayscopyOfTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"b.length"</span><span class="token operator">+</span>b<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结果：</p><pre class=" language-java"><code class="language-java"><span class="token number">10</span></code></pre><h3 id="3-3-两者联系和区别"><a href="#3-3-两者联系和区别" class="headerlink" title="3.3 两者联系和区别"></a>3.3 两者联系和区别</h3><p><strong>联系：</strong> </p><p>看两者源代码可以发现 <code>copyOf()</code> 内部实际调用了 <code>System.arraycopy()</code> 方法 。</p><p><strong>区别：</strong></p><p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p><h2 id="四-ensureCapacity-方法"><a href="#四-ensureCapacity-方法" class="headerlink" title="四 ensureCapacity() 方法"></a>四 <code>ensureCapacity()</code> 方法</h2><p>ArrayList 源码中有一个 <code>ensureCapacity</code> 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**    如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。     *     * @param   minCapacity   所需的最小容量     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ensureCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> minExpand <span class="token operator">=</span> <span class="token punctuation">(</span>elementData <span class="token operator">!=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// any size if not default element table</span>            <span class="token operator">?</span> <span class="token number">0</span>            <span class="token comment" spellcheck="true">// larger than default for default empty table. It's already</span>            <span class="token comment" spellcheck="true">// supposed to be at default size.</span>            <span class="token operator">:</span> DEFAULT_CAPACITY<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> minExpand<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p><strong>最好在 add 大量元素之前用 <code>ensureCapacity</code> 方法，以减少增量重新分配的次数。</strong></p><p>我们通过下面的代码实际测试以下这个方法的效果：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnsureCapacityTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ArrayList<span class="token operator">&lt;</span>Object<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">10000000</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> startTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">long</span> endTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"使用ensureCapacity方法前："</span><span class="token operator">+</span><span class="token punctuation">(</span>endTime <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行结果：</p><pre class=" language-java"><code class="language-java">使用ensureCapacity方法前：<span class="token number">2158</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnsureCapacityTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ArrayList<span class="token operator">&lt;</span>Object<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">10000000</span><span class="token punctuation">;</span>        list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> startTime1 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">ensureCapacity</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">long</span> endTime1 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"使用ensureCapacity方法后："</span><span class="token operator">+</span><span class="token punctuation">(</span>endTime1 <span class="token operator">-</span> startTime1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行结果：</p><pre class=" language-java"><code class="language-java">使用ensureCapacity方法前：<span class="token number">1773</span></code></pre><p>通过运行结果，我们可以看出向 ArrayList 添加大量元素之前最好先使用 <code>ensureCapacity</code> 方法，以减少增量重新分配的次数。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList</title>
      <link href="/2020/04/13/hou-duan/ji-he/arraylist/"/>
      <url>/2020/04/13/hou-duan/ji-he/arraylist/</url>
      
        <content type="html"><![CDATA[<h3 id="ArrayList-简介"><a href="#ArrayList-简介" class="headerlink" title="ArrayList 简介"></a>ArrayList 简介</h3><p>ArrayList 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用 <code>ensureCapacity</code> 操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。</p><p>它继承于 <strong>AbstractList</strong>，实现了 <strong>List</strong> 、<strong>RandomAccess</strong> 、<strong>Cloneable</strong> 、<strong>java.io.Serializable</strong> 这些接口。</p><p>在我们学数据结构的时候就知道了线性表的顺序存储，插入删除元素的时间复杂度为 <strong>O（n）</strong>,求表长以及增加元素，取第 i 个元素的时间复杂度为 <strong>O（1）</strong>。</p><p>ArrayList 继承了AbstractList ，实现了 List 。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。</p><p>ArrayList 实现了 <strong>RandomAccess 接口</strong> ， <strong>RandomAccess</strong> 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</p><p>ArrayList 实现了 <strong>Cloneable 接口</strong>，即覆盖了函数 <code>clone()</code> ，<strong>能被克隆</strong>。</p><p>ArrayList 实现 <strong>java.io.Serializable 接口</strong>，这意味着 ArrayList <strong>支持序列化</strong>，<strong>能通过序列化去传输</strong>。</p><p>和 Vector 不同，<strong>ArrayList 中的操作不是线程安全的</strong>！所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 <strong>Vector</strong> 或者 <strong>CopyOnWriteArrayList</strong> 。</p><h3 id="ArrayList-核心源码"><a href="#ArrayList-核心源码" class="headerlink" title="ArrayList 核心源码"></a>ArrayList 核心源码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> java<span class="token punctuation">.</span>util<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span>Consumer<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span>Predicate<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span>UnaryOperator<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token operator">&lt;</span>E<span class="token operator">></span>        <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">,</span> RandomAccess<span class="token punctuation">,</span> Cloneable<span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable<span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 8683452581122892189L<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 默认初始容量大小     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_CAPACITY <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 空数组（用于空实例）。     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> EMPTY_ELEMENTDATA <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//用于默认大小空实例的共享空数组实例。</span>      <span class="token comment" spellcheck="true">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 保存ArrayList数据的数组     */</span>    <span class="token keyword">transient</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// non-private to simplify nested class access</span>    <span class="token comment" spellcheck="true">/**     * ArrayList 所包含的元素个数     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 带初始容量参数的构造函数。（用户自己指定容量）     */</span>    <span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//创建initialCapacity大小的数组</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//创建空数组</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal Capacity: "</span><span class="token operator">+</span>                                               initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     *默认构造函数，DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10     */</span>    <span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。     */</span>    <span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//</span>        elementData <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果指定集合元素个数不为0</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// c.toArray 可能返回的不是Object类型的数组所以加上下面的语句用于判断，</span>            <span class="token comment" spellcheck="true">//这里用到了反射里面的getClass()方法</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>                elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 用空数组代替</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。      */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">trimToSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            elementData <span class="token operator">=</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>              <span class="token operator">?</span> EMPTY_ELEMENTDATA              <span class="token operator">:</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//下面是ArrayList的扩容机制</span><span class="token comment" spellcheck="true">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span><span class="token comment" spellcheck="true">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span>    <span class="token comment" spellcheck="true">/**     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量     * @param   minCapacity   所需的最小容量     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ensureCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> minExpand <span class="token operator">=</span> <span class="token punctuation">(</span>elementData <span class="token operator">!=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// any size if not default element table</span>            <span class="token operator">?</span> <span class="token number">0</span>            <span class="token comment" spellcheck="true">// larger than default for default empty table. It's already</span>            <span class="token comment" spellcheck="true">// supposed to be at default size.</span>            <span class="token operator">:</span> DEFAULT_CAPACITY<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> minExpand<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">//得到最小扩容量</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">// 获取默认的容量和传入参数的较大值</span>            minCapacity <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//判断是否需要扩容</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// overflow-conscious code</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span>            <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 要分配的最大数组大小     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_ARRAY_SIZE <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * ArrayList扩容的核心方法。     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// oldCapacity为旧容量，newCapacity为新容量</span>        <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span>        <span class="token comment" spellcheck="true">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span>        <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//再检查新容量是否超出了ArrayList所定义的最大容量，</span>        <span class="token comment" spellcheck="true">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span>        <span class="token comment" spellcheck="true">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// minCapacity is usually close to size, so this is a win:</span>        elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//比较minCapacity和 MAX_ARRAY_SIZE</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// overflow</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> MAX_ARRAY_SIZE<span class="token punctuation">)</span> <span class="token operator">?</span>            Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span>            MAX_ARRAY_SIZE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     *返回此列表中的元素数。      */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> size<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 如果此列表不包含元素，则返回 true 。     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//注意=和==的区别</span>        <span class="token keyword">return</span> size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 如果此列表包含指定的元素，则返回true 。     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 </span>        <span class="token keyword">return</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1      */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//equals()方法比较</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.     */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lastIndexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）      */</span>    <span class="token keyword">public</span> Object <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            ArrayList<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> v <span class="token operator">=</span> <span class="token punctuation">(</span>ArrayList<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span>            v<span class="token punctuation">.</span>elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>            v<span class="token punctuation">.</span>modCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> v<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 这不应该发生，因为我们是可以克隆的</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InternalError</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。      *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。     */</span>    <span class="token keyword">public</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;      *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。      *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。      *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）      */</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> size<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//调用System提供的arraycopy()方法实现数组之间的复制</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">></span> size<span class="token punctuation">)</span>            a<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Positional Access Operations</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>    E <span class="token function">elementData</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 返回此列表中指定位置的元素。     */</span>    <span class="token keyword">public</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 用指定的元素替换此列表中指定位置的元素。      */</span>    <span class="token keyword">public</span> E <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//对index进行界限检查</span>        <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        E oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//返回原来在这个位置的元素</span>        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 将指定的元素追加到此列表的末尾。      */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>        <span class="token comment" spellcheck="true">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span>        elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 在此列表中的指定位置插入指定的元素。      *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>        <span class="token comment" spellcheck="true">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>                         size <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。      */</span>    <span class="token keyword">public</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        E oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>                             numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// clear to let GC do its work</span>      <span class="token comment" spellcheck="true">//从列表中删除的元素 </span>        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。     *返回true，如果此列表包含指定的元素     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*     * Private remove method that skips bounds checking and does not     * return the value removed.     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fastRemove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>                             numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// clear to let GC do its work</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 从列表中删除所有元素。      */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 把数组中所有的元素的值设为null</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>        size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numNew <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> numNew<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> numNew<span class="token punctuation">)</span><span class="token punctuation">;</span>        size <span class="token operator">+=</span> numNew<span class="token punctuation">;</span>        <span class="token keyword">return</span> numNew <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numNew <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> numNew<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount</span>        <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> numNew<span class="token punctuation">,</span>                             numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> numNew<span class="token punctuation">)</span><span class="token punctuation">;</span>        size <span class="token operator">+=</span> numNew<span class="token punctuation">;</span>        <span class="token keyword">return</span> numNew <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。     *将任何后续元素移动到左侧（减少其索引）。     */</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">removeRange</span><span class="token punctuation">(</span><span class="token keyword">int</span> fromIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> toIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> toIndex<span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> toIndex<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> fromIndex<span class="token punctuation">,</span>                         numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// clear to let GC do its work</span>        <span class="token keyword">int</span> newSize <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token punctuation">(</span>toIndex<span class="token operator">-</span>fromIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> newSize<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        size <span class="token operator">=</span> newSize<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 检查给定的索引是否在范围内。     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rangeCheck</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">>=</span> size<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token function">outOfBoundsMsg</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * add和addAll使用的rangeCheck的一个版本     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">></span> size <span class="token operator">||</span> index <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token function">outOfBoundsMsg</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 返回IndexOutOfBoundsException细节信息     */</span>    <span class="token keyword">private</span> String <span class="token function">outOfBoundsMsg</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Index: "</span><span class="token operator">+</span>index<span class="token operator">+</span><span class="token string">", Size: "</span><span class="token operator">+</span>size<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 从此列表中删除指定集合中包含的所有元素。      */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">removeAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果此列表被修改则返回true</span>        <span class="token keyword">return</span> <span class="token function">batchRemove</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 仅保留此列表中包含在指定集合中的元素。     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。      */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">retainAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">batchRemove</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。      *返回的列表迭代器是fail-fast 。      */</span>    <span class="token keyword">public</span> ListIterator<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">listIterator</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> index <span class="token operator">></span> size<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token string">"Index: "</span><span class="token operator">+</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ListItr</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     *返回列表中的列表迭代器（按适当的顺序）。      *返回的列表迭代器是fail-fast 。     */</span>    <span class="token keyword">public</span> ListIterator<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">listIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ListItr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     *以正确的顺序返回该列表中的元素的迭代器。      *返回的迭代器是fail-fast 。      */</span>    <span class="token keyword">public</span> Iterator<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Itr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="ArrayList-源码分析"><a href="#ArrayList-源码分析" class="headerlink" title="ArrayList 源码分析"></a><font face="楷体" id="1" id="5">ArrayList 源码分析</font></h3><h4 id="System-arraycopy-和-Arrays-copyOf-方法"><a href="#System-arraycopy-和-Arrays-copyOf-方法" class="headerlink" title="System.arraycopy() 和 Arrays.copyOf() 方法"></a>System.arraycopy() 和 Arrays.copyOf() 方法</h4><p>通过上面源码我们发现这两个实现数组复制的方法被广泛使用而且很多地方都特别巧妙。比如下面 <font color="red">add(int index, E element)</font> 方法就很巧妙的用到了 <font color="red">arraycopy() 方法</font>让数组自己复制自己实现让 index 开始之后的所有成员后移一个位置：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 在此列表中的指定位置插入指定的元素。      *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>        <span class="token comment" spellcheck="true">//arraycopy()方法实现数组自己复制自己</span>        <span class="token comment" spellcheck="true">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> size <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>又如 <code>toArray()</code> 方法中用到了 <code>copyOf()</code> 方法：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。      *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。     */</span>    <span class="token keyword">public</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//elementData：要复制的数组；size：要复制的长度</span>        <span class="token keyword">return</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h5 id="两者联系与区别"><a href="#两者联系与区别" class="headerlink" title="两者联系与区别"></a>两者联系与区别</h5><p><strong>联系：</strong><br>看两者源代码可以发现 <code>copyOf()</code> 内部调用了 <code>System.arraycopy()</code> 方法。<br><strong>区别：</strong></p><ol><li><p><strong>arraycopy()</strong> 需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置。</p></li><li><p><strong>copyOf()</strong> 是系统自动在内部新建一个数组，并返回该数组。</p><h4 id="ArrayList-核心扩容技术"><a href="#ArrayList-核心扩容技术" class="headerlink" title="ArrayList 核心扩容技术"></a>ArrayList 核心扩容技术</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//下面是ArrayList的扩容机制</span><span class="token comment" spellcheck="true">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span><span class="token comment" spellcheck="true">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span> <span class="token comment" spellcheck="true">/**  * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量  * @param   minCapacity   所需的最小容量  */</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ensureCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span> minExpand <span class="token operator">=</span> <span class="token punctuation">(</span>elementData <span class="token operator">!=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span>         <span class="token comment" spellcheck="true">// any size if not default element table</span>         <span class="token operator">?</span> <span class="token number">0</span>         <span class="token comment" spellcheck="true">// larger than default for default empty table. It's already</span>         <span class="token comment" spellcheck="true">// supposed to be at default size.</span>         <span class="token operator">:</span> DEFAULT_CAPACITY<span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> minExpand<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//得到最小扩容量</span> <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">// 获取默认的容量和传入参数的较大值</span>         minCapacity <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//判断是否需要扩容,上面两个方法都要调用</span> <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>     modCount<span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 如果说minCapacity也就是所需的最小容量大于保存ArrayList数据的数组的长度的话，就需要调用grow(minCapacity)方法扩容。</span>     <span class="token comment" spellcheck="true">//这个minCapacity到底为多少呢？举个例子在添加元素(add)方法中这个minCapacity的大小就为现在数组的长度加1</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span>         <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">/**  * ArrayList扩容的核心方法。  */</span> <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//elementData为保存ArrayList数据的数组</span>    <span class="token comment" spellcheck="true">///elementData.length求数组长度elementData.size是求数组中的元素个数</span>     <span class="token comment" spellcheck="true">// oldCapacity为旧容量，newCapacity为新容量</span>     <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span>     <span class="token comment" spellcheck="true">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span>     <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>         newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//再检查新容量是否超出了ArrayList所定义的最大容量，</span>     <span class="token comment" spellcheck="true">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span>     <span class="token comment" spellcheck="true">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>         newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// minCapacity is usually close to size, so this is a win:</span>     elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    </code></pre><p>扩容机制代码已经做了详细的解释。另外值得注意的是大家很容易忽略的一个运算符：<strong>移位运算符</strong>。</p></li></ol><p><strong>简介：</strong>移位运算符就是在二进制的基础上对数字进行平移。按照平移的方向和填充数字的规则分为三种：<font color="red">&lt;&lt;（左移）</font>、<font color="red">&gt;&gt;（带符号右移）</font>和 <font color="red">&gt;&gt;&gt;（无符号右移）</font>。<br><strong>作用：</strong>对于大数据的 2 进制运算，位移运算符比那些普通运算符的运算要快很多，因为程序仅仅移动一下而已，不去计算，这样提高了效率，节省了资源。<br><strong>比如这里：</strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);<br>右移一位相当于除 2 ，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于oldCapacity / 2 。</p><p><strong>另外需要注意的是：</strong></p><ol><li><p>Java 中的 <strong>length 属性</strong>是针对数组说的,比如说你声明了一个数组，想知道这个数组的长度则用到了 length 这个属性。</p></li><li><p>Java 中的 <strong>length() 方法</strong>是针对字符串 String 说的，如果想看这个字符串的长度则用到 length() 这个方法。</p></li><li><p>Java 中的 <strong>size() 方法</strong>是针对泛型集合说的,如果想看这个泛型有多少个元素，就调用此方法来查看！</p></li></ol><h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><pre class=" language-java"><code class="language-java">    <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Itr</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token operator">&lt;</span>E<span class="token operator">></span>      <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">ListItr</span> <span class="token keyword">extends</span> <span class="token class-name">Itr</span> <span class="token keyword">implements</span> <span class="token class-name">ListIterator</span><span class="token operator">&lt;</span>E<span class="token operator">></span>      <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">SubList</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">RandomAccess</span>      <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ArrayListSpliterator</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Spliterator</span><span class="token operator">&lt;</span>E<span class="token operator">></span>  </code></pre><p>ArrayList 有四个内部类，其中的 <strong>Itr 是实现了 Iterator 接口</strong>，同时重写了里面的 <strong>hasNext()</strong> ，<strong>next()</strong> ， <strong>remove()</strong> 等方法；其中的 <strong>ListItr</strong> 继承 <strong>Itr</strong> ，实现了 <strong>ListIterator 接口</strong>，同时重写了 <strong>hasPrevious()</strong> ， <strong>nextIndex()</strong> ，<strong>previousIndex()</strong> ，<strong>previous()</strong> ，<strong>set(E e)</strong> ，<strong>add(E e)</strong> 等方法，所以这也可以看出了 <strong>Iterator 和 ListIterator 的区别：</strong>ListIterator 在 Iterator 的基础上增加了添加对象、修改对象、逆向遍历等方法，这些是 Iterator 不能实现的。</p><h3 id="ArrayList-经典-Demo"><a href="#ArrayList-经典-Demo" class="headerlink" title=" ArrayList 经典 Demo"></a><font face="楷体" id="6"> ArrayList 经典 Demo</font></h3><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Iterator<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayListDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> srgs<span class="token punctuation">)</span><span class="token punctuation">{</span>         ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> arrayList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Before add:arrayList.size() = %d\n"</span><span class="token punctuation">,</span>arrayList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"After add:arrayList.size() = %d\n"</span><span class="token punctuation">,</span>arrayList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Printing elements of arrayList"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 三种遍历方式打印元素</span>         <span class="token comment" spellcheck="true">// 第一种：通过迭代器遍历</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"通过迭代器遍历:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         Iterator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> it <span class="token operator">=</span> arrayList<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">while</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 第二种：通过索引值遍历</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"通过索引值遍历:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrayList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 第三种：for循环遍历</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"for循环遍历:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">for</span><span class="token punctuation">(</span>Integer number <span class="token operator">:</span> arrayList<span class="token punctuation">)</span><span class="token punctuation">{</span>             System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>number <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">// toArray用法</span>         <span class="token comment" spellcheck="true">// 第一种方式(最常用)</span>         Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> integer <span class="token operator">=</span> arrayList<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 第二种方式(容易理解)</span>         Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> integer1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>arrayList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         arrayList<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>integer1<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 抛出异常，java不支持向下转型</span>         <span class="token comment" spellcheck="true">//Integer[] integer2 = new Integer[arrayList.size()];</span>         <span class="token comment" spellcheck="true">//integer2 = arrayList.toArray();</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 在指定位置添加元素</span>         arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 删除指定位置上的元素</span>         arrayList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 删除指定元素</span>         arrayList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Object<span class="token punctuation">)</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 判断arrayList是否包含5</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ArrayList contains 5 is: "</span> <span class="token operator">+</span> arrayList<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 清空ArrayList</span>         arrayList<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 判断ArrayList是否为空</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ArrayList is empty: "</span> <span class="token operator">+</span> arrayList<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">Before add<span class="token operator">:</span>arrayList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span>After add<span class="token operator">:</span>arrayList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">5</span>Printing elements of arrayList通过迭代器遍历<span class="token operator">:</span><span class="token number">1</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">7</span> <span class="token number">9</span> 通过索引值遍历<span class="token operator">:</span><span class="token number">1</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">7</span> <span class="token number">9</span> <span class="token keyword">for</span>循环遍历<span class="token operator">:</span><span class="token number">1</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">7</span> <span class="token number">9</span> ArrayList contains <span class="token number">5</span> is<span class="token operator">:</span> <span class="token boolean">true</span>ArrayList is empty<span class="token operator">:</span> <span class="token boolean">true</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客主题之hexo-theme-matery的介绍</title>
      <link href="/2020/04/12/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/"/>
      <url>/2020/04/12/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/</url>
      
        <content type="html"><![CDATA[<p><a href="README.md">English Document</a> | <a href="https://blinkfox.github.io/" target="_blank" rel="noopener">演示示例</a> </p><blockquote><p>这是一个采用<code>Material Design</code>和响应式设计的 Hexo 博客主题。</p></blockquote><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>简单漂亮，文章内容美观易读</li><li><a href="https://material.io/" target="_blank" rel="noopener">Material Design</a> 设计</li><li>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</li><li>首页轮播文章及每天动态切换 <code>Banner</code> 图片</li><li>瀑布流式的博客文章列表（文章无特色图片时会有 <code>24</code> 张漂亮的图片代替）</li><li>时间轴式的归档页</li><li><strong>词云</strong>的标签页和<strong>雷达图</strong>的分类页</li><li>丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）</li><li>可自定义的数据的友情链接页面</li><li>支持文章置顶和文章打赏</li><li>支持 <code>MathJax</code></li><li><code>TOC</code> 目录</li><li>可设置复制文章内容时追加版权信息</li><li>可设置阅读文章时做密码验证</li><li><a href="https://gitalk.github.io/" target="_blank" rel="noopener">Gitalk</a>、<a href="https://imsun.github.io/gitment/" target="_blank" rel="noopener">Gitment</a>、<a href="https://valine.js.org/" target="_blank" rel="noopener">Valine</a> 和 <a href="https://disqus.com/" target="_blank" rel="noopener">Disqus</a> 评论模块（推荐使用 <code>Gitalk</code>）</li><li>集成了<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子统计</a>、谷歌分析（<code>Google Analytics</code>）和文章字数统计等功能</li><li>支持在首页的音乐播放和视频播放功能</li></ul><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>当你看到这里的时候，应该已经有一个自己的 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 博客了。如果还没有的话，不妨使用 Hexo 和 <a href="https://www.appinn.com/markdown/" target="_blank" rel="noopener">Markdown</a> 来写博客和文章。</p><p>点击 <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master" target="_blank" rel="noopener">这里</a> 下载 <code>master</code> 分支的最新稳定版的代码，解压缩后，将 <code>hexo-theme-matery</code> 的文件夹复制到你 Hexo 的 <code>themes</code> 文件夹中即可。</p><p>当然你也可以在你的 <code>themes</code> 文件夹下使用 <code>Git clone</code> 命令来下载:</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/blinkfox/hexo-theme-matery.git</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的  <code>theme</code> 的值：<code>theme: hexo-theme-matery</code></p><h4 id="config-yml-文件的其它修改建议"><a href="#config-yml-文件的其它修改建议" class="headerlink" title="_config.yml 文件的其它修改建议:"></a><code>_config.yml</code> 文件的其它修改建议:</h4><ul><li>请修改 <code>_config.yml</code> 的 <code>url</code> 的值为你的网站主 <code>URL</code>（如：<code>http://xxx.github.io</code>）。</li><li>建议修改两个 <code>per_page</code> 的分页条数值为 <code>6</code> 的倍数，如：<code>12</code>、<code>18</code> 等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果你是中文用户，则建议修改 <code>language</code> 的值为 <code>zh-CN</code>。</li></ul><h3 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h3><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"categories"</span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> categories<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token punctuation">---</span></code></pre><h3 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h3><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"tags"</span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> tags<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 18:23:38</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token punctuation">---</span></code></pre><h3 id="新建关于我-about-页"><a href="#新建关于我-about-页" class="headerlink" title="新建关于我 about 页"></a>新建关于我 about 页</h3><p><code>about</code> 页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"about"</span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> about<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token punctuation">---</span></code></pre><h3 id="新建友情连接-friends-页（可选的）"><a href="#新建友情连接-friends-页（可选的）" class="headerlink" title="新建友情连接 friends 页（可选的）"></a>新建友情连接 friends 页（可选的）</h3><p><code>friends</code> 页是用来展示<strong>友情连接</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>friends/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"friends"</span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/friends/index.md</code>，至少需要以下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> friends<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-12-12 21:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"friends"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"friends"</span><span class="token punctuation">---</span></code></pre><p>同时，在你的博客 <code>source</code> 目录下新建 <code>_data</code> 目录，在 <code>_data</code> 目录中新建 <code>friends.json</code> 文件，文件内容如下所示：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">[</span><span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/1_qq_27922023.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"码酱"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"我不是大佬，只是在追寻大佬的脚步"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://luokangyuan.com/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/4027734.jpeg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"闪烁之狐"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://blinkfox.github.io/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/avatar.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"ja_rome"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"平凡的脚步也可以走出伟大的行程"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"ttps://me.csdn.net/jlh912008548"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 <a href="https://github.com/ele828/hexo-prism-plugin" target="_blank" rel="noopener">hexo-prism-plugin</a> 的 Hexo 插件来做代码高亮，安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> i -S hexo-prism-plugin</code></pre><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置，主要配置如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">highlight</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">prism_plugin</span><span class="token punctuation">:</span>  <span class="token key atrule">mode</span><span class="token punctuation">:</span> <span class="token string">'preprocess'</span>    <span class="token comment" spellcheck="true"># realtime/preprocess</span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> <span class="token string">'tomorrow'</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">false    </span><span class="token comment" spellcheck="true"># default false</span>  custom_css<span class="token punctuation">:</span></code></pre><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>本主题中还使用到了 <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-search --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">search</span><span class="token punctuation">:</span>  <span class="token key atrule">path</span><span class="token punctuation">:</span> search.xml  <span class="token key atrule">field</span><span class="token punctuation">:</span> post</code></pre><h3 id="中文链接转拼音（可选的）"><a href="#中文链接转拼音（可选的）" class="headerlink" title="中文链接转拼音（可选的）"></a>中文链接转拼音（可选的）</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin" target="_blank" rel="noopener">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。</p><p>安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> i hexo-permalink-pinyin --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">permalink_pinyin</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">separator</span><span class="token punctuation">:</span> <span class="token string">'-'</span> <span class="token comment" spellcheck="true"># default: '-'</span></code></pre><blockquote><p><strong>注</strong>：除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">hexo-abbrlink</a> 插件也可以生成非中文的链接。</p></blockquote><h3 id="文章字数统计插件（可选的）"><a href="#文章字数统计插件（可选的）" class="headerlink" title="文章字数统计插件（可选的）"></a>文章字数统计插件（可选的）</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount" target="_blank" rel="noopener">hexo-wordcount</a>插件。</p><p>安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> i --save hexo-wordcount</code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，激活以下配置项即可：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">wordCount</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># 将这个值设置为 true 即可.</span>  <span class="token key atrule">postWordCount</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">min2read</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">totalCount</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><h3 id="添加-RSS-订阅支持（可选的）"><a href="#添加-RSS-订阅支持（可选的）" class="headerlink" title="添加 RSS 订阅支持（可选的）"></a>添加 RSS 订阅支持（可选的）</h3><p>本主题中还使用到了 <a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a> 的 Hexo 插件来做 <code>RSS</code>，安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-feed --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">feed</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> atom  <span class="token key atrule">path</span><span class="token punctuation">:</span> atom.xml  <span class="token key atrule">limit</span><span class="token punctuation">:</span> <span class="token number">20</span>  <span class="token key atrule">hub</span><span class="token punctuation">:</span>  <span class="token key atrule">content</span><span class="token punctuation">:</span>  <span class="token key atrule">content_limit</span><span class="token punctuation">:</span> <span class="token number">140</span>  <span class="token key atrule">content_limit_delim</span><span class="token punctuation">:</span> <span class="token string">' '</span>  <span class="token key atrule">order_by</span><span class="token punctuation">:</span> <span class="token punctuation">-</span>date</code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code> 文件，说明你已经安装成功了。</p><h3 id="修改页脚"><a href="#修改页脚" class="headerlink" title="修改页脚"></a>修改页脚</h3><p>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 <code>/layout/_partial/footer.ejs</code> 文件中，包括站点、使用的主题、访问量等。</p><h3 id="修改社交链接"><a href="#修改社交链接" class="headerlink" title="修改社交链接"></a>修改社交链接</h3><p>在主题的 <code>_config.yml</code> 文件中，默认支持 <code>QQ</code>、<code>GitHub</code> 和邮箱的配置，你可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://github.com/blinkfox<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tooltipped<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span> <span class="token attr-name">data-tooltip</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>访问我的GitHub<span class="token punctuation">"</span></span> <span class="token attr-name">data-position</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span> <span class="token attr-name">data-delay</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fa fa-github<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span></code></pre><p>其中，社交图标（如：<code>fa-github</code>）你可以在 <a href="https://fontawesome.com/icons" target="_blank" rel="noopener">Font Awesome</a> 中搜索找到。以下是常用社交图标的标识，供你参考：</p><ul><li>Facebook: <code>fa-facebook</code></li><li>Twitter: <code>fa-twitter</code></li><li>Google-plus: <code>fa-google-plus</code></li><li>Linkedin: <code>fa-linkedin</code></li><li>Tumblr: <code>fa-tumblr</code></li><li>Medium: <code>fa-medium</code></li><li>Slack: <code>fa-slack</code></li><li>新浪微博: <code>fa-weibo</code></li><li>微信: <code>fa-wechat</code></li><li>QQ: <code>fa-qq</code></li></ul><blockquote><p><strong>注意</strong>: 本主题中使用的 <code>Font Awesome</code> 版本为 <code>4.7.0</code>。</p></blockquote><h3 id="修改打赏的二维码图片"><a href="#修改打赏的二维码图片" class="headerlink" title="修改打赏的二维码图片"></a>修改打赏的二维码图片</h3><p>在主题文件的 <code>source/medias/reward</code> 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。</p><h3 id="配置音乐播放器（可选的）"><a href="#配置音乐播放器（可选的）" class="headerlink" title="配置音乐播放器（可选的）"></a>配置音乐播放器（可选的）</h3><p>要支持音乐播放，就必须开启音乐的播放配置和音乐数据的文件。</p><p>首先，在你的博客 <code>source</code> 目录下的 <code>_data</code> 目录（没有的话就新建一个）中新建 <code>musics.json</code> 文件，文件内容如下所示：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">[</span><span class="token punctuation">{</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"五月雨变奏电音"</span><span class="token punctuation">,</span>    <span class="token property">"artist"</span><span class="token operator">:</span> <span class="token string">"AnimeVibe"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://xxx.com/music1.mp3"</span><span class="token punctuation">,</span>    <span class="token property">"cover"</span><span class="token operator">:</span> <span class="token string">"http://xxx.com/music-cover1.png"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Take me hand"</span><span class="token punctuation">,</span>    <span class="token property">"artist"</span><span class="token operator">:</span> <span class="token string">"DAISHI DANCE,Cecile Corbel"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"/medias/music/music2.mp3"</span><span class="token punctuation">,</span>    <span class="token property">"cover"</span><span class="token operator">:</span> <span class="token string">"/medias/music/cover2.png"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Shape of You"</span><span class="token punctuation">,</span>    <span class="token property">"artist"</span><span class="token operator">:</span> <span class="token string">"J.Fla"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://xxx.com/music3.mp3"</span><span class="token punctuation">,</span>    <span class="token property">"cover"</span><span class="token operator">:</span> <span class="token string">"http://xxx.com/music-cover3.png"</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><blockquote><p><strong>注</strong>：以上 JSON 中的属性：<code>name</code>、<code>artist</code>、<code>url</code>、<code>cover</code> 分别表示音乐的名称、作者、音乐文件地址、音乐封面。</p></blockquote><p>然后，在主题的 <code>_config.yml</code> 配置文件中激活配置即可：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 是否在首页显示音乐.</span><span class="token key atrule">music</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">showTitle</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">title</span><span class="token punctuation">:</span> 听听音乐  <span class="token key atrule">fixed</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># 是否开启吸底模式</span>  <span class="token key atrule">autoplay</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># 是否自动播放</span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> '<span class="token comment" spellcheck="true">#42b983'</span>  <span class="token key atrule">loop</span><span class="token punctuation">:</span> <span class="token string">'all'</span> <span class="token comment" spellcheck="true"># 音频循环播放, 可选值: 'all', 'one', 'none'</span>  <span class="token key atrule">order</span><span class="token punctuation">:</span> <span class="token string">'list'</span> <span class="token comment" spellcheck="true"># 音频循环顺序, 可选值: 'list', 'random'</span>  <span class="token key atrule">preload</span><span class="token punctuation">:</span> <span class="token string">'auto'</span> <span class="token comment" spellcheck="true"># 预加载，可选值: 'none', 'metadata', 'auto'</span>  <span class="token key atrule">volume</span><span class="token punctuation">:</span> <span class="token number">0.7 </span><span class="token comment" spellcheck="true"># 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效</span>  <span class="token key atrule">listFolded</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># 列表默认折叠</span>  <span class="token key atrule">listMaxHeight</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 列表最大高度</span></code></pre><h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2" target="_blank" rel="noopener">开源中国在线工具</a>、<a href="http://encode.chahuo.com/" target="_blank" rel="noopener">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx" target="_blank" rel="noopener">站长工具</a>。</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2020-03-07 09:25:00</span><span class="token punctuation">---</span></code></pre><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2020-03-07 09:25:00</span><span class="token key atrule">author</span><span class="token punctuation">:</span> 聂文骏<span class="token key atrule">img</span><span class="token punctuation">:</span> /source/images/xxx.jpg<span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">cover</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">coverImg</span><span class="token punctuation">:</span> /images/1.jpg<span class="token key atrule">password</span><span class="token punctuation">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<span class="token key atrule">toc</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">summary</span><span class="token punctuation">:</span> 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要<span class="token key atrule">categories</span><span class="token punctuation">:</span> Markdown<span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> Typora  <span class="token punctuation">-</span> Markdown<span class="token punctuation">---</span></code></pre><h2 id="效果截图"><a href="#效果截图" class="headerlink" title="效果截图"></a>效果截图</h2><p><img src="http://static.blinkfox.com/matery-20181202-1.png" alt="首页"></p><p><img src="http://static.blinkfox.com/matery-20181202-2.png" alt="首页推荐文章"></p><p><img src="http://static.blinkfox.com/matery-20181202-3.png" alt="首页文章列表"></p><p><img src="http://static.blinkfox.com/matery-20181202-7.png" alt="首页文章列表"></p><p><img src="http://static.blinkfox.com/matery-20181202-8.png" alt="首页文章列表"></p><h2 id="自定制修改"><a href="#自定制修改" class="headerlink" title="自定制修改"></a>自定制修改</h2><p>在本主题的 <code>_config.yml</code> 中可以修改部分自定义信息，有以下几个部分：</p><ul><li>菜单</li><li>我的梦想</li><li>首页的音乐播放器和视频播放器配置</li><li>是否显示推荐文章名称和按钮配置</li><li><code>favicon</code> 和 <code>Logo</code></li><li>个人信息</li><li>TOC 目录</li><li>文章打赏信息</li><li>复制文章内容时追加版权信息</li><li>MathJax</li><li>文章字数统计、阅读时长</li><li>点击页面的’爱心’效果</li><li>我的项目</li><li>我的技能</li><li>我的相册</li><li><code>Gitalk</code>、<code>Gitment</code>、<code>Valine</code> 和 <code>disqus</code> 评论配置</li><li><a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子统计</a>和谷歌分析（<code>Google Analytics</code>）</li><li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 <code>hashcode</code> 值取余，来选择展示对应的特色图</li></ul><p><strong>我认为个人博客应该都有自己的风格和特色</strong>。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 <code>_config.yml</code> 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：</p><h3 id="修改主题颜色"><a href="#修改主题颜色" class="headerlink" title="修改主题颜色"></a>修改主题颜色</h3><p>在主题文件的 <code>/source/css/matery.css</code> 文件中，搜索 <code>.bg-color</code> 来修改背景颜色：</p><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */</span><span class="token selector"><span class="token class">.bg-color</span> </span><span class="token punctuation">{</span>    <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>to right, <span class="token hexcode">#4cbf30</span> <span class="token number">0%</span>, <span class="token hexcode">#0f9d58</span> <span class="token number">100%</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@-webkit-keyframes</span> rainbow</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">/* 动态切换背景颜色. */</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@keyframes</span> rainbow</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 动态切换背景颜色. */</span><span class="token punctuation">}</span></code></pre><h3 id="修改-banner-图和文章特色图"><a href="#修改-banner-图和文章特色图" class="headerlink" title="修改 banner 图和文章特色图"></a>修改 banner 图和文章特色图</h3><p>你可以直接在 <code>/source/medias/banner</code> 文件夹中更换你喜欢的 <code>banner</code> 图片，主题代码中是每天动态切换一张，只需 <code>7</code> 张即可。如果你会 <code>JavaScript</code> 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，<code>banner</code> 切换的代码位置在 <code>/layout/_partial/bg-cover-content.ejs</code> 文件的 <code>&lt;script&gt;&lt;/script&gt;</code> 代码中：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.bg-cover'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'background-image'</span><span class="token punctuation">,</span> <span class="token string">'url(/medias/banner/'</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.jpg)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在 <code>/source/medias/featureimages</code> 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 <code>_config.yml</code> 做同步修改。</p><h2 id="版本记录"><a href="#版本记录" class="headerlink" title="版本记录"></a>版本记录</h2><ul><li>v1.0.0<ul><li>新增了所有基础功能；</li></ul></li><li>v1.0.1<ul><li>调整 <code>css</code>、<code>js</code> 的文件请求路径在主题的<code>_config.yml</code>中配置，便于你更快捷的配置自己的 CDN；</li><li>新增代码是否折行为可配置，默认为折行；</li><li>默认激活 <code>TOC</code> 功能，并新增为某篇文章关闭 <code>TOC</code> 的 <code>Front-matter</code> 配置选项；</li><li>修复文章滚动时，高亮的目录选项不准确的问题；</li><li><code>IOS</code>下移除搜索框自动获得焦点属性，防止自动获得焦点后导致视图上移；</li></ul></li><li>v1.0.2<ul><li>升级了 <a href="https://materializecss.com/" target="_blank" rel="noopener">Materialize</a> 框架版本为<code>1.0.0</code>，重构和修改了升级过程中的部分文件或问题；</li><li>新增了首页封面的全屏轮播特效，可以将更重要的文章设置到首页轮播中；</li><li>修复首页第一个按钮是中文的问题</li><li>修复了 iPhone 上点击搜索输入获取焦点的问题；</li><li>修复了 iPhone 上输入框获取焦点后页面放大的问题；</li><li>修复一些文章或 UI 显示问题；</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/04/12/hello-world/"/>
      <url>/2020/04/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
